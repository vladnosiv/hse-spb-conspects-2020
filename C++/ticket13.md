## Билет 13
Автор: Кирилл Карнаухов

### Объект-функтор
Функтором называется класс (или структура) с перегруженным `operator()`. Могут применяться также, как и функции, однако имеют преимущества. Например, хотим посортировать массив по компаратору `a[i] * x`, где `x` — константа. Для обычной функции-компаратора пришлось бы заводить отдельную глобальную константу, что не очень хорошо. Однако в функторе мы можем хранить `x`, как поле класса. Возможная реализация:
```cpp
struct Comparator {
    int x;
    bool operator()(int a, int b) {
        return a * x < b * x;
    }
};
```
Теперь можно использовать этот функтор, например, для сортировки такого вида:
```cpp
template<typename T, typename Cmp>
void sort(Array<T>& array, Cmp cmp) {...}
```
Плюсом ко всему является то, что нет виртуальных вызовов.

### Применение в алгоритмах 
Функторы имеют огромное применение в `std::algorithm`. Например, имея функтор из предыдущего пункта, можно:
```cpp
std::vector<int> arr = {...};
std::sort(arr.begin(), arr.end(), Comparator{1}); //сортировка по возрастанию
std::sort(arr.begin(), arr.end(), Comparator{-1}); //сортировка по убыванию
```
Сюда можно передавать все, отчего можно вызвать `()` без аргументов. 

Примечание: в таких применениях функция сравнения должна быть транзитивной, иначе будет `Runtime Error`.

### Функторы, как компараторы в ассоциативных контейнерах
По умолчанию, `std::set` хранит значения по возрастанию. Хотим хранить, например, `int` по убыванию. Напишем компаратор:
```cpp
struct Comparator {
	bool operator()(int a, int b) {
		return a > b;
	}
};
```
Тогда, если написать `std::set<int, Comparator>`, то контейнер будет хранить ключи по убыванию. 

В общем, случае, нужно передавать функтор, который для `(a, b)` возвращает `true`, когда `a` должен идти *не позже* `b`. 

То же самое можно делать с `std::map` и другими ассоциативными контейнерами. 

Примечание: верно то же самое, что функция должна быть транзитивной. 

### Лямбды
Все это, конечно, очень круто, но иногда нам нужно использовать функтор всего в одном месте, и не как-то не хочется для этого создавать отдельный класс. Или нам хочется создать функцию внутри другой функции. Для этого придумали лямбды. Синтакис такой:
```cpp
auto func = [](int a, int b) {
	return a + b;
};
```
По сути, лямбды — это синтаксический сахар. На самом деле, это просто функтор с неизвестным типом. Применение:
```cpp
std::sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; }); //сортировка по убыванию
```
По умолчанию, в лямбдах нельзя ничего использовать, помимо глобальных переменных. Чтобы была возможность брать переменные из области видимости, есть так называемые захваты:
```cpp
int x = 100;

auto cmp1 = [x](int a, int b) { return a * x < b * x; }; //захват по значению (то есть значение x скопируется)
auto cmp2 = [&x](int a, int b) { return a * x < b * x; }; //захват по ссылке
auto cmp3 = [=](int a, int b, int c, std::string d) { ... }; //захват всей области видимости по значению
auto cmp4 = [&](int a, int b, float f) { ... }; //захват всей области видимости по ссылке

struct smth {
	void func() {
		auto f = [this]() { ... }; //захват всего экземпляра класса
	}
};
``` 

### Подробности лямбды
Как уже говорилось, нельзя явным образом получить тип лямбды. Однако, если мы хотим указать тип, например, для шаблонов, то можно использовать `decltype`.

Лямбда превращается в анонимный класс с `operator()`. 

Также, комппилятор все оптимизирует на этапе компиляции.

### mutable для лямбды
По умолчанию, лямбда создает функтор с `operator()`, который является `const-qualified`. Но иногда нам все-таки хочется менять переменные внутри оператора. Для этого можно написать `mutable`, то есть:
```cpp
int x = 10;
auto func = [&x](int a, int b) mutable {
	x--;
	return a * x < b * x;
};
```

### Возвращаемое значение
Лямбда сама узнает, какое возвращаемое значение у `operator()`. Например, здесь это `int`:
```cpp
auto func = [](int x) { return x * x; };
```
Если функция возвращает несколько значений, то компилятор смотрит на первый `return`. То есть следующий код **не** скомпилируется:
```cpp
auto func = [](int x, double y) {
	if (x > 0) {
		return 0;
	} else {
		return y;
	}
};
```
Это происходит, потому что компилятор не понимает, что именно мы хотим вернуть. Однако, можно использовать касты. 

Также можно явно указать тип возвращаемого значения:
```cpp
auto func = [](int a, double y) -> double { ... };
```

### Шаблонные параметры
Пока полноценные шаблоны для лямбд в C++ не завезли, но есть `auto`.  Например, можно так:
```cpp
std::vector<std::string> array = { ... };
std::sort(array.begin(), array.end(), [](const auto &fir, const auto &sec) {
	return a.length() < b.length();
});
```
Компилятор сам поймет, какие типы у аргументов. 

### Отличия от `std::function`
Внутри `std::function` хранится указатель на выделенный объект на куче, у которого нужно вызвать `()`. Можно ли хранить лямбды в `std::function`? Да, можно. Нужно ли? Нет, нужно пытаться этого избегать.

Проблема в том, что вызов метода у `std::function` — это виртуальный вызов и он не всегда будет соптимизирован. В то же время, лямбда не имеет виртульаных вызовов. Из-за этого `std::function` может работать сильно медленнее обычной лямбды.

Если хотите сохранить лямбду, можете сохранить ее в шаблон.