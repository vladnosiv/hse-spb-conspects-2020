## Билет 01 "Детали классов"
Автор: Герман Тарабонда

### Корректное объявление глобальные констант

Круче пользоваться `constexpr`, нежели `const`, потому что лучше производительность, никаких race condition. Не ускоряет вычисления в compile-time, но требует возможность. Например:

```C++
constexpr b = 3; // ОК
constexpr c = f(1); // ОК, если f -- может быть вычислена во время компиляции
```

Будет больно, со сложными объектами, потому что нельзя инициализировать на этапе компиляции: будут беды с порядком инициализвции разных единиц трансляций.

Если `const` вне класса, то он будет виден только в своей единице трансляции. При подключении хедера с константой в другие файлы произойдет копирование константы. Если мы хотим сохранить ссылки, то лучше `constexpr`. Например:

```C++
// inc.h
const std::string Flag = "--file"
// fst.cpp
#include "inc.h"
    ...&Flag... // (1) своя копия
// snd.cpp
#include "inc.h"
    ...&Flag... // (2) своя копия
// ссылка (1) != ссылке (2),
// чтобы были одинаковые пишем: constexpr char [] Flag = "--file"
```

### Корректное объявление статических констант-членов

Если у нас статические константы-члены классов, то константы видны везде и могут произойти беды, если мы захотим взять ссылку на константы:

```C++
// foo.h
struct Foo {
    static const int N = 60; // объявление
    static constexpr char Name[] = "NAME"; // объявление (аналогичное поведение до C++17)
}
// fst.cpp
... Foo::N ... // ОК
... Foo::Name[0] ... // ОК
... &Foo::N ... // может быть undefined reference на этапе линковки
... &Foo::Name[0] ... // может быть undefined reference на этапе линковки
// snd.cpp
... Foo::N ... // ОК
... Foo::Name[0] ... // ОК
... &Foo::N ... // может быть undefined reference на этапе линковки
... &Foo::Name[0] ... // может быть undefined reference на этапе линковки
```

В чем проблема? У константы должно быть и объявление, и должно быть определение ровно в одной единицы трансляции. Для решение проблемы добавлянм определение констант.

```C++
// foo.h
struct Foo {
static const int N = 60; // объявление
static constexpr char Name[] = "NAME"; // объявление (аналогичное поведение до C++17)
}
// fst.cpp
const int Foo::N; // инициализация и слово `statuc` не нужны
constexpr char Name[]; // в заголовочном файле не определяем, инчае будет UB на этапе компиляции
... Foo::N ... // ОК
... Foo::Name[0] ... // ОК
... &Foo::N ... // ОК
... &Foo::Name[0] ... // ОК
// snd.cpp
... Foo::N ... // ОК
... Foo::Name[0] ... // ОК
... &Foo::N ... // ОК
... &Foo::Name[0] ... // ОК
```

Самое важное: **если можем, то ставим constexpr, а в заголовках еще пишем inline**.

```C++
struct Foo {
    static inline const std::string NO = "NO"
    static inline constexpr char YES[] = "YES"
}
inline const std::string NO = "NO"
inline constexpr char YES[] = "YES"
```

*C C++17 inline можно писать у констант и у перемнных*

### Перегрузка `operator->`

Мы можем ее перегружать (вау). Это унарный оператор, а не бинарный (важно). Для перегрузки мы должны возвращать то, к чему мы можем применить стрелочку. Например:

```C++
template<typename T>
struct unique_ptr {
T* data;
// ....

// Унарный оператор *
      T& operator*()       { return *data; }
const T& operator*() const { return *data; }

// "Бинарный" оператор ->, второй аргумент - метод.
// Так что на самом деле унарный.
      T* operator->()       { return data; }
const T* operator->() const { return data; }
};
// ....
unique_ptr<std::string> s = ....;
s->size();
// На самом деле у нас выходит цепочка из вызовов operator->
// auto x = s.operator->(); x->size();
```

Получается, мы можем сделать и такую перегрузку:

```C++
struct Foo {
    auto operator->() {
        return std::make_unique<std::string>("hello");
    }
} f;
f->size();  // размер "hello" = 5; время жизни unique_ptr — до конца full expression (;)
// auto x = f.operator->(); x->size();
```

### Функции-друзья

Функция-друг позволяет пользоваться закрытой частью другого класса. Например:

```C++
class matrix;
class vector {
    int v[4];
    ...
    friend vector multiply(const matrix&, const vector&); // имеет доступ к matrix
};
class matrix {
    vector v[4];
    ...
    friend vector multiply(const matrix&, const vector&); // имеет доступ к vector
};
```

### friend class

Если мы хотим в классе воспользоваться приватной функцией другого класса, то она должна стать его другом. При этом мы не можем отдельно обозвать функцию другом. Синтаксис такой:

```C++
class Bar;
class Foo {
    friend class Bar; // не можем сказать, что конкретный метод класса Bar -- друг
    void privateFunc();
};
class Bar {
    void bar() {
        Foo f;
        f.privateFunc(); // ОК
    }
};
class Baz {
    void bar() {
        Foo f;
        f.privateFunc(); // не ОК
    }
};
```

### `using` для методов и полей: method hiding, изменение видимости

Правило такое: если в наследнике есть хотя бы один метод с именем `foo`, то в родителей мы уже не смотрим (даже если у нас override), то есть по умолчанию у нас method hiding.

```C++
struct Foo {
virtual int foo(int) { return 1; }
virtual int foo(double) { return 2; }
}
struct Bar: Foo {
void foo(int) override { return 3; }
}

Foo f;
std::cout << f.foo(1) << std::endl; // 1, смотрим на функции Foo
std::cout << f.foo(1.2) << std::endl; // 2, смотрим на функции Foo
Bar b;
std::cout << b.foo(1) << std::endl; // 3, не смотрим в родителя
std::cout << b.foo(1.2) << std::endl; // 3, не смотрим в родителя
Foo& b2 = b;
std::cout << b2.foo(1) << std::endl; // 3, смотрим на функции Foo,
// но так как foo(int) виртуальная и ссылается на Bar, то выводим 3
std::cout << b2.foo(1.2) << std::endl; // 2, смотрим на функции Foo
```

Если добавить `using`, то мы подключим все имена методов в текущий класс:

```C++
struct Foo {
    void foo(int);
};
struct Bar : Foo {
    // using Foo::foo;
    void foo(double);
};
Foo f;
f.foo(1.2); // int
f.foo(1); // int
Bar b;
b.foo(1.2); // double
b.foo(1); // double, после using - int.
b.Foo::foo(1); // int
Foo &b2 = b;
b2.foo(1.2); // int
b2.foo(1); // int
```

### `using` для методов и полей: использование для упрощения конструкторов

Зачем писать так:

```C++
struct my_exception : std::runtime_error {
    my_exception(const std::string& what_arg) : std::runtime_error(what_arg) {}
    my_exception(const char*        what_arg) : std::runtime_error(what_arg) {}
};
// ...
throw my_exception("Foo");
// ...
```

Если можно так:

```C++
struct my_exception : std::runtime_error {
    using std::runtime_error::runtime_error; // вместо нескольких конструкторов 1 строчка
};
// ...
throw my_exception("Foo");
// ...
```

С помощью `using` мы указываем компилятору, что мы собираемся наследовать конструкторы базового класса. И компилятор тогда сгенерирует код выполнения наследования и пересылки производного класса в базовый класс.
## Билет 02
Автор: Носивской Влад

* Зачем: во избежание коллизий. Например, пишем клиент-сервер, класс User есть и у клиента, и у сервера. Для этого заведем namespace client и namespace server. Теперь обращение client::User и server::User соответственно.

* Еще немного про мотивацию:
    * Можно использовать вложенные классы:

        ```C++
        class Database {
        public:
            class User { ... };
        };
        ```

        ```C++
        class Application {
        public:
            class User { ... };
            static Database connectToDb() { ... }
        };
        ```

        Здесь Database::User и Application::User - разные классы. Есть минусы: нужно писать много static-ов и в разных файлах использовать разные классы, либо заводить один God object, который содержит все функции и переменные со всех файлов. 
        
        Зачем здесь написан static для функции connectToDb? static функции как члены класса - это функции, которые не требуют наличия экземпляра класса для вызова (в данном случае мы не обязаны иметь экземпляр класса Application для вызова функции connectToDb).

    * А можно использовать namespaces:
        
        ```C++
        namespace database {
        class Database {
        public:
            class User { ... };
        };
        } // namespace database

        namespace application {
        class User { ... };
        database::Database connectToDb() { ... }
        } namespace application
        ```
* Немного про стиль при использовании namespace:
    * Обычно в одном файле один namespace. Внутри пишется без отступов (см. пример выше)
    * Имя в snake_case
    * namespace можно переоткрывать (в отличие от классов), в том числе в разных файлах. При этом содержимое конкатенируется. 
    * Если пишете библиотеку - хороший тон обернуть ее в namespace, а дальше творить в ней что угодно.
    * Заглянуть внутрь это ::, как у классов.

* Вложенные пространства имен.
    ```C++
    namespace database {
        namespace internal {
            void foo();
            void bar();
            struct Foo {};
        } // namespace internal
        struct User {};
    } // namespace database
    ```

    Начиная с С++11 можно писать так:

    ```C++
    namespace database::internal {
        void foo();
        void bar();
    } // namespace database::internal
    ```

    Чтобы обратиться к глобальному пространству имен, обратитесь будто к безымянному пространству:

    ```C++
    int foo;
    namespace bar {
        int foo;
        void some() {
            ::foo = 0; // Изменилось значение переменной, которая объявлена в глобальном пространстве имен.
        }
    } 
    ```

* Анонимное пространство имен.
    * Вспомним для начала, что такое internal linkage.
        
        header.hpp

        ```C++
        static int var = 82; // Передаю привет Гимназии №82 города Краснодара
        ```

        file1.hpp

        ```C++
        #include "header.hpp"

        void foo() { var = 239; }
        ```

        main.cpp
        ```C++
        #include <iostream>
        
        #include "header.hpp"
        #include "file1.hpp"

        int main() {
            foo();
            std::cout << var << std::endl;
        }
        ```

        Такая программа на выходе выдаст 82, а не 239, так как переменная var объявлялась как static, поэтому в каждом файле, где ее подключили, она своя.

    * Выше был показан сишный подход, в плюсах решили, что для internal linkage будут использовать анонимные пространства имен. А именно, для реализации того, что показано выше, в плюсах мы напишем:

        header.cpp

        ```C++
        namespace {

        int var = 82;

        }
        ```

        Теперь в плюсах не принято писать static-функции, их принято оборачивать в анонимные пространства имен.

* Про typedef и using, а главное - про отличие между ними.

    typedef пришел к нам из Си и означает он синоним имени. using же протаскивает имя.

    Например, можно сказать typedef int score_t; чтобы использовать score_t в коде, это будет псевдоним для int.

    * Вне контекста пространств имен typedef проигрывает using-у, так как ему очень плохо дается работа с шаблонами. Пример:

        ```C++
        template<typename T>
        using myAllocList = std::list<T, myAlloc<T>>;

        myAllocList<Object> ml;
        ```

        С typedef-ом написать подобный код будет больно и сложно (но все же возможно, пусть и использование усложнится).

    * В контексте пространств имен using позволяет протащить имя в точку.

        ```C++
        using database::Database;
        ```

    * Еще можно протаскивать целиком все имена из пространства имен:

        ```C++
        using namespace database;
        ```

        Здесь нужно быть очень аккуратным и уверенным, что не будет коллизий с именами. Поэтому не стоит писать в коде using namespace std; (привет контестам), ведь мы не знаем все имена из стандартной библиотеки. Например, там лежат функции left и right, а назвать так переменную иногда может хотеться. 

        Стоит отметить, что использование using namespace внутри .h/.hpp файлов идея сомнительная. Пользователь может добавить хедер и надеяться, что коллизий не будет.


## Билет 03 "Правила поиска имён (глобальных и внутри классов)"
Автор: Герман Тарабонда

### Где возникает qualified lookup, а где — unqualified

Если простым языком: то для  `foo()` происходит unqualified lookup (то есть просто поиск по имени), а для `::foo()` происходит qualified lookup.

Как вообще это происходит.

Unqulified lookup -- ищем в текущих `{}` где находится наш условный `foo()` и ищем объвление `foo()`. Подробнее об этом будет написано позже.

Qualified lookup -- ищем так как указано. Например: `model::animal::run()`. Сначала мы смотрим на `run()`. Вызывается qualified lookup. Для этого должны найти `animal`. Теперь нужно найти `animal`. Это тоже выполняется qualified lookup'ом. Чотбы найти `animal` нужно найти `model`. А вот поиск `model` происходит с помощью unqulified lookup.

### Явное обращение к глобальному пространству имён (`::foo`)

Все что не лежит явно в namespace'ах лежит в глобальном namespace. Чтобы обратиться к глобальному namespace можно явно указать `::foo`.

### Правила unqualified lookup в телах функций, методов, на уровне пространств имён ("глобально")

Правило такое: везде кроме классов ищем объвление до строчки использования. В классах мы изем во всем его объявлении. Например:

```C++
... // И в конце концов здесь (4)
namespace food {
... // Потом здесь (3)
class Meat {
... // Потом здесь (2)
void fry() {
... // Ищем здесь сначала (1)
slice();
... // Здесь не ищем
}
... // И здесь (2)
}
... // Здесь тоже не ищем
}
... // И тут не ищем
```

### Forward declaration для функций и классов, особенности неполных типов

В чем прикол forward declaration? На самом деле это довольно полезная штука. Оно позволяет программисту написать объявление чего-либо, а затем когда-нибудь написать определение этого чего-либо.

Пример из `lab_11` файл `bin_manip.h`:

```C++
#include <iosfwd>

std::ostream& hex(std::ostream&);
...
```

Здесь нужно только объявление `ostream`, поэтому достаточно подключения `iosfwd`. Это заметно ускоряет компиляцию программу, так как в `iosfwd` написаны только неполные объявления классов.

В `bin_manip.cpp` уже нужно подключать `iostream`, так как там есть вызов функций, которые не объявлены в `iosfwd`.

В `employee.cpp` тоже есть проблемы. Например:

```C++
#include "bin_manip.h"

...(ifstream& f) {
f >> read_le_int32(...);
}
```

Такого рода файл будет выдавать ошибку компиляции, так как не поймет, что `ifstream` - наследник `istream`, так как в `iosfwd` не указаны детали реализации. Поэтому дополнительно в этот файл нужно подключить `fstream`.

Кратко про неполные типы: объвлять можно, пользоваться нельзя. Пример:

```C++
class IncompleteClass; // forward declaration, неполный класс

void foo1(const IncompleteClass* p); // ОК
void foo2(const IncompleteClass& p); // ОК
void foo3(IncompleteClass p); // ОК
void foo4(IncompleteClass p); // не ОК, определение функции

IncompleteClass* p; // ОК
IncompleteClass p; // не ОК
```

## Билет 04
Автор: <Имя Фамилия>
## Билет 05
Автор: <Имя Фамилия>
## Билет 06
Автор: <Имя Фамилия>
## Билет 07
Автор: Денис Филиппов

* Синтаксис и пример
	* Появилась возможность наследовать одну структуру / класс от нескольких. Пример:

		``` C++
		struct PieceOfArt { std::chrono::time_point date; };      
		struct Music : PieceOfArt { std::string notes; };
		struct Lyrics : PieceOfArt { ... };
		struct Song : Music, Lyrics {
		Song(...) : Music(...), Lyrics(...), album(...) {}
		std::string album;
		// using Music::date;
		};
		```

	* Синтаксис как в обычном наследовании, только теперь мы через запятую перечисляем несколько предков.

	* Если возникает пересечение по именам, при обращении добавляем квалификатор. Если пересечений нет, то как обычно:

		``` C++
		Song s;
		x = s.Music::date;
		y = s.Lyrics::date;
		z = s.notes;
		```

	* Если есть using `Music::date`, то можно через `.` обращаться к date без `Music::`

		``` C++
		x = s.date;
		```

* Возможное представление в памяти, пример изменения адреса при `static_cast`

	* Возможное представление в памяти: сначала идут базовые объекты в порядке объявления (возможно с повторениями, в примере `PieceOfArt` повторится внутри `Music` и `Lyrics`), потом свои поля (в примере -- `album`).

  * Когда делаем `static_cast` (например, `static_cast<Lyrics *>(&s)`), меняется адрес указателя. Почему? Раньше у нас всегда был один предок, он располагался в начале куска памяти, потом шли поля. Поэтому первый байт у наследника и первый байт у предка совпадали. Теперь же, если мы кастуем к подобъекту, который не первый в памяти, указатель сдвинется до этого подобъекта.


* Порядок инициализации/уничтожения подобъектов и полей, как передать параметры конструкторам

	* Сначала инициализируются базовые объекты, причем в том порядке, в котором они указаны в объявлении класса (получается своеобразный dfs, т.к. заходим в первый базовый класс, у него заходим в первый базовый класс и т.д.). После этого как обычно (в порядке объявляния) инициализируются поля. Параметры конструкторам базовых классов передаются через запятую.

	* Уничтожение происходит в обратном порядке.


* Возможное дублирование базового класса и возникающие неоднозначности при приведении типа.

	* Нельзя кастовать напрямую `Song` к `PieceOfArt`. Это происходит из-за того что в `Song` хранятся два экземпляра `PieceOfArt` и возникает ситуация ambiguous base: непонятно к какому экземпляру кастовать. Сначала нужно прикастовать к `Music` / `Lyrics`, и только потом к `PieceOfArt` (в общем случаи также, на примере понятнее).
## Билет 08
Автор: <Имя Фамилия>
## Билет 09
Автор: <Имя Фамилия>
## Билет 10
Автор: Егор Лебедев
### Исключения, вылетающие из конструктора
В силу того, что у конструктора нет возвращаемого значения, ошибки возникшие на этапе создания объекта обычно обрабатываются с помощью исключений. Очень удобно, что если мы можем обратиться к переменной, то она всегда корректна (поскольку исключение кидается за фигурные скобочки, в которых переменная объявлена). Пример:
```c++
try {
    std::vector<int> a(178'000'000);
    ...
} catch (std::bad_alloc&) {
    ... // вектор уже не существует
}
... // вектор уже не существует
```

Отсюда идиома:

**RAII** - resource acquisition is initialization (получение ресурса есть инициализация): конструктор должен полностью проинициализировать класс и убедиться во всех инвариантах. А если не смог — кидаем исключение.

* Исключения могут вылетать в теле конструктора, тут их они обрабатываются так, как это происходит обычно.


* Также исключения могут вылетать из member initializer list (поля, базовые классы). Тогда не совсем ясно, что можно с этим вообще сделать. Конечно, существует такой синтаксис, называется **function try block**:
    ```c++
    struct Foo {
        Foo() try
            : vec(31'000)
            , f(new int[238])
            , s(new int[31]) {
            // ...
        } catch (...) {
            // ...
            /* throw; */
        }
        std::vector<int> vec;
        int** f;
        int** s;
    };
    ```
    В такой реализации при вылетевшем из строки `s(new int[31])` исключении невозможно будет обратиться к `f`, так как она будет "мертва" уже в момент входа в `catch`. Решение: объекты с автоматическим управлением временем жизни, такие как вектор, у которого деструктор вызовется автоматически.

    _Замечание_: в конца такого блока `catch` всегда неявно будет дописываться `throw` (только в конструкторах).

* В отдельный случай можно выделить **делигирующие конструкторы**:
    ```c++
    struct Foo {
        Foo(int x) {
            some_operation_a(x); // (1)
        }
        Foo() : Foo(10) {
            some_operation_b();  // (2)
        }
        ~Foo() {}
    };
    ```
    1. Если вызвали `Foo(10)` и `(1)` выкинуло исключение,
   то деструктор не вызовется.
    2. Если вызвали `Foo()` и `(1)` выкинуло исключение,
   то деструктор не вызовется.
    3. Если вызвали `Foo(10)` и `(2)` выкинуло исключение,
   то __деструктор вызовется__.

* Везде лучше использовать RAII:
    ```c++
    new X(new Y); // Тут `X` начинает владеть `Y` и обязан его удалить, "очевидно".
    ```
    1. Если кинул конструктор `Y`, то утечек нет.
    2. Если кинул конструктор `X`, то утечек нет — он _может_ удалить переданный во владение `Y`.
    3. Если кинул исключение `new Y`, то утечек нет.
    4. А вот если исключение кинул `new X`, то **утекло** `new Y`. До конструктора `X` дело не дошло.

    Решение: `X` сам себе создает `Y`, или `unique_ptr`.

* _Замечание (не только для конструкторов)_: в таком коде
    ```c++
    try {
        T** arr = new T[238];  // 1
        ... // 2
    } catch (const std::bad_alloc&) {
    }
    ```
    если `1` бросит исключение, то утечки памяти не будет, поскольку new либо отработает корректно, либо отчистит всю память которую выделил и вызовет все деструкторы. Если же `2` кинет исключение - утечка памяти, поскольку к `arr` мы уже не сможем обратиться, чтобы вызвать оператор `delete`

_Замечание_ про function try block: он может использоваться не только в конструкторах, но его необходимость отсутствует, поскольку он заменяется на привычный try-catch блок. Пример (возможно, на экзамене не нужен):
```c++
int f(int n = 2) try {
   ++n;
   throw n;
} catch(...) {
   ++n; // n все еще видна как параметр функции
   assert(n == 4);
   return n;
   // throw НЕ дописывается неявно
}
```
### Исключения из деструктора
По умолчанию исключения из деструктора бросать **запрещено** (неявно дописан `noexcept`), иначе вызывается `std::terminate`. Причина: деструкторы активно вызываются в момент, когда поймано какое-то другое исключение и происходит раскрутка стека, поэтому не ясно, как с этим справляться, если вылетит еще одно исключение (из деструктора).

### Преимущества и недостатки
* Преимущества:
    * Потенциально меньше кода
    * Явное разделение нормальной работы программы и исправления ошибки
* Недостатки:
    * Время работы программы может пострадать
    * Требуют аккуратности с ресурсами

### Непойманные исключения
Непойманные исключени - аварийно завершают программу, при это возможно такое, что программа поймет, что исключение никто не поймает, и завершится **без** раскрутки стека.

Решение: ловить их (например, оборачивать `main` в `try-catch` блок).

Лично у меня такой код ничего не выводил:
```c++
struct sd {
    ~sd() { cout << "finally"; }
};

int main() {
    sd var;
    throw int();
}
```
## Билет 11
Автор: Глеб Марьин

### Определения и примеры

Следующие понятия характеризуют код с точки зрения безопасности при работе с исключениями: как плохо будет коду, если выкинется исключение.

- No throw: исключения не кидаются, код всегда работает (или в хлам роняет программу, если не повезло).
  - Хороший пример: a = b; для простых типов.
  - Плохой пример: то же самое для сложных (в случае вектора может не хватить памяти).
  - Плохой пример: ввод-вывод.
  - Пример от автора: деструкторы тоже обычно не кидают, чтобы всегда можно было бы успешно произвести stack unwinding.

- Strong guarantee (сильная гарантия): если исключение и вылетело, то ничего не поменялось, например если оно вылетело из Foo::bar(), то Fo все ещё в корректном состоянии, можно без страха продолжать использовать.
  - Пример: list::push_back. Если памяти не хватило, то исключение вылетело, но список не поменялся вообще. Если упал конструктор копирования, то список не поменялся вообще.
  - Пример: vector::push_back. Если памяти не хватило, то исключение вылетело, но вектор не поменялся вообще. Тонкость: для этого надо, чтобы элементы могли копироваться с гарантирей strong. Или перемещаться, но тогда nothrow.

- Basic guarantee (базовая гарантия): если исключение и вылетело, то не произошло UB, все объекты в каком-то корректном состоянии (инварианты есть), нет утечек и прочих проблем.
  - Пример: vector::push_back, если мы не имеем права копировать/перемещать объекты без ошибок. Правда, всё ещё надо уметь уничтожать объекты.

- No guarantee: если исключение произошло, можно только завершить процесс. Если программа дошла до этого момента, то непонятно как давно случилась ошибка, и что плохого сделано уже, поэтому, чтобы не наломать дров стоит убить программу.

### Невозможность обеспечения basic guarantee на основе no guarantee

Если какой-то код не предоставляет даже базовой гарантии, и наш код использует этот небезопасный код, то наш тоже становится небезопасным, потому что если из плохого вылетит исключение, то мало ли что он попортил, он на то и no guarantee. Таким образом наш код тоже no guarantee.

### Обеспечение базовой гарантии при помощи RAII

Как сказал Егор в консультации: RAII помогает нам обеспечивать
базовую гарантию очень сильно. Если мы везде используем умные указатели,
везде пишем RAII, везде корректно пишем деструкторы, то базовая
гарантия всегда есть. То есть никогда не нужно писать явно try/catch, просто всегда есть базовая гарантия.

### Гарантии в шаблонах

В шаблонах мы не знаем заранее, какие гарантии предоставляет шаблонный
тип. Поэтому гарантии нашего кода зависят от гарантий этого типа.
Если методы класса не предоставляют какой-то гарантии, то мы,
работая с ними, не можем её предоставить. Например, пишем

```C++
template <typename T>
int foo(const T &a, const T &b) {
  if (a == b) {
    return 0;
  }
  T c(std::move(a));
  return 239;
}
```

Тогда гарантия будет определяться как худшая из `T::operator==(const T &)` и `T::T(T &&)`. Соответственно, если мы хотим, чтобы `foo` была
с какой-то гарантией, то нужно её потребовать от вызываемых методов.

### noexcept для функций и методов

Есть спецификатор функции `noexcept`, который говорит, что функция
или метод не может кинуть исключения, синтаксис

```C++
void foo() noexcept {
  some_noexcept_call_1();
  some_noexcept_call_2();
  2 + 2;
}

struct Foo {
  void foo() noexcept {};
};
```

Если внутри такой функции вылетит исключение, то случится ошибка
выполнения. Из `noexcept` можно вызывать только `noexcept`
функции и методы, точно также, как с const qualified.
Важно знать, что любая аллокация может кинуть, и все, кто её вызывают.
`new`, `std::make_unique`, `std::make_shared`, везде может вылететь
`std::bad_alloc`, что значит, что на куче не хватило памяти для
выделения места под объект.

### Условный noexcept, оператор noexcept

- Оператор noexcept позволяет узнать, может ли из выражения теоретически вылететь исключение (по спецификаторам noexcept).
- Возвращает true/false на этапе компиляции, не вычисляя выражение.

```C++
int bar()          { return 2; }
// ....
int a = 10;
vector<int> b;
static_assert(noexcept(a == 10));
static_assert(!noexcept(new int{}));   // Утечки не будет: не вычисляется.
static_assert(noexcept(a == foo()));
static_assert(!noexcept(a == bar()));  // bar() не noexcept
static_assert(!noexcept(b == b));      // vector::operator== не noexcept
bool x = noexcept(a = 10);
assert(x);
```

В шаблонах хотелось бы помечать функции и методы noexcept,
если это возможно. Для этого используется условный noexcept.

Можно вызвать оператор внутри спецификатора:

```C++
template<typename T> struct optional {
    optional() noexcept;
    optional(optional &&other) noexcept(    // noexcept только при условии...
       noexcept(  // ...что следующее выражение noexcept...
           T(std::move(other))  // вызов move-конструктора T
       )
   );
}
```

Получаем:

```C++
template<typename T> struct optional {
    optional() noexcept;
    optional(optional &&other) noexcept(noexcept(T(std::move(other))));
}
```

Применение. Полезно для vector со строгой гарантией исключений.
Если у элементов is_nothrow_move_constructible, то можно перевыделять буфер без копирований:

```C++
void increase_buffer() {
    vector_holder new_data = allocate(2 * capacity);  // Может быть исключение.
    for (size_t i = 0; i < len; i++)
        new (new_data + i) T(std::move(data[i]));     // Портим data, боимся исключений.
    data.swap(new_data);                              // Исключений точно нет.
}
```

Иначе мы обязаны копировать. Уже есть готовая функция:

```C++
void increase_buffer() {
    vector_holder new_data = allocate(2 * capacity);
    for (size_t i = 0; i < len; i++)
        new (new_data + i) T(std::move_if_noexcept(data[i]));
    data.swap(new_data);
}
```
## Билет 12
Автор: Кирилл Бриллинатов

### Строгая гарантия в конструкторах (ctor) и деструкторах (dtor)
#### ctor
В **ctor** обеспечить строгую гарантию исключений очень просто, так как до конструктора у объекта 
не было состояния - его не существовало. Тогда если в конструкторе вылетело исключение, 
то после этого состояние не поменяется. Единственное, надо следить за тем, чтобы не утекали 
ресурсы - этого проще всего добится использованием RAII-оберток. 
```cpp
struct HuffmanArchiver {
  HuffamnArchiver(const std::string& inputFilename, const std::string& outputFilename) 
      : inputFilename_{inputFilename}, outputFilename_{outputFilename} {}
      // если std::bad_alloc вылетело при копировании в outputFilename_, то inputFilename_ корректно удалится
private:
  std::string inputFileaname_, outputFilename_;
};
```

#### dtor 
В **dtor** обеспечение строгой гарантии должно быть выполнено, так как неявно все **dtor** помечены **noexcept**

### Общий алгоритм для проведения остальных операций

В общем случае, чтобы обеспечить строгую гарантию исключений для метода класса, можно провести необходимую операцию в два шага: 
1. Сделать все "кидающие" операции, не меняя состояния класса
2. Обновить (если надо) состояние класса с помощью "не кидающих" операций (например мувами)

```cpp
struct Matrix {
  void setColNRow(int cols, int rows) { 
    data_.resize(rows);
    for (auto& row : data_)  {
      row.resize(cols);
    }
  }
  // Плохая реализация, так как внутри цикла может выкинутся bad_alloc, а состояние объекта уже изменено

  void setColNRow(int cols, int rows) { 
    std::vector<std::vector<int>> newdata(rows);
    std::copy(data_.begin(), data_.end(), newdata.begin()); // копирование векторов
    for (auto& row : newdata) { 
      row.resize(cols);
    }
    std::swap(data_, newdata);
  }
  // Лучше, так как swap по умолчанию noexcept

private:
  std::vector<std::vector<int>> data_;
};
```
### Copy-swap trick
```cpp
struct DataHolder {
  DataHolder(const DataHolder& other) : size_{other.size_} { 
    try {
      data_ = new char[size_];
      std::memcpy(data_, other.data_, other.size_);
    } catch(... /* можно специфировать */) {
        delete[] data_;
    }
  }
  
  DataHolder& operator=(DataHolder other) { 
    std::swap(data_, other.data_);
    std::swap(size_, other.size_);
    return *this;
  }
  // При вызове создаетсь копия, того что передали (или мувается, но это видимо здесь неважно), 
  // затем происходит обмен полями с other и так как время жизни other ограничено фигурными 
  // скобаками, то он удалится и вызовется деструктор DataHolder и старый data_ удалится.

private:
  char* data_;
  std::size_t size_;
};
  
```
Из-за такой реализации код сильно упрощается.
### Проблемы с move-семантикой
Проблемы возникают, когда мы работаем с объектами, у которых move оператор присваивания или ctor 
не **noexcept**. Особенно сложно становится, когда мы храним такой объект по значению. Так как в 
таком случае, например, в move операторе приходится явно мувать этот объект. Можно скопировать, 
но у объекта может быть некопируемым (бывает достаточно часто). Получается, что иногда такие проблемы 
не получается решить и лучше для своих структур делать move ctor и оператор **noexcept**
#### Вывод
Пример, когда нельзя решить: пишем контейнер, хотим reserve - выделили новую память, туда
надо, либо мувать, либо копироавть. Move-оператор - не **noexcept**, нет ctor коипрования.

Пример, когда можно решить: все тоже самое - но есть ctor копирования, тогда можно полностью все скопировать в новый буфер, потом свопнуть указтели (это **noexcept**)

### pop в stack
При реализации метода pop в классе stack нельзя одновременно вернуть последний элемент и удалить его. До move-семантики нужно обязательно кипровать возвращаемое значение, но тогда во время возврата значения могло кинуться исключение, а состояние объекта уже поменялось.
```cpp
T pop() {
  return data_[--size_];
}
```
Но move-семантика не до конца решает (опять же может быть кидающий move ctor). В связи с этим разделют данную процедуру на две - top и pop
```cpp
void pop() {
  // как-то удалили последний элемент
  --size_;
}

T top() const {
  return data_[size_ - 1]; 
}
// можно добавить rev-qualified перегрузок - из временного стэка можно мувать, так как он умрет все равно.
```

## Билет 13
Автор: Кирилл Карнаухов

### Объект-функтор
Функтором называется класс (или структура) с перегруженным `operator()`. Могут применяться также, как и функции, однако имеют преимущества. Например, хотим посортировать массив по компаратору `a[i] * x`, где `x` — константа. Для обычной функции-компаратора пришлось бы заводить отдельную глобальную константу, что не очень хорошо. Однако в функторе мы можем хранить `x`, как поле класса. Возможная реализация:
```cpp
struct Comparator {
    int x;
    bool operator()(int a, int b) {
        return a * x < b * x;
    }
};
```
Теперь можно использовать этот функтор, например, для сортировки такого вида:
```cpp
template<typename T, typename Cmp>
void sort(Array<T>& array, Cmp cmp) {...}
```
Плюсом ко всему является то, что нет виртуальных вызовов.

### Применение в алгоритмах 
Функторы имеют огромное применение в `std::algorithm`. Например, имея функтор из предыдущего пункта, можно:
```cpp
std::vector<int> arr = {...};
std::sort(arr.begin(), arr.end(), Comparator{1}); //сортировка по возрастанию
std::sort(arr.begin(), arr.end(), Comparator{-1}); //сортировка по убыванию
```
Сюда можно передавать все, отчего можно вызвать `()` без аргументов. 

Примечание: в таких применениях функция сравнения должна быть транзитивной, иначе будет `Runtime Error`.

### Функторы, как компараторы в ассоциативных контейнерах
По умолчанию, `std::set` хранит значения по возрастанию. Хотим хранить, например, `int` по убыванию. Напишем компаратор:
```cpp
struct Comparator {
	bool operator()(int a, int b) {
		return a > b;
	}
};
```
Тогда, если написать `std::set<int, Comparator>`, то контейнер будет хранить ключи по убыванию. 

В общем, случае, нужно передавать функтор, который для `(a, b)` возвращает `true`, когда `a` должен идти *не позже* `b`. 

То же самое можно делать с `std::map` и другими ассоциативными контейнерами. 

Примечание: верно то же самое, что функция должна быть транзитивной. 

### Лямбды
Все это, конечно, очень круто, но иногда нам нужно использовать функтор всего в одном месте, и не как-то не хочется для этого создавать отдельный класс. Или нам хочется создать функцию внутри другой функции. Для этого придумали лямбды. Синтакис такой:
```cpp
auto func = [](int a, int b) {
	return a + b;
};
```
По сути, лямбды — это синтаксический сахар. На самом деле, это просто функтор с неизвестным типом. Применение:
```cpp
std::sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; }); //сортировка по убыванию
```
По умолчанию, в лямбдах нельзя ничего использовать, помимо глобальных переменных. Чтобы была возможность брать переменные из области видимости, есть так называемые захваты:
```cpp
int x = 100;

auto cmp1 = [x](int a, int b) { return a * x < b * x; }; //захват по значению (то есть значение x скопируется)
auto cmp2 = [&x](int a, int b) { return a * x < b * x; }; //захват по ссылке
auto cmp3 = [=](int a, int b, int c, std::string d) { ... }; //захват всей области видимости по значению
auto cmp4 = [&](int a, int b, float f) { ... }; //захват всей области видимости по ссылке

struct smth {
	void func() {
		auto f = [this]() { ... }; //захват всего экземпляра класса
	}
};
``` 

### Подробности лямбды
Как уже говорилось, нельзя явным образом получить тип лямбды. Однако, если мы хотим указать тип, например, для шаблонов, то можно использовать `decltype`.

Лямбда превращается в анонимный класс с `operator()`. 

Также, комппилятор все оптимизирует на этапе компиляции.

### mutable для лямбды
По умолчанию, лямбда создает функтор с `operator()`, который является `const-qualified`. Но иногда нам все-таки хочется менять переменные внутри оператора. Для этого можно написать `mutable`, то есть:
```cpp
int x = 10;
auto func = [&x](int a, int b) mutable {
	x--;
	return a * x < b * x;
};
```

### Возвращаемое значение
Лямбда сама узнает, какое возвращаемое значение у `operator()`. Например, здесь это `int`:
```cpp
auto func = [](int x) { return x * x; };
```
Если функция возвращает несколько значений, то компилятор смотрит на первый `return`. То есть следующий код **не** скомпилируется:
```cpp
auto func = [](int x, double y) {
	if (x > 0) {
		return 0;
	} else {
		return y;
	}
};
```
Это происходит, потому что компилятор не понимает, что именно мы хотим вернуть. Однако, можно использовать касты. 

Также можно явно указать тип возвращаемого значения:
```cpp
auto func = [](int a, double y) -> double { ... };
```

### Шаблонные параметры
Пока полноценные шаблоны для лямбд в C++ не завезли, но есть `auto`.  Например, можно так:
```cpp
std::vector<std::string> array = { ... };
std::sort(array.begin(), array.end(), [](const auto &fir, const auto &sec) {
	return a.length() < b.length();
});
```
Компилятор сам поймет, какие типы у аргументов. 

### Отличия от `std::function`
Внутри `std::function` хранится указатель на выделенный объект на куче, у которого нужно вызвать `()`. Можно ли хранить лямбды в `std::function`? Да, можно. Нужно ли? Нет, нужно пытаться этого избегать.

Проблема в том, что вызов метода у `std::function` — это виртуальный вызов и он не всегда будет соптимизирован. В то же время, лямбда не имеет виртульаных вызовов. Из-за этого `std::function` может работать сильно медленнее обычной лямбды.

Если хотите сохранить лямбду, можете сохранить ее в шаблон.

## Билет 14
Автор: Валера Головин
### Шаблонные классы
```C
// my_array.h
class IntArray {
private: 
    int *array;
    size_t size;
public:
    ...
}
```
Хотим сделать IntArray не только для int
#### Решение в Си
```C
// my_array.h
#define MyArray(TYPE) class MyArray_##Type { \
private: \
    TYPE *array; \
    size_t size; \
public: \
    ... \
}
// \ - перевод строки, а ## - конкатенация токенов.

// Применение
#include "my_array.h"
MyArray(int);
MyArray(double);

MyArray_int a;
```
##### Проблемы
* среда разработки никак не поможет
* очень странные ошибки могут быть, при опечатке в названии
* не работает с namespace: `MyArray(details::Foo)` не скомпилируется.

#### Решение в C++
```cpp
template<typename T>
class MyArray {
private:
    T *data;
    size_t size;
public:
    Array();
    Array(const Array& other);
    T& get(size_t i) { return data[i]; }
    T& operator[](size_t i);
};

<T>
T& MyArray<T>::operator[](size_t i) { return data[i]; }
<T>
T& MyArray<T>::Array() { ... }
```
* Здесь `MyArray` — шаблон, а `MyArray<int>` — класс.
* Все `MyArray<???>` абсолютно независимые.
* Компилируется методом "скопировали токены, заменили `T` на указанный тип".
  * Нет проблем с именами.
* Шаблон проверяется только на базовую синтаксическую корректность
  (скобочки сошлись), но не компилируется, пока не потребуется.
* В момент первого использования шаблон **инстанцируется** в конкретный класс и происходит компиляция. (_Инстанцирование (англ. instantiation) — создание экземпляра класса_)
  Тут уже можно получить несоответствия типов, не найденные перегрузки функций...
  * Инстанцируется отдельно: все поля класса (когда пытаемся создать объект), методы (когда вызываем конкретный метод; то есть какие-то методы могут для некоторых типов не работать). Пока методы в классе не вызываются они могут вообще не иметь смысла ("утиная типизация").
* Так как работает потенциально с любым типом,
  все реализации должны быть в `.h`.
 Компилятор должен понимать, какой для какого типа он должен компилить.
* До C++11 нельзя было писать `vector<vector<int>>`, потому что `>>` похоже на битовый сдвиг.

### Шаблонные функции
```cpp
template<typename T>
void print(const vector<T>& a) {
    for (const auto& i : a) {
        std::cout << i << '\n';
    }
}

// использование
vector<int> a;
print<int>(a);
print(a); // он решит уравнение и поймет, что T = int
```
Проверка наличия << у типа `T` происходит только в момент инстанцирования.
Если есть несколько перегруженных функций, то компилятор в каждой перегрузке решит
уравнение, если не получилось - выкинет из кандидатов, а среди выживших
проведёт конкурс "кто лучше подоходит под параметры".
```cpp
// объявление функций
template<typename T, typename V>
void foo(V x);

template<typename T, typename V>
void goo(T x);

template<typename T = void, typename V>
void hoo(V x);


// вызов этих функций
foo<int>(10.0); // T = int, V = double
foo(10.0); // не хватает информации для T

goo<int>(10.0); // не хватает информации для V
goo(10.0); // не хватает информации для V

hoo<int>(10.0); // T = int, V = double
hoo(10.0); // T = void, V = double
```
Еще один пример с сортировкой
```cpp
template<typename T, typename Cmp>
void sort(Array<T> &arr, Cmp fn);

// вызов
struct Comparator {
    bool operator()(int a, int b) {
        return a < b;
    }
};
Comporator c;
Array<int> arr;
sort<int, Comparator>(arr, c); // явное указание типов
sort(arr, c);
```
Работает быстрее, т.к. нет виртуальных вызывов.
Код можно сократить, используя лямбды.
```cpp
sort(arr, [](int a, int b) { return a < b; });
// Тип лямбды неизвестен, его явно не указать, только автовыводом.
```
### Строгая гарантия исключений
### Неявный конструктор присваивания
В стандарте есть:
```cpp
class Foo {
    Foo(const Foo&)  // Copy constructor
    Foo(Foo&&)       // Move constructor
    Foo& operator=(Foo&&)       // Move assignment
    Foo& operator=(const Foo&)  // Copy assignment (1)
    Foo& operator=(Foo)         // Copy assignment (2) для copy-and-swap.
};
```
* Если не объявлен копирующий конструктор, то его сгенерирует компилятор.
* Даже если есть другой подходящий конструктор

```cpp
class Foo {
    template<typename T>
    Foo(const T&) {}    // (1) не copy constructor.
    // Foo(const Foo&)  // (2) copy constructor.
    // (2) неявно объявлен и определён, приоритет выше (1).
};
```
При вызове `Foo new_foo( foo )` вызовится `Foo(const Foo&)`

## Билет 15
Автор: <Имя Фамилия>
## Билет 16
Автор: Илья Онофрийчук

## Псевдонимы шаблонов
Инстанцированный шаблон -- это обычный тип, поэтому для него можно написать `typedef`
```cpp
typedef vector<int> vi;
``` 
Для неинстанцированных шаблонов так писать уже нельзя, будет ошибка компиляции
```cpp
typedef vector v; //compilation error
``` 
В C++11 появился Alias template(псевдоним шаблонов). Конкретные примеры:
```cpp
template<typename T>
using v = vector<T>;

template<typename T>
using enable_if_t = typename enable_if<T>::type;
```
## Шаблонные методы в шаблонных классах
Рассмотрим пример:
```cpp
template<typename T>
struct shared_ptr {
    Storage *s;
    shared_ptr(T *data);
};

struct Base {};
struct Derived : Base {};

int main() {
    shared_ptr<Derived> d = ...;
    shared_ptr<Base> b = d;  // Упс, несовместимые типы.
}
```
Возникает проблема, что мы не можем записать указатель на наследника в указатель на базовый класс. 

Причина: `shared_ptr<Derived>` и `shared_ptr<Base>` -- разные типы, и они друг с другом не связаны. 

Решение: добавить шаблонный конструктор.
```cpp
template<typename T>
struct shared_ptr {
    ...    
    template<typename U>
    shared_ptr(const shared_ptr<U> &p);
};
```
Не смотря на то, что данный конструктор сработает даже если `U*` нельзя будет привести к `T*`, например `U = int` и `T = Derived`, произойдёт ошибка компиляции, то есть всё безопасно.

Аналогично любой метод у класса может быть шаблонным, при этом автовывод шаблонных параметров будет работать также как у шаблонных функций. Также, ***не конструктор*** можно  вызвать, явно указав параметры шаблонного метода. 

## Необходимость слов `typename` и `template` в некоторых контекстах

```cpp
template<typename T> struct A { using x = int; };
template<typename T> struct B {
    void foo() {
        A<T>::x * y; // (1)
    }
};
```
Неочевидно, что делает строчка `(1)`, это либо умножение, либо объявление переменной типа `A<T>::x`. Поэтому обычно компиляторы требуют явно писать слово `typename` перед зависимым типом, иначе они будут трактовать `x` как переменную. Строку `(1)` следует исправить слеующим образом:
```cpp
typename A<T>::x * y;
```
Пример про `template`:
```cpp
template<typename T> struct A { ... };
template<typename T> struct B {
    template<typename U> using C = A<U>;
};
template<typename T> struct D {
    B<T>::C<T>::x ... // (1)
};
```
В строке `(1)` компилятору неясно `C` -- это поле или шаблон. Поэтому нужно добавить перед `C` слово `template`. То есть строка `(1)` должна иметь следующий вид:
* Если `x` -- это переменная: 
```cpp
B<T>::template C<T>::x ...
```
* Если `x` -- это тип: 
```cpp
typename B<T>::template C<T>::x ...
```
Аналогичная проблема может возникнуть при вызове шаблонных функций, которым хотим явно задать параметры:
```cpp
template<typename T> struct Foo {
    template<typename U> 
    void foo();
};

template<typename T>
void bar() {
    Foo<T> x;
    x.template foo<char>();
}
```
Компилятору может потребоваться явное указание того, что `foo` -- это метод, так как он не знает метод ли это, поле или что-нибудь ещё.
## Специализации шаблонов функций
Частичной специализации функций не существует, есть только полная.

Пример специализации функции:
```cpp
template<typename T> 
void my_swap(T &a, T &b) { ... }

template<> 
void my_swap<std::string>(std::string &a, std::string &b) { ... }

template<typename T> 
void my_swap<std::vector<T>>(std::vector<T> &a, std::vector<T> &b) { ... } // compilation error, так как частичной специализации для функций не существует
```
Вместо частичной специализации функций предполагается использовать перегрузки.
```cpp
template<typename T> 
void my_swap(std::vector<T> &a, std::vector<T> &b) { ... } // Ok. Это перегрузка, а не специализация
```
Однако функцию `std::swap` можно по стандарту специализировать, но не перегружать. Стандарт запрещает добавлять свои перегрузки в пространство имён `std` .

## Отличия специализации шаблонов функций и перегрузок
```cpp
template<typename T>
void print(const T &) { } //(1)

template<>
void print<std::vector<int>>(const std::vector<int> &) { } //(2)

template<typename T>
void print(const std::vector<T> &) { } //(3)

int main() {
    std::vector<int> vi;
    std::vector<float> vf;

    print<std::vector<int>>(vi); //вызовется (2), T = std::vector<int>
    print<int>(vi); //вызовется (3), T = int

    print<std::vector<float>>(vf); //вызовется (1), T = std::vector<float>
    print<float>(vf); //вызовется (3), T = float
    return 0;
}
```

## Билет 17
Автор: <Имя Фамилия>
## Билет 18
Автор: Тарасов Денис

* ### `static_cast<Target>(expr)`
  Почти всегда, когда нам необходим какой-то cast следует использовать `static_cast`. Позволяет делать все неявные преобразования из `expr` в `Target`, а так же все обратные к ним.
  * Преобразования между числовыми типами, в том числе с потерей точности.
  ```C++
  char c = 1;
  int i = 2;
  i = c; // Неявное расширяющее преобразование
  i = static_cast<int>(c); // То же самое
  c = i; // Обратное к неявному
  c = static_cast<char>(i); // То же самое
  ```
  * Знает о конструкторах типа.
  ```C++
  struct Foo1 {};
  struct Foo2 {};
  struct Bar {
      Bar() : val(1) {}
      Bar(Foo1) : val(2) {}
      explicit Bar(Foo2) : val(3) {}
      int val;
  };  
  Bar bar;
  bar = static_cast<Bar>(Foo1());
  assert(bar.val == 2);
  bar = static_cast<Bar>(Foo2());
  assert(bar.val == 3);
  ```
  * Перобразование от базового типа к наследнику. `static_cast` следит за положением базовых классов в памяти и корректно пересчитывает указатели.
  ```C++
  struct Base1 {int x};
  struct Base2 {int y};
  struct Derived : Base1, Base2 {int x};
  Derived *d = new Derived;
  Base1 *b1 = d; // Можно неявно
  Base2 *b2 = d; // Можно неявно
  assert(b1 != b2);
  Derived *d1 = static_cast<Derived*>(b1); // Нужен static_cast
  assert(b1 == d1);
  Derived *d2 = static_cast<Derived*>(b2); // Нужен static_cast
  assert(b2 != d2);
  ```
  * Используется для преобразований от/к `void*` (может понадобиться например при вызове C-функций), при этом значение указателя не меняется. Нельзя таким образом делать преобразование между произвольными указателями.
  ```C++
  char *pc;
  int *pi;
  pc = static_cast<char *>(pi); // CE
  pi = static_cast<int *>(pc); // CE
  void *pv = static_cast<void*>(pi);
  assert(pv == pi);
  int *pi1 = static_cast<int*>(pv);
  assert(pi == pi1);
  ```
  * Можно глушить предупреждение о том, что переменная не используется.
  ```C++
  Foo foo;
  static_cast<void>(foo); // Убирает warning
  ```

* ### `reinterpret_cast<Target>(expr)`
Нужен очень редко, небезопасен. Говорит компилятору интерпретировать `expr` как `Target`. Не компилируется в процессорные инструкции.
  * Не дает никаких гарантий на промежуточные преобразования,
  ```C++
  int *a = new int();
  void *b = reinterpret_cast<void*>(a); // Нет гарантии, что a == b
  int *c = reinterpret_cast<int*>(b);
  assert(a == c); // Лишь здесь есть гарантия
  ```
  * Может преобразовывать любые указатели/ссылки в любые другие, но часто ведет к UB из-за strict aliasing (кажется, на лекциях о нем не было).
  ```C++
  float *d = reinterpret_cast<float*>(a);
  cout << *d; // UB: нарушение strict aliasing: доступ к int через несовместимый float*
  ```
  * Преобразование из пункта выше разрешаются для `char*` и `unsigned char*` (но не `signed char*`, который является отдельным типом). Является одним из немногих разумных использований.
  ```C++
  Foo *f = new Foo();
  char *c = reinterpret_cast<char*>(foo);
  unsigned char *uc = reinterpret_cast<char*>(foo);
  cout << *c << *uc; // Не UB
  ```
  * Может конвертировать указатели в числа и обратно, если хватает места.
  * Не следит за корректностью указателей при работе с наследованием, как это делает `static_cast`.

* ### `const_cast<Target>(expr)`
Отбрасывает константность у `expr`. UB, если `expr` был константным. Используется редко, не безопасен.
  * Пример с UB и без.
  ```C++
  vector<int> vec;
  const auto &rvec = vec;
  const_cast<vector<int>&>(rvec).clear();  // Окей, т.к. vec не const
  const vector<int> cvec;
  const_cast<vector<int>&>(cvec).clear();  // UB
  ```
  * Разумное использование при написании `operator[]`. Уже реализована константная перегрузка, при этом в неконстантной нужны те же действия. В обратную сторону может быть UB.
  ```C++
  const T& operator[](size_t i) const { .. }
  T& operator[](size_t i) {
      return const_cast<T&>(static_cast<const vector<T>&>(*this)[i]); // Нет UB
  }
  ```
  * Второе разумное использование: совместимость со старым C.
  ```C++
  void println(char *s); // Мы уверены, что s не меняется внутри функции
  println(const_cast<char*>("foo"));
  ```

* ### `dynamic_cast<Target>(expr)`
    Единственный каст, позволяющий работать с полиморфными объектами (те у кого есит виртуальные функции). Позволяет узнать тип объекта во время выполнения программы. В случае неверного преобразования возвращает `nullptr` для указателей и кидает исключение для ссылок. Безопасен.

    ```C++
    struct Base { virtual ~Base(); };
    struct Foo : Base {};
    struct Bar : Base {};
    struct Derived : Foo, Bar {};

    Foo *f = ..;
    Base *b = f;  // Неявное преобразование (basecast).
    Derived *d1 = static_cast<Derived*>(f);  // Derivedcast. UB, если f не был Derived.
    Derived *d2 = dynamic_cast<Derived*>(f);  // Derivedcast. nullptr, если f не был Derived.
    Bar *bar = dynamic_cast<Bar*>(f);  // Crosscast. static_cast не умеет. Сначала преобрзует
        // к Derived (derivedcast), а затем к Bar (basecast). В случае неудачи nullptr.

    Foo &rf = f;
    Derived &rd1 = static_cast<Derived&>(rf);  // Возможно UB.
    Derived &rd2 = dynamic_cast<Derived&>(rf);  // Возможно исключение std::bad_cast.
    ```

* ### ` C-style-cast`
  Пытается применить какую-то цепочку преобразований, чтобы код скомпилировался.
  * Синтаксис (есть и другой).
  ```C++
  int i = (int)10.5;
  T foo = (T)expr;
  ```
  * Пробует следующую цепочку преобразований
    * const_cast
    * static_cast и разрешает ещё пару преобразований
    * reinterpret_cast
    * На каждый вариант пытается ещё навесить const_cast
  * Не надо использовать совсем. Лучше попробовать `static_cast`, вызов конструктора или расписать цепочку явно.

* ### `dynamic_cast`, виртуальное наследование и еще примеры
```C++
struct Base { virtual ~Base() {} };
struct Foo : virtual Base {};
struct Bar : virtual Base {};
struct Derived : Foo, Bar {};
struct Derived2 : Derived {};
int main() {
    Derived *d = new Derived2; // Неявно от наследника к базе
    Derived2 *d2 = static_cast<Derived2*>(d); // Обратно нужен static_cast
    Derived *dd = d2; // Снова неявно как в первый раз
    const Base *a = d; // Можно неявно, т.к. Base только один (виртуальное наследование)
#if 0
    // Код внутри этого #if не компилируется из-за виртуального наследования.
    // Т.к. не знаем на этапе компиляции расположения Foo и Base.
    Foo *f = static_cast<Foo*>(a);
#endif
    const Foo *f = dynamic_cast<const Foo*>a; // Единственный выход,
        // т.к. он сможет изучить строение объекта во время выполнения.
    const Bar *b = dynamic_cast<const Bar*>(f); // Кажется, здесь crosscast.
    const Derived *ddd = static_cast<const Derived*>(f); // Foo не виртуальная база Derived, 
        // поэтому static_cast достаточно, но можно и dynamic_cast
    Derived *cddd = const_cast<Derived*>(static_cast<const Derived*>(f)); // Один нельзя, 
        // необходимо быть увереным в наших действиях
}
```
## Билет 19
Автор: Глеб Марьин

### Явные (explicit) и неявные (implicit) приведения типов

Как я понимаю, и как на консультации рассказал Егор: явные преобразования -
когда явно пишем круглые, или фигурные скобки, зависит от вызываемого конструктора,
то есть [direct initialization (cppreference)](https://en.cppreference.com/w/cpp/language/direct_initialization). Явным также является static_cast, например.
Если же пишем равно, или принимаем в функцию, или возвзращаем из функции, то
происходит неявное преобразование типа, то есть происходит [copy initialization (cppreference)](https://en.cppreference.com/w/cpp/language/copy_initialization#:~:text=The%20effects%20of%20copy%20initialization,destination%20object%3A%20see%20copy%20elision).

Определения direct и copy из конспекта, эти виды важны в этом билете.

Direct initialization: T t(foo, bar), T(foo, bar), static_cast\<T>(foo, bar), new T(foo, bar), : member(foo, bar).
Вызов конструктора T с параметрами foo и bar.
В C++11 добавили: T t{foo, bar};, T{foo, bar}, new T{foo, bar}, member{foo, bar}.
Copy initialization: T t = ..;, T t = {..}, f(t), return .., throw ...
Вызов не-explicit конструктора T с параметрами.
В C++11 можно делать несколько параметров.

Примеры:

```C++
struct Point {
    int x, y;
    Point() : x(), y() /* value initialization */ {}
    Point(int x_, int y_) : x(x_), y(y_) /* direct initialization */ {}
};
Point foo(Point p) { return {p.y, p.x} /* copy initialization */; }
int main() {
    foo(Point(10, 20));  // direct initialization
    foo({10, 20});       // copy initialization
    Point p1{10, 20};    // direct initialization
    Point p2 = {10, 20}; // copy initialization
}
```

### Оператор приведения типа, конструктор приведения

Можно приводить типы двумя способами:

- Сделать конструктор от любого другого типа

```C++
struct From { ... };
struct To {
    From(const From &) { ... }
};
```

В таком случае получится конструктор приведения типа.

- Сделать оператор приведения

```C++
struct To { ... };
struct From {
    operator To() { ... }
}
```

Получится оператор приведения типа.

Эти способы абсолютно симметричны, каждая команда выбирает способ приведения,
какой ей больше нравится (от Егора: лучше конструкторы).

### Модификатор explicit для конструкторов и операторов приведения

По умолчанию, если написан конструктор, или оператор приведения типа, то
могут выполняться неявные преобразования к этому классу, или из него соответственно.
Чтобы избежать нежелательных неявных преобразований, нужно использовать модификатор
explicit, который говорит, что конструктор или оператор приведения явный.

```C++
class A {};
class B {};
class C {
public:
    explicit C(const A &) { ... } // конструктор приведения из A -> C
    explicit operator B() { ... } // оператор приведения C -> B
};

int main() {
    A a;
    // C c = a; неявное преобразование, забанено explicit
    С с(a); // все еще можно, если определено - преобразование явное.
    // B b = c; тут уместно было бы использовать operator B(), если бы он не был explicit
    B b(c); // так можно, если определено - явное преобразование.
}
```

Без explicit неожиданные вещи могут происходить, поэтому 10 раз подумать, прежде чем
писать не explicit оператор.

### Особенности explicit operator bool() по сравнению с остальными explicit-операторами

С лекции:

Например, когда пишем свой unique_ptr, может захотеться проверять его на null, как с обычным указателем:

```C++
unique_ptr<Foo> f = ...;
if (f) { ...  }
// или
if (!f) { ... }
```

Можно сделать operator bool(). Но тогда неявные преобразования врубятся вообще везде, включая: 10 + f (преобразовали в bool, преобразовали в int, сложили). В C++03 для этого использовались костыли под названием "Safe bool idiom" (там возвращали хитрый тип, который нельзя в int, но можно в bool), в C++11 можно написать explicit operator bool(). Тогда можно будет преобразовать в bool, но только явно, как с explicit конструкторами (static_cast). Конкретно для bool захардкожено, что можно использовать в: if/while/for, !, ||, &&, ?: и ещё паре мест.

И добавить нечего, могу только пример привести

```C++
struct my_unique_ptr {
    explicit operator bool() { ... }
};

int main() {
    my_unique_ptr<int> a;
    if (a) {
        assert(false);
    }

    // bool a = p; explicit запрещает
    // int a = 10 + a; тоже неявное преобразование
    a.reset(new int(10));
    std::cout << (a ? *a : 0) << std::endl;
}
```

Не уверен, что это нужно, но вроде где-то это есть.
Можно делать шаблонные операторы приведения (ну вроде понятно, как делать конструкторы приведения). Например, написали свой BigInteger, тогда хочется написать операторы приведения к char, int, long long. В простом варианте так

```C++
#include <cstdint>
#include <iostream>

struct BigInteger
{
    std::int64_t first = 0;
    std::int64_t second = 0; // пусть храним 2 половины числа
    template <typename T>
    operator T()
    {
        return first + second; // какое-то осознанное приведение к типу, это, понятно, некорректно
    }
};

int main()
{
    BigInteger i;
    std::cout << static_cast<int>(i) << std::endl;
    std::cout << static_cast<long long>(i) << std::endl;
}
```

Это работает, я проверил. Еще можно добавить SFINAE, чтобы было совсем красиво.

```C++
#include <cstdint>
#include <iostream>
#include <string>

struct BigInteger
{
    std::int64_t first = 0;
    std::int64_t second = 0; // пусть храним 2 половины числа
    template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    operator T()
    {
        return first + second; // какое-то осознанное приведение к типу, это, понятно, некорректно
    }
};

int main()
{
    BigInteger i;
    std::cout << static_cast<int>(i) << std::endl;
    std::cout << static_cast<long long>(i) << std::endl;
    // std::cout << static_cast<std::string>(i) << std::endl; // не компилируется
}

```

Это тоже работает, я проверил.
## Билет 20
Автор: Денис Филиппов
## Билет 21
Автор: <Имя Фамилия>
## Билет 22
Автор: <Имя Фамилия>
## Билет 23
Автор: <Имя Фамилия>
## Билет 24
Автор: Пётр Сурков

### STL

* Containers libary
* Iterators libary
* Algoritms libary

Этот билет — Containers libary. В следующих билетах есть подробнее про каждый из видов контейнеров в нём. 

А ещё тут спрашиваются отличия, например, stdio.h и cstdio. В C используем первый, в C++ — второй, он не загрязняет глобальное пространство имён, а кладёт всё в `std::`

### Containers libary
Хранит объекты и управляет их временем жизни.

Должен быть

* Деструктор
* Хотя бы некоторые из конструкторов (копирования, перемещения, создания с параметрами, в зависимости от вызываемых методов)
* Обычно должны быть операторы присванивания (копирования, перемещения)

Контейнеры инвариантны по типам: `vector<Base*>` и `vector<Derived*>` - независимые контейнеры. Скопировать второй в первый не получится.

#### Аллокатор

Памятью управляет аллокатор - шаблонный класс, умеющий выделять, удалять память, инициализировать и удалять объект. 

Обычно используется `std::allocator`, он вызывает `new/delete`, которые можно [перегружать](https://habr.com/ru/post/490640/).

Аллокатор - сложный объект. должен уметь выделять не только `T`. Например, в `list<>` нужно уметь выделять внутренний тип (структуру с `T` и указателями на следующий элемент).

К тому же, до C++11 аллокаторы не могли иметь глобального состояния.

Из-за этого есть специфичные требования к написанию собственных аллокаторов.

#### Сложность и гарантии исключения
Стандарт обещает какое-то время работы. Например, копирование `vector<T>` происходит за `O(n)` копирований `T`. 

Базовая гарантия есть всегда, про строгую каждой операции надо читать в стандарте. Но если move T кидает исключения, то многие строгие гарантии рушатся. 

#### Виды контейнеров

* Последовательные (хранят элементы в фиксированном пользователем порядке): `vector`, `deque`, `list`, `forward_list`.
* Ассоциативные (сортируют элементы по ключу): `map`, `set`, `multimap`, `multiset`.
* Неупорядоченные ассоциативные (хэшируют элементы по ключу): `unordered_*`.
* Адаптеры (надстраиваются над другими контейнерами): `queue`, `priority_queue`, `stack`.

#### Стандартные операции, есть всегда:

* Конструктор по умолчанию `O(1)`
* Конструктор перемещения `O(n)` (при копировании `T` за `O(1)`)
* `a.swap(b)`, `swap(a,b)` за константу для всех, кроме `std::array`
* `.empty()` (константа)
* `.size()` (константа, даже у списка)
* Конструктор копирования, если `CopyInsertable` (есть конструктор копирования у `T`):
* `==`/`!=`, если объекты можно сравнивать на `==`/`!=`:    
* Для обобщённого программирования:
    * `vector<T>::value_type`
    * `vector<T>::reference_type`
    * `vector<T>::const_reference`
    * `vector<T>::size_type`
    * `vector<T>::difference_type`

#### Некоторые из гарантий исключений
##### noexcept
* `erase` (если только не бросит исключение move/copy оператор/конструктор в `vector`/`deque`)/`clear`/`swap`
* `pop_back`/`pop_front` (если есть)

##### Строгая гарантия
* `insert`/`emplace` (если вставляет один элемент, а не много сразу; и то только если с нужного конца, см. `vector`/`deque`)
* `push_back`/`push_front`/`emplace_back`/`emplace_front` (если есть)


#### Range-based for
Синтаксический сахар:
```cpp
for (DECL : EXPR) BODY
```
разворачивается как
```cpp
{
    auto range = EXPR;
    auto begin = std::begin(range);
    auto end = std::end(range);
    for (auto it = begin; it != end; ++it) {
        DECL = *it;
        BODY
    }
}
```
Функции `std::begin`/`std::end` вызывают внутренние `begin`/`end`, но перегружены для обычных массивов.

Есть тонкость. В `for (int &x : foo().bar()) { ... }` временное значение `foo()` не живёт, но `bar()` живёт. 

[Пример](https://cppinsights.io/) развёртки сахара.

Как видно из раскрытия, не стоит удалять/добавлять элементы в контейнер проходясь range-based for по нему.

В билете №28 можно прочитать про ranged-based ещё раз и найти информацию про связь с ADL, но в данном билете это не требуется.

#### Удаление, Инвалидация
Функция `.erase` возвращает итератор на элемент, который теперь занимает место первого удалённого элемента, либо `end()` при его отсутствии. 

Если идём по контейнеру, удаляя элементы по текущему итератору, то пишем `it=v.erase(it)`, вместо просто `v.erase(it)`. Иначе сделав `it++` на следующем шаге можем получить инвалидированный итератор, так как `it` указывал на уже удалённый элемент.

Про другие варианты инвалидации можно почитать в билете №28. 
## Билет 25
Автор: <Имя Фамилия>
## Билет 26
Автор: <Имя Фамилия>
## Билет 27
Автор: Кирилл Бриллиантов
### Адаптеры

Основное свойство - построены на основе других контейнеров.

#### stack и queue

Дек, у которог убрали половину методов

```cpp
template<typename T, typename Container = std::deque<T>>
struct stack {
    Container c;
    ... // методы связанные с итераторами
    void push(const T &value) { c.push_back(value); }
    void push(T &&value) { c.push_back(std::move(value)); }
    void pop() { c.pop_back(); }
    T& top() { return c.back(); }
    const T& top() const { return c.back(); }
};
template<typename T, typename Container = std::deque<T>>
struct queue {
    Container c;
    ....
    void push(const T &value) { c.push_front(value); }
    void push(T &&value) { c.push_front(std::move(value)); }
    void pop() { c.pop_front(); }
    T& front() { return c.front(); }
    const T& front() const { return c.front(); }
};
```
Следствием того, что они хранят контейнер является, то что инвалидация ссылок и итератров происходит тогда же, когда и у **Conatiner**. 

Вместо deque можно подставить что-то у чего есть соответсвующие методы.

#### priority_queue

Адаптор, представляющий собой двоичную кучу. Помимо контейнера использует компаратор и бибилиотечные функции связанные с кучей
```cpp
template<typename T, typename Container = std::vector<T>, typename Compare = std::less<T>>
struct priority_queue {
    Container c;
    ....
    const T& top() { return c[0]; }
    void push(const T &value) {
        c.push_back(value);
        std::push_heap(....);
    }
    void push(T &&value);
    void pop() {
        std::pop_heap(....);
        c.pop_back();
    }
};
```
- Итераторов нет. Можно получить доступ только к голове куче. 
- Методы что-то_heap можно вызывать самостоятельно. 
- Рабоатет быстрее, чем ```set<T>```

### bitset
Контейнер, хранящий последовательно ``` N ``` (известно на этапе компиляции) битов.
- конвертируется в строки для вывода на экран
- операции с индивижульными битами происходят медленее, чем в ```vector<char>```
- массовые же наоборот во много раз быстрее (Егор говорит в 10 раз)
- полезно для ускорения динамического программирования
```cpp
bitset<10> bs(   "0000010011");
bs.set(2);     // 0000010111
assert(bs.test(2));
assert(bs[2]);
bs.reset(2);   // 0000010011
bs.flip();     // 1111101100
assert(bs.count() == 7);
bs ^= bitset<10>("1100000001");
               // 0011101101
assert(bs.count() == 6);
```
## Билет 28
Автор: <Имя Фамилия>
## Билет 29
Автор: <Имя Фамилия>
## Билет 30
Автор: <Имя Фамилия>
## Билет 31
Автор: Александр Морозов
## Билет 32
Автор: <Имя Фамилия>
## Билет 33
Автор: Кирилл Карнаухов

### `std::tuple` и его друзья
У нас есть `std::pair<T, U>`, но работает только для двух параметров. Хотим больше. На помощь приходит `std::tuple<Args...>`, так называемый гетерогенный список (кортеж). Пример использования:
```cpp
std::tuple<int, vector<int>, string> t1(10, vector<int>(2), "foo");
auto t2 = std::make_tuple(10, vector<int>(2), "foo");  // t1 и t2 совпадают
int a = std::get<0>(t1);     // получить нулевой элемент
string c = std::get<2>(t1);  // Цикла по tuple<> нет
```

Теперь подробнее про функции, связанные с `std::tuple`:

* `std::get<index>(tuple)`. Получает элемент с номером `index` из `tuple`. Важно: `index` должен быть `constexpr` и находиться в полуинтервале `[0, std::tuple_size(tuple))`.
* `std::tuple_size(tuple)` возращает размер кортежа.
* `std::tuple_element<size_t I, template Tuple>::type` возвращает тип `Tuple` на позиции `I`. Возможное применение:
```cpp
auto mytuple = std::make_tuple (10, 'a');
std::tuple_element<0, decltype(mytuple)>::type first = std::get<0>(mytuple);
std::tuple_element<1, decltype(mytuple)>::type second = std::get<1>(mytuple);
```
* `std::make_tuple(Args...)` создает `std::tuple` из переданных аргументов. Пример выше.
* `std::tuple_cat` объединяет два кортежа:
```cpp
auto tuple1 = std::make_tuple(10, 10.0, 'c');
auto tuple2 = std::tuple_cat(t, t); //получится (10, 10.0, 'c', 10, 10.0, 'c')
```
* `std::apply(Func, Tuple)` вызывает `Func` с аргументами, взятыми из `Tuple`.

Полезный факт: есть каст из `std::pair<T, U>` в `std::tuple<T, U>`.
    
### Ссылки внутри `std::tuple`
Внутри можно хранить ссылки, пример:
```cpp
int a = 10; string b = "foo";
std::tuple<int&, string&> t(a, b);
t = std::make_tuple(20, "bar"); 
assert(a == 20);
assert(b == "bar");
```

### `std::tie` 
Пусть есть функция, которая возвращает `std::tuple<>` (или `std::pair<>`, так как есть каст), и мы хотим сопоставить каждому элементу из кортежа свою переменную. С C++11 можно делать так:
```cpp
std::tuple<int, int, char> func() { return { 1, 2, 'a' }; }
//здесь какой-то код

int first;
int second;
char third;

std::tie(first, second, third) = func();
assert(first == 1);
assert(second == 2);
assert(third == 'a');
```

### Structured binding (базовое)
Это более современная замена `std::tie`. Синтаксис:
```cpp
std::tuple<int, int, std::string> tuple(10, 15, "hello");
auto [first, second, third] = tuple; //происходит копирование
assert(first == 10);
assert(second == 15);
assert(third == "hello");
```
Можно навешивать `const/&/static`.

Полезные факты:

* Есть direct initialization (`auto [a, b, c](tuple)`) и list initialization(`auto [a, b, c]{tuple}`).
* Нельзя указать типы отдельных элементов.
* Нельзя вкладывать друг в друга (т.е. нельзя `[[a, b], c]`).
* Происходит на этапе компиляции, поэтому массивы можно (дальше будет подробнее), а вектора — нет.
* Может разворачивать простые структуры.

### Structured binding (применение)
* Получить результат `insert`:
```cpp
map<int, string> m = ...;
if (auto [it, inserted] = m.emplace(10, "foo"); inserted) {
	cout << "Inserted, value is " << it->second << '\n';
} else {
    cout << "Already exists, value is " << it->second << '\n';
}
```
* Итерирование по `map`:
```cpp
for (const auto &[key, value] : m) {
	cout << key << ": " << value << '\n';
}
```

### Structured binding (как работает и раскрывается)
Пусть есть выражение:
```cpp
map<int, string> m = { ... };
//здесь какой-то код
auto [key, value] = *m.begin();
```
Тогда произойдет следующее:

* Создается невидимая переменная:
```cpp
auto e = *m.begin();
using E = pair<const int, string>;
``` 
* Проверяется, что количество аргументов совпадает:
```cpp
static_assert(std::tuple_size_v<E> == 2);
```
* Объявляются новые переменные:
```cpp
std::tuple_element_t<0, E> &key   = get<0>(e);  // Или e.get<0>()
std::tuple_element_t<1, E> &value = get<1>(e);  // Или e.get<1>()
```

Важная особенность состоит в том, что возвращаемое значение не должно быть обязательно `std::tuple`. Можно туда сунуть все, что умеет делать `std::get<>` и `std::tuple_size<>` (метод или функция), которое можно найти с помощью `ADL`. 

### Structured binding (массивы, кортежи и структуры)
Есть три формы привязки:

* Массив фиксированного размера:
```cpp
Foo arr[3];
auto [a, b, c] = arr;
// превращается в
auto e[3] = { arr[0], arr[1], arr[2] };
Foo &a = e[0], &b = e[1], &c = e[2];
```

* Кортежоподобная структура (умеет `std::get<>` и `std::tuple_size<>`). Тогда будет включен `ADL` (упоминалось выше).
* Простые структуры данных:
```cpp
struct Point {
	int x, y;
}; // Привяжется.

struct Good { int a, b; }
struct GoodDerived : Good {};

struct BadPrivate { int a; private: int b; }  // Не привяжется: приватные запрещены.
struct BadDerived : Good { int c; }  // Не привяжется: все поля должны быть в одном классе.
```

### Structured binding (дополнительно)
В зависимости от `auto`/`auto&`/`const auto&` и инициализатора у нас получаются немного разные типы:

* `auto&` попробует привязать ссылку.
* `const auto&` продлит жизнь временному объекту.
* `auto` всегда скопирует объект целиком, а не просто его кусочки.

Если внутри объекта лежали ссылки, то может сломаться время жизни:
```cpp
namespace std {
    std::pair<const T&, const T&> minmax(const T&, const T&);
}
auto [min, max] = minmax(10, 20);  // Только копирование значений?
// перешло в
const pair<const int&, const int&> e = {10, 20};
// Сам `e` — не временный, поэтому продления жизни нет.
// e.first и e.second ссылаются на уже умершие 10 и 20.
const int &min = e.first;   // Oops.
const int &max = e.second;  // Oops.
```

Рекомендация: осторожно с функциями, которые возвращают ссылки.
С ними лучше `std::tie`.
## Билет 34
Автор: Александр Морозов
## Билет 35
Автор: Петя Сурков

### Мотивация метапрограммирования

#### Обобщения
* `std::distance` должен работать для разных итераторов по-разному:
    * Для random access iterator: `last - first`
    * Для остальных: `while (first != last) ++first;`
* `vector<T>::resize` может вести себя по-разному:
    * Если есть nothrow move constructor, то можно сразу перемещать элементы из буфера в буфер
    * Если нет, то надо всегда копировать, чтобы была strong exception safety.
* `std::any`/`std::function` — хотим small object optimization (если объект маленький, то выделим его на стеке, а не в куче). Т.е. поведение объекта зависит от типа, который скормили конструктору.

#### Компилятор делает рутину за нас
##### Пример 1:
```c++
int dijkstra(const Graph &g, int start, int end);
int floyd(const Graph &g, int start, int end);
int random_shuffle(const Graph &g, int start, int end);
// Хотим, чтобы можно было писать так:
check_answer_same(dijkstra, floyd, random_shuffle)(some_graph, 0, n - 1);
```
##### Пример 2:
Хотим сделать Serialize, аргументы которого представляют собой названия параметров и откуда их брать.
```c++
using PersonSerializer =
    Serialize<"name", &Person::getName, // &Person::getName - указатель на функцию
              "age", &Person::getAge>;
PersonSerializer s(std::cin); 
s << getPerson();  // name=Ivan, age=23
```
##### Пример 3:
Пишем калькулятор, хотим добавлять в него функции.
```c++
CalculatorFunctions functions = {
    {"sin", std::sin},
    {"func", [](double a, double b, double c) { return a + b * c; }}
};
```
##### Пример 4:
DFS в compile time (dependency injection): есть куча классов с конструкторами, надо собрать объект.

### Constexpr-вычисления

* Можно использовать многие конструкции языка: нельзя `goto` и не-`constexpr` функции.
* Можно использовать скалярные типы и типы с `constexpr`-конструктором и тривиальным деструктором (вроде `optional` от простых типов).
* С C++14 можно менять переменные внутри функций!
* До C++20 нельзя выделять память => нельзя `vector`

Пример:

```c++
constexpr int factorial(int n) {
    int res = 1;
    optional<int> unused1;
    // vector<int> unused2(n); нельзя до C++20 
    for (int i = 1; i <= n; i++)
        res *= i; // Можно с C++14
    return res;
}
static_assert(factorial(5) == 120);
// ...
assert(factorial(5) == 120);
std::vector<int> vec(factorial(5));
std::array<int, factorial(5)> arr;
```

### "Функции" из типов в типы
Ещё с C++98 бывают функции из типов в типы:
```c++
template<typename T>
struct iterator_traits {  // Общий случай
    using value_type = typename T::value_type;
    using difference_type = typename T::difference_type;
};
template<typename T>
struct iterator_traits<T*> {  // Частный случай
    using value_type = T;
    using difference_type = std::ssize_t;
};
```

Можно несколько входов, можно несколько выходов, можно
простые типы в качестве параметров шаблона.

Вызов:
```c++
typename iterator_traits<Iterator>::value_type x = *it;
```
Важно указать `typename`, иначе компилятор не поймёт смысл `<`, распарсит как знак меньше.

### "Функция" из типов в один тип
Если такая "функция" возвращает ровно один тип, есть конвенция:
```c++
template<typename T> struct remove_const {
    using type = T;
};
template<typename T> struct remove_const<const T> {
    using type = T;
};
```
В C++11 появились псевдонимы шаблонов (alias template), конвенция:
```c++
// В библиотеке делаем псевдоним с суффиксом _t
template<typename T> using remove_const_t = typename remove_const<T>::type;
// В коде
remove_const_t<const int> x = 10;
```
Получаем вызов функции, только `<>` вместо `()`, и в качестве параметров — и значения, и типы.

### "Функция" из типов в число
Напишем функцию, вычисляющую кол-во размерностей переданного массива
```c++
template<typename T> struct rank { // общий случай
    static constexpr size_t value = 0;
};
template<typename T> struct rank<T[]> { // передали массив, мы не знаем его размер
    static constexpr size_t value = rank<T>::value + 1;
};
template<typename T, size_t N> struct rank<T[N]> { // передали массив, мы знаем его размер
    static constexpr size_t value = rank<T>::value + 1;
};
static_assert(rank<int[][10]>::value == 2);
```
Раньше, такое [писали](https://stackoverflow.com/a/205000/767632) так `struct rank { enum { value = 10 }; }` из-за багов компилятора. Сейчас так не надо.

Заметим, что `constexpr`-функции тут не хватит. Она не сможет заглянуть внутрь типа.

С C++17 есть конвенция создавать template variable:
```c++
// В библиотеке делаем псевдоним с суффиксом _v
template<typename T> constexpr size_t rank_v = rank<T>::value;
// Тогда в коде сможем писать чуть короче
static_assert(rank_v<int[][10]> == 2);
```

Снова получаем вызов функции с `<>` вместо `()`.

### Стандартные вспомогательные классы
```c++
template<typename T> struct rank
    : std::integral_constant<size_t, 0> {}; // разобрали общий случай
template<typename T> constexpr size_t rank_v = rank<T>::value; // завели вспомогательный using
template<typename T> struct rank<T[]>
    : std::integral_constant<size_t, rank_v<T> + 1> {}; // частный случай
template<typename T, size_t N> struct rank<T[N]>
    : std::integral_constant<size_t, rank_v<T> + 1> {}; // частный случай
static_assert(rank<int[][10]>::value == 2);
```
Обычно пишут через них, так короче.

В библиотеке реализованы примерно так:
```c++
template<typename T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    constexpr operator T() const noexcept { return v; }
    ....
};
template<bool v>
struct bool_constant : integral_constant<bool, v> {};
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;
```

### Тонкости с числами в параметрах
Бывают ограничения. В специализации нельзя фиксировать значение, не фиксируя тип значения:
```c++
template<typename T, T N> struct fac { .... };
template<typename T>      struct fac<T, 0> { .... };  // Нельзя( Ну вдруг 0 не типа T на самом деле
```

Но их можно обходить, если специализировать и тип тоже, в этом поможет `integral_constant`:
```c++
template<typename /*N*/> struct fac {};  // Базовый случай, вызовется только если не integral_constant
// Не будет value, поэтому если нам дадут какую-то фигню а не число, то, скорее всего, будет ошибка компиляции
// это хорошо
template<typename T, T N> constexpr auto fac_v =
    fac<std::integral_constant<T, N>>::value;
template<typename T, T N> struct fac<std::integral_constant<T, N>>
    : std::integral_constant<T, N * fac_v<T, N - 1>> {};
template<typename T>      struct fac<std::integral_constant<T, 0>>
    : std::integral_constant<T, 1> {};
static_assert(fac_v<int, 5> == 120);
```
Если передать отрицательный `N`, то компилятор зациклится и на глубине примерно 1000 выдаст ошибку компиляции.
Так как это дело "открывали", могут быть ещё сюрпризы...

### Простые type traits
Классы или структуры, которые только таскают информацию в типах, называются "типажи" (traits).

Есть встроенные в язык "кирпичики" из `type_traits`, которые можно сделать самому:

* `is_same<A, B>` совпадают ли типы? 
* `is_convertible<From, To>` — можно ли сконвертировать `From` в `To` неявно? Это позволит узнать, например, будет ли компилиться `To foo() { return From{}; }`
* `is_nothrow_convertible<T, U>` — то, что выше, но и `noexcept`? Важно: просто смотрит на пометку `noexcept`, никак не смотрит на реализацию.
* `is_constructible<T, A, B>` — есть ли конструктор `T` из `A` и `B`?

### Пример алгоритма на типах на type traits
```c++
template<typename T> struct is_reference { constexpr static bool value = false; };
template<typename T> struct is_reference<T&> { constexpr static bool value = true; };
template<typename T> struct is_reference<T&&> { constexpr static bool value = true; };
```

### Ещё пример. Для сериализации
Пишем общий случай `template<typename T> struct serializer {};`, а дальше для каждого типа реализуем 
```c++
struct serializer {
    static std::string serialize(const T&);
    static T deserialize(std::string);
}
```
### Сложные type traits
Некоторые принципиально требуют поддержки компилятора:

```c++
// Цитата из libc++ Егора: вызываем кусок компилятора  __is_polymorphic
template<typename _Tp> struct is_polymorphic
  : public integral_constant<bool, __is_polymorphic(_Tp)> { };
```

Какие-то можно писать самому, но лучше не надо:
```c++
template<typename> struct is_integral       : false_type {};
template<>         struct is_integral<int>  : true_type {};
template<>         struct is_integral<char> : true_type {};
// И так далее; зависит от компилятора и библиотеки.
```

Некоторые есть в библиотеках (например, `boost::function_traits`. Позволяет узнать кол-во аргументов, их типы, тип возвращаемого значения). 

Для функций одного аргумента легко реализовать самим:
```c++
template<typename> struct function_traits {};
template<typename Ret, typename Arg0>  // Можно написать обобщённо для N аргументов.
struct function_traits<Ret(*)(Arg0)> {
    static constexpr std::size_t arity = 1;
    using return_value = Ret;
    using arg_0 = Arg0;
};
```

### Расширяемые type traits
Некоторые traits предполагаются для расширения пользователем.

Пример: `iterator_traits`. Это такое хранилище свойств (как и любой traits) итераторов. Например,  чтобы мы могли одинаковым кодом спросить `value_type` и у итератора на вектор, и у указателя на массив. По умолчанию берёт `typename` изнутри типа, но можно сделать что-нибудь своё для своего итератора:
```c++
namespace std {
    template<typename T> struct iterator_traits<MyMagicIterator<T>> {
        using value_type = typename MyMagicIterator<T>::magic_value_type;
        // ....
    };
}
```
в примере выше мы захотели, чтобы у нашего итератора в качестве `value_type` брался не просто `value_type` нашего итератора, а его `magic_value_type`.

Ещё пример: `char_traits` задаёт логику работы с "символами", [пример с SO](https://stackoverflow.com/a/5319855/767632):

```c++
  struct CaseInsensitiveTraits : std::char_traits<char> {
      static bool lt(char a, char b) { return tolower(a) < tolower(b); } 
      static bool eq(char a, char b) { return tolower(a) == tolower(b); }
      static int compare (const char *a, const char *b, size_t length) {
          ....
      }
  };
  using CaseInsensitiveString = std::basic_string<char, CaseInsensitiveTraits>;
```

* Получили строчки `CaseInsensitiveString`, которые сравнивается без учёта регистра.
* И заодно дают UB на не-латинице из-за `tolower`.
* Говорят, что из-за своих `char_traits` получается неудобный ужас :(
## Билет 38
Автор: Кирилл Карнаухов

### SFINAE (начало)
Расшифровка: Substitution Failure Is Not An Error.

Означает, что если при подстановке типовых параметров в функцию/специализацию/конструктор что-то не удалось вывести через `::`, то просто забиваем на конкретную перегрузку функции/специализацию/конструктор и пробуем дальше.

Мотивация: хочется, чтобы работали всякие `is_move_constructible` — они смотрят только на объявление, не определение.

Пример:
```cpp
template<typename T>
void duplicate_element(T &container, typename T::iterator iter) {
    container.insert(iter, *iter);
}

template<typename T>
void duplicate_element(T *array, T *element) {
   assert(array != element);
   *(element - 1) = *element;
}

int main() {
    std::vector a{1, 2, 3};
    duplicate_element(a, a.begin() + 1);
    int b[] = {1, 2, 3};
    duplicate_element(b, b + 1);  // Нет ошибки, когда пробуем первую перегрузку: не бывает int[]::iterator, но это не ошибка компиляции. SFINAE.
}
```

Отличается от hard compilation error тем, что если произошла ошибка при подстановке, то это ошибки компиляции не будет (будет только тогда, когда ни одна специализация/перегрузка не подошла). 

Важна следующая тонкость: SFINAE работае только на один уровень. То есть, если сделать свою структуру, а внутри `using`, то он должен быть нормальным. Пример:
```cpp
struct BotvaHolder {
    using botva = int;
};

//****рабочая версия****
template<typename T> using GetBotva = typename T::botva;

template<typename T>
void foo(T, GetBotva<T>) {  // Просто псевдоним, так можно, проблемы возникают как бы "тут".
    std::cout << "1\n";
}
//****конец рабочей версии****
//****нерабочая версия****
template<typename T>
struct GetBotva {
    using type = typename T::botva;  // hard compilation error.
};

template<typename T>
void foo(T, typename GetBotva<T>::type) {  // Ошибка компиляции, потому что проблема возникла уже внутри GetBotva.
    std::cout << "1\n";
}
//****конец нерабочей версии****

template<typename T>
void foo(T, std::nullptr_t) {
    std::cout << "2\n";
}

int main() {
    foo(BotvaHolder(), 10);  // 1
    foo(BotvaHolder(), nullptr);  // 2
    // foo(10, 10);  // CE
    foo(10, nullptr); // 2
}
```

### SFINAE (`auto` + `decltype`)
Первый способ вырезать перегрузку (и т.д.). Пример:
```cpp
template<typename T>
auto add(const T &a, const T &b) -> decltype(a + b) {
    return a + b;
}

auto add(...) { 
    return 239;
}

int main() {
    std::cout << add(10, 20) << "\n";
    std::cout << add(nullptr, nullptr) << "\n";
}
```
Пояснения. Если `a` и `b` можно сложить, то `a + b` корректно определено, то есть можно выполнить `decltype(a + b)` и получить правильный тип. Тогда эта перегрузка не будет вырезана. А так как аргумент `...` имеет приоритет ниже, то будет использована именно первая перегрузка. Таким образом, если два объекта можно сложить, то это произойдет.

Иначе эта перегрузка будет вырезана по SFINAE, так как произошла ошибка подстановки. В таком случае будет вызвана вторая функция, так как осталась только она.

Если хотим проверить, можно ли сложить два числа, то можно сделать так:
```cpp
template<typename T>
auto isAddable(const T &a, const T &b) -> decltype(a + b, true) {
    return true;
}

auto isAddable(...) { 
    return false;
}
```
Если `operator,` не перегружен для `T`, то это сработает следующим образом. Выполнится выражение `a + b` и проверится, что это возможно. И если это было успешно, то возвращаемое значение будет `decltype(true) = bool`, так как `operator,` возвращает то, что справа. Иначе будет вызвана вторая перегрузка.

Заключение. Метод хороший, если хочется проверить лишь корректность выражения. Не работает для конструкторов, потому что нет возвращаемого значения.

### SFINAE (Фиктивный шаблонный параметр-тип, `decltype` и `nullptr`)
Второй способ. Пример:
```cpp
struct Foo {
    template<typename T, typename = decltype(std::declval<T>().foo())>
    Foo(T) {
        std::cout << "1\n";
    }

    template<typename T>
    explicit Foo(T) {
        std::cout << "2\n";
    }
};

struct Bar {
    void foo() {}
};

int main() {
    Foo f1 = Bar();  // 1, потому что 2 недоступно из-за explicit
    Foo f2(10);      // 2, потому что 1 недоступно из-за SFINAE
}
```
Пояснение. Пытаемся подставить `int`. Но возникает проблема, что у `int` нет `.foo()`, поэтому по SFINAE конструктор вырезается.

К сожалению, для `Bar` оба конструктора одинаково подходят, поэтому, как вариант, необходим `explicit`. 

Также можно изменить `typename` на конкретный тип. Например:
```cpp
struct Foo {
    template<typename T, std::void_t<decltype(std::declval<T>().foo())>* = nullptr>
    Foo(T) {
        std::cout << "1\n";
    }

    template<typename T>
    explicit Foo(T) {
        std::cout << "2\n";
    }
};
```
*Насколько я понял, то, что дальше в этом пункте, — не для экзамена, но на всякий случай напишу*

Мотивация предыдущего изменения в том, что мы не можем два раза использовать что-то вроде `template<typename T, typename = decltype(std::declval<T>().foo())>`, так как в таком случае компилятор не различит перегрузки. Но если использовать `void* = nullptr`, то все будет хорошо.

Но есть еще один подводный камень. Он состоит в `std::void_t`. Компилятор просто соптимизирует и скажет, что это всегда `void`, и таким образом может забить на выражение внутри. Поэтому можно написать свой `void_t`:
```cpp
template<typename...>
struct my_void { using type = void; };

template<typename... Ts>
using my_void_t = typename my_void<Ts...>::type;
```

### SFINAE (Вспомогательный `void_t` в специализациях шаблонных классов)
Третий способ. Пример:
```cpp
template<typename T, typename = void>
struct MyFormatHelper {
    void func1() {}
};

template<typename T>
struct MyFormatHelper<T, decltype(static_cast<void>(std::declval<T>().foo()))> {
    void func2() {}
};

struct Foo {
    void foo() {}
};

int main() {
    MyFormatHelper<int> f1;  // 1
    f1.func1();
    MyFormatHelper<Foo> f2;  // 2
    f2.func2();
}
```
Здесь все происходит аналогично предыдущим пунктам. Но мы изначально указали фиктивный шаблонный аргумент, чтобы потом использовать его для вырезания по SFINAE. Чтобы можно было создавать `FormatHelper<T>`, не указывая второй параметр (а он не нужен пользователю), сделали `void` значением по умолчанию. 

Примечание: поиск конкретного метода или чего-то такого называется member detection idiom.
## Билет 39
Автор: Кирилл Бриллиантов

### ```enable_if```

Помимо того, чтобы вырезать перегрузки по корректности какого-то выражения, можно вырезать еще и по корректности условия. Для этого существует структурка ```enable_if```

Возможная реализация enalble_if

```cpp
template<bool B, class T = void>
struct enable_if {};
 
template<class T>
struct enable_if<true, T> { using type = T; };

template<bool B, class T = void>
using enable_if_t = typename enable_if<B, T>::type; // чтобы в коде не лезть внутрь enable_if
```

То есть если условие ложно, то выберется основная версия ```enable_if``` (имеется в виду не специализация). А в такой версии нет псевдонима type, получается, что если ```enable_if_t<B, T>``` полезет внутрь ```enable_if``` , то он не найдет член type, поэтому будет substitution failure.

### Удаление перегрузок методов внутри класса

Иногда хочется удалить некоторые перегрузки изначально нешаблонных методов внутри шаблонного класса. Наивное решение ждет неудача

```cpp
template <typename T>
struct MemberDetecter {
  std::enable_if_t< /*some condition*/, bool> test() {
    return true;
  }
  bool test() const /* const, чтобы не было ambigous */{ 
    return false;
  }
};
```
В такой реализации, если условие неверно, произойдет ошибка компиляции, так как SFINAE не работает для нешаблонных объектов, а в данном случае  ```test``` - нешаблонная фукнция. Чтобы это пофиксить

```cpp
template <typename T>
struct MemberDetecter {
  template <typename U = T> // Теперь test - шаблонная
  std::enable_if_t< /*some condition*/, bool> test() {
    return true;
  }
  bool test() const /* const, чтобы не было ambigous */{ 
    return false;
  }
};
```

Теперь при вызове test ничего не поменялось, так как есть параметр по умолчанию, но устранилась ошибка компилции, так как врубилось SFINAE

### Упрощенный member detection

Две предыдущие идея можно объединить для упрощенного member detection

```cpp
// детектим метод int getValue() const;
template <typename T>
struct MemberDetecter {
  bool test (...) const { return false; } // 1
  
  template <typename U = T>
  std::enable_if_t<
    std::is_same_v<int, decltype(std::declval<const T&>()).getValue()>,
    bool
  > test (std::nullptr_t) cosnt { // 2
     return true;
  }
};
```
Внутри ```enable_if_t``` происходит многоуровневая проверка
- Вначале провеятся можно ли вызывать getValue() от const& на объект типа T. Если нельзя то данная перегрузка вырежется по SFINAE
- Далее происходит проверка того, что возвращаемые типы сошлись при помощи ```is_same_v```

Также тут используется ```...``` для того чтобы сделать перегрузку с приоритетом меньше, чем у 2. Помимо точек надо, чтобы 2 что-то принимало (например std::nullptr_t). Возможно, здесь можно обойтись без этого, но такой трюко удобен, когда кол-во перегрузок больше двух.
## Прочие мелочи, не в билетах

### Строковые литералы
Тип строковых литералов - массив `const char` фиксированной (на этапе компиляции) длины. Это позволяет писать такие шаблонные функции:
```c++
template<size_t N>
constexpr auto parse_format(const char (&s)[N]) {
    int specifiers = 0;
    array<char, N> found{};
    for (size_t i = 0; i < N; i++) {  // Вот в этом месте так как strlen не constexpr, то если бы приняли как char*, то не смогли узнать до куда идти циклом.
        if (s[i] == '%') {
            if (i + 1 >= N)
                throw std::logic_error("Expected specifier after %");
            i++;
            found[specifiers++] = s[i];
            if (!(s[i] == 'd' || s[i] == 'c' || s[i] == 's'))
                throw std::logic_error("Unknown specifier");
        }
    }
    return pair{specifiers, found};
}
static_assert(parse_format("hello%d=%s").first == 2);
static_assert(parse_format("hello%d=%s").second[0] == 'd');
static_assert(parse_format("hello%d=%s").second[1] == 's');
```
Таким образом, вот эта [библиотека](https://github.com/hanickadot/compile-time-regular-expressions) позволяет работать с регулярками в стиле `ctre::match<"[a-z]+([0-9]+)">(s)`