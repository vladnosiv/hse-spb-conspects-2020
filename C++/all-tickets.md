## Билет 01 "Детали классов"
Автор: Герман Тарабонда

### Корректное объявление глобальные констант

Круче пользоваться `constexpr`, нежели `const`, потому что лучше производительность, никаких race condition. Не ускоряет вычисления в compile-time, но требует возможность. Например:

```C++
constexpr b = 3; // ОК
constexpr c = f(1); // ОК, если f -- может быть вычислена во время компиляции
```

Будет больно, со сложными объектами, потому что нельзя инициализировать на этапе компиляции: будут беды с порядком инициализации разных единиц трансляций.

Если `const` вне класса, то он будет виден только в своей единице трансляции. При подключении хедера с константой в другие файлы произойдет копирование константы. Если мы хотим сохранить ссылки, то лучше `constexpr`. Например:

```C++
// inc.h
const std::string Flag = "--file"
// fst.cpp
#include "inc.h"
    ...&Flag... // (1) своя копия
// snd.cpp
#include "inc.h"
    ...&Flag... // (2) своя копия
// ссылка (1) != ссылке (2),
// чтобы были одинаковые пишем: constexpr char [] Flag = "--file"
```

### Корректное объявление статических констант-членов

Если у нас статические константы-члены классов, то константы видны везде и могут произойти беды, если мы захотим взять ссылку на константы:

```C++
// foo.h
struct Foo {
    static const int N = 60; // объявление
    static constexpr char Name[] = "NAME"; // объявление (аналогичное поведение до C++17)
}
// fst.cpp
... Foo::N ... // ОК
... Foo::Name[0] ... // ОК
... &Foo::N ... // может быть undefined reference на этапе линковки
... &Foo::Name[0] ... // может быть undefined reference на этапе линковки
// snd.cpp
... Foo::N ... // ОК
... Foo::Name[0] ... // ОК
... &Foo::N ... // может быть undefined reference на этапе линковки
... &Foo::Name[0] ... // может быть undefined reference на этапе линковки
```

В чем проблема? У константы должно быть и объявление, и должно быть определение ровно в одной единицы трансляции. Для решения проблемы добавляем определение констант.

```C++
// foo.h
struct Foo {
static const int N = 60; // объявление
static constexpr char Name[] = "NAME"; // объявление (аналогичное поведение до C++17)
}
// fst.cpp
const int Foo::N; // инициализация и слово `statuc` не нужны
constexpr char Name[]; // в заголовочном файле не определяем, иначе будет UB на этапе компиляции
... Foo::N ... // ОК
... Foo::Name[0] ... // ОК
... &Foo::N ... // ОК
... &Foo::Name[0] ... // ОК
// snd.cpp
... Foo::N ... // ОК
... Foo::Name[0] ... // ОК
... &Foo::N ... // ОК
... &Foo::Name[0] ... // ОК
```

Самое важное: **если можем, то ставим constexpr, а в заголовках еще пишем inline**.

```C++
struct Foo {
    static inline const std::string NO = "NO"
    static inline constexpr char YES[] = "YES"
}
inline const std::string NO = "NO"
inline constexpr char YES[] = "YES"
```

*C C++17 inline можно писать у констант и у переменных*

### Перегрузка `operator->`

Мы можем ее перегружать (вау). Это унарный оператор, а не бинарный (важно). Для перегрузки мы должны возвращать то, к чему мы можем применить стрелочку. Например:

```C++
template<typename T>
struct unique_ptr {
T* data;
// ....

// Унарный оператор *
      T& operator*()       { return *data; }
const T& operator*() const { return *data; }

// "Бинарный" оператор ->, второй аргумент - метод.
// Так что на самом деле унарный.
      T* operator->()       { return data; }
const T* operator->() const { return data; }
};
// ....
unique_ptr<std::string> s = ....;
s->size();
// На самом деле у нас выходит цепочка из вызовов operator->
// auto x = s.operator->(); x->size();
```

Получается, мы можем сделать и такую перегрузку:

```C++
struct Foo {
    auto operator->() {
        return std::make_unique<std::string>("hello");
    }
} f;
f->size();  // размер "hello" = 5; время жизни unique_ptr — до конца full expression (;)
// auto x = f.operator->(); x->size();
```

### Функции-друзья

Функция-друг позволяет пользоваться закрытой частью другого класса. Например:

```C++
class matrix;
class vector {
    int v[4];
    ...
    friend vector multiply(const matrix&, const vector&); // имеет доступ к vector и массиву v
}; 

class matrix { 
    vector v[4]; 
    ... 
    friend vector multiply(const matrix&, const vector&); // имеет доступ к matrix и массиву v 
}; 

### friend class

Если мы хотим в классе воспользоваться приватной функцией другого класса, то она должна стать его другом. При этом мы не можем отдельно обозвать функцию другом. Синтаксис такой:

```C++
class Bar;
class Foo {
    friend class Bar; // не можем сказать, что конкретный метод класса Bar -- друг
    void privateFunc();
};
class Bar {
    void bar() {
        Foo f;
        f.privateFunc(); // ОК
    }
};
class Baz {
    void bar() {
        Foo f;
        f.privateFunc(); // не ОК
    }
};
```

### `using` для методов и полей: method hiding, изменение видимости

Правило такое: если в наследнике есть хотя бы один метод с именем `foo`, то в родителей мы уже не смотрим (даже если у нас override), то есть по умолчанию у нас method hiding.

```C++
struct Foo {
virtual int foo(int) { return 1; }
virtual int foo(double) { return 2; }
}
struct Bar: Foo {
void foo(int) override { return 3; }
}

Foo f;
std::cout << f.foo(1) << std::endl; // 1, смотрим на функции Foo
std::cout << f.foo(1.2) << std::endl; // 2, смотрим на функции Foo
Bar b;
std::cout << b.foo(1) << std::endl; // 3, не смотрим в родителя
std::cout << b.foo(1.2) << std::endl; // 3, не смотрим в родителя
Foo& b2 = b;
std::cout << b2.foo(1) << std::endl; // 3, смотрим на функции Foo,
// но так как foo(int) виртуальная и ссылается на Bar, то выводим 3
std::cout << b2.foo(1.2) << std::endl; // 2, смотрим на функции Foo
```

Если добавить `using`, то мы подключим все имена методов в текущий класс:

```C++
struct Foo {
    void foo(int);
};
struct Bar : Foo {
    // using Foo::foo;
    void foo(double);
};
Foo f;
f.foo(1.2); // int
f.foo(1); // int
Bar b;
b.foo(1.2); // double
b.foo(1); // double, после using - int.
b.Foo::foo(1); // int
Foo &b2 = b;
b2.foo(1.2); // int
b2.foo(1); // int
```

### `using` для методов и полей: использование для упрощения конструкторов

Зачем писать так:

```C++
struct my_exception : std::runtime_error {
    my_exception(const std::string& what_arg) : std::runtime_error(what_arg) {}
    my_exception(const char*        what_arg) : std::runtime_error(what_arg) {}
};
// ...
throw my_exception("Foo");
// ...
```

Если можно так:

```C++
struct my_exception : std::runtime_error {
    using std::runtime_error::runtime_error; // вместо нескольких конструкторов 1 строчка
};
// ...
throw my_exception("Foo");
// ...
```

С помощью `using` мы указываем компилятору, что мы собираемся наследовать конструкторы базового класса. И компилятор тогда сгенерирует код выполнения наследования и пересылки производного класса в базовый класс.
## Билет 02
Автор: Носивской Влад

За поиск багов спасибо Данилу Бубнову.

* Зачем: во избежание коллизий. Например, пишем клиент-сервер, класс User есть и у клиента, и у сервера. Для этого заведем namespace client и namespace server. Теперь обращение client::User и server::User соответственно.

* Еще немного про мотивацию:
    * Можно использовать вложенные классы:

        ```C++
        class Database {
        public:
            class User { ... };
        };
        ```

        ```C++
        class Application {
        public:
            class User { ... };
            static Database connectToDb() { ... }
        };
        ```

        Здесь Database::User и Application::User - разные классы. Есть минусы: нужно писать много static-ов и в разных файлах использовать разные классы, либо заводить один God object, который содержит все функции и переменные со всех файлов. 
        
        Зачем здесь написан static для функции connectToDb? static функции как члены класса - это функции, которые не требуют наличия экземпляра класса для вызова (в данном случае мы не обязаны иметь экземпляр класса Application для вызова функции connectToDb).

    * А можно использовать namespaces:
        
        ```C++
        namespace database {
        class Database {
        public:
            class User { ... };
        };
        } // namespace database

        namespace application {
        class User { ... };
        database::Database connectToDb() { ... }
        } namespace application
        ```
* Немного про стиль при использовании namespace:
    * Обычно в одном файле один namespace. Внутри пишется без отступов (см. пример выше)
    * Имя в snake_case
    * namespace можно переоткрывать (в отличие от классов), в том числе в разных файлах. При этом содержимое конкатенируется. 
    * Если пишете библиотеку - хороший тон обернуть ее в namespace, а дальше творить в ней что угодно.
    * Заглянуть внутрь это ::, как у классов.

* Вложенные пространства имен.
    ```C++
    namespace database {
        namespace internal {
            void foo();
            void bar();
            struct Foo {};
        } // namespace internal
        struct User {};
    } // namespace database
    ```

    Начиная с С++11 можно писать так:

    ```C++
    namespace database::internal {
        void foo();
        void bar();
    } // namespace database::internal
    ```

    Чтобы обратиться к глобальному пространству имен, обратитесь будто к безымянному пространству:

    ```C++
    int foo;
    namespace bar {
        int foo;
        void some() {
            ::foo = 0; // Изменилось значение переменной, которая объявлена в глобальном пространстве имен.
        }
    } 
    ```

* Static и анонимные пространства имен.
    * Internal linkage позволяет использовать объект/функцию/класс только в той единице трансляции, в которой они объявлены и определены, что позволяет избежать коллизий.
        
        file1.hpp

        ```C++
        static int var = 82; // Передаю привет Гимназии №82 города Краснодара
        int foo() { return var; }
        ```

        file2.hpp

        ```C++
        static int var = 239;
        int bar() { return var; }
        ```

        main.cpp
        ```C++
        #include <iostream>
        
        #include "file1.hpp"
        #include "file2.hpp"

        int main() {
            std::cout << foo() << std::endl; // 82
            std::cout << bar() << std::endl; // 239
        }
        ```

    * Выше был показан сишный подход, в плюсах решили, что для internal linkage будут использовать анонимные пространства имен. Также анонимные пространства имен позволяют делать internal linkage для типов (классов, структур), что не позволяет static
        
        header.cpp
        ```C++
        namespace {

        int var = 82;

        class A{ int x { 0 }; }

        void f() {}

        }
        ```

        В плюсах лучше всегда использовать анонимные пространства имен.

* Про typedef и using, а главное - про отличие между ними.

    typedef пришел к нам из Си и означает он синоним имени. using же протаскивает имя.

    Например, можно сказать typedef int score_t; чтобы использовать score_t в коде, это будет псевдоним для int.

    * Вне контекста пространств имен typedef проигрывает using-у, так как ему очень плохо дается работа с шаблонами. Пример:

        ```C++
        template<typename T>
        using myAllocList = std::list<T, myAlloc<T>>;

        myAllocList<Object> ml;
        ```

        С typedef-ом написать подобный код будет больно и сложно (но все же возможно, пусть и использование усложнится).

        ```C++
        template<typename T>
        struct MyAllocList {
            typedef std::list<T, MyAlloc<T>> type;
            
        };

        MyAllocList<Widget>::type lw;
        ```

    * В контексте пространств имен using позволяет протащить имя в точку.

        ```C++
        using database::Database;
        ```

    * Еще можно протаскивать целиком все имена из пространства имен:

        ```C++
        using namespace database;
        ```

        Здесь нужно быть очень аккуратным и уверенным, что не будет коллизий с именами. Поэтому не стоит писать в коде using namespace std; (привет контестам), ведь мы не знаем все имена из стандартной библиотеки. Например, там лежат функции left и right, а назвать так переменную иногда может хотеться. 

        Стоит отметить, что использование using namespace внутри .h/.hpp файлов идея сомнительная. Пользователь может добавить хедер и надеяться, что коллизий не будет.


## Билет 03 "Правила поиска имён (глобальных и внутри классов)"
Автор: Герман Тарабонда

### Где возникает qualified lookup, а где — unqualified

Если простым языком: то для  `foo()` происходит unqualified lookup (то есть просто поиск по имени), а для `::foo()` происходит qualified lookup.

Как вообще это происходит.

Unqulified lookup -- ищем в текущих `{}` где находится наш условный `foo()` и ищем объявление `foo()`. Подробнее об этом будет написано позже.

Qualified lookup -- ищем так как указано. Например: `model::animal::run()`. Сначала мы смотрим на `run()`. Вызывается qualified lookup. Теперь нужно найти `animal`. Это тоже выполняется qualified lookup'ом. Чотбы найти `animal` нужно найти `model`. А вот поиск `model` происходит с помощью unqulified lookup.

### Явное обращение к глобальному пространству имён (`::foo`)

Все что не лежит явно в namespace'ах лежит в глобальном namespace. Чтобы обратиться к глобальному namespace можно явно указать `::foo`.

### Правила unqualified lookup в телах функций, методов, на уровне пространств имён ("глобально")

Правило такое: везде кроме классов ищем объявление до строчки использования. В классах мы ищем во всем его объявлении. Например:

```C++
... // И в конце концов здесь (4)
namespace food {
... // Потом здесь (3)
class Meat {
... // Потом здесь (2)
void fry() {
... // Ищем здесь сначала (1)
slice();
... // Здесь не ищем
}
... // Здесь мы ищем, т. к. это класс (2)
}
... // Здесь тоже не ищем
}
... // И тут не ищем
```

### Forward declaration для функций и классов, особенности неполных типов

В чем прикол forward declaration? На самом деле это довольно полезная штука. Оно позволяет программисту написать объявление чего-либо, а затем когда-нибудь написать определение этого чего-либо.

Пример из `lab_11` файл `bin_manip.h`:

```C++
#include <iosfwd>

std::ostream& hex(std::ostream&);
...
```

Здесь нужно только объявление `ostream`, поэтому достаточно подключения `iosfwd`. Это заметно ускоряет компиляцию программу, так как в `iosfwd` написаны только неполные объявления классов.

В `bin_manip.cpp` уже нужно подключать `iostream`, так как там есть вызов функций, которые не объявлены в `iosfwd`.

В `employee.cpp` тоже есть проблемы. Например:

```C++
#include "bin_manip.h"

...(ifstream& f) {
f >> read_le_int32(...);
}
```

Такого рода файл будет выдавать ошибку компиляции, так как не поймет, что `ifstream` - наследник `istream`, так как в `iosfwd` не указаны детали реализации. Поэтому дополнительно в этот файл нужно подключить `fstream`.

Кратко про неполные типы: объявлять можно, пользоваться нельзя. Пример:

```C++
class IncompleteClass; // forward declaration, неполный класс

void foo1(const IncompleteClass* p); // ОК
void foo2(const IncompleteClass& p); // ОК
void foo3(IncompleteClass p); // ОК
void foo4(IncompleteClass p) {}; // не ОК, определение функции

IncompleteClass* p; // ОК
IncompleteClass p; // не ОК
```

## Билет 04
Автор: Влад Носивской

Боже, если вы сейчас читаете это на экзамене, потому что вам выпал этот билет, то мои вам соболезнования, это такие дебри, что легче алгебру сдать без подготовки, чем разобраться в этом. Но мы сейчас попробуем. Морально приготовьтесь.

* Для начала разберемся, зачем это нужно, поймем, что мы это используем часто и постараемся не думать о том, как это работает.

    Давайте будем говорить на одном языке. Для этого поймем, что такое lookup. Если вы использовали функцию в коде, во время компиляции ей сопоставится ее объявление. Но объявление нужно для начала найти. Если вы задали с помощью :: область, в которой нужно искать - это будет qualified name lookup.
    
    Но вот если не задали... Тогда компилятор должен угадать, что же вы имели в виду. Например, безобидная конструкция ```std::cout << "Hello world!";``` это уже ADL. Потому что это на самом деле вызов ```std::operator<<(std::ostream&, T)```, но мы нигде не подсказали компилятору, где искать такой оператор, поэтому он отправляется на увлекательные поиски оператора, что само по себе крайне полезно, если не задумываться о том, как он это делает.

* Что же, вы все еще это читаете, значит, ждете чего-нибудь страшного? Тогда давайте разберем этот крайне занимательный код.

    ```C++
    #include <iostream>

    int main() {
        // Это сработает, вы и без меня знаете, но, знаете ли, почему?
        // Как я говорил выше, с одной стороны мы не знаем, что такое std::operator<<( ... ), но
        // ADL для того и создан, чтобы ходить по неймспейсам и настойчиво интересоваться:
        // "А у вас некий operator<<(std::ostream&, const char *) найдется?"
        // В данном случае ему повезет, и в огромном и страшном namespace std ему найдут такой,
        // а ADL не брезгливый, он возьмет подходящую функцию даже у std.
        std::cout << "Hello world!\n";

        // Аналогично сработает и такой пример (это ведь просто другая нотация):
        operator<<(std::cout, "Hello world!\n");

        // Дальше - больше.
        // Следующая конструкция не сработает.
        // А все, потому что ADL начинает работать только на вызовах функций
        // Поэтому мы не найдем определение endl
        std::cout << endl;

        // Внимательный читатель подметит, что endl - тоже функция
        // Но раз так, то мы же можем ее вызвать? Да, можем!
        // На этот раз ADL все же запустится.
        endl(std::cout);

        // Но настолько ли вы внимательный читатель? Предлагаю тест в виде строки:
        (endl)(std::cout);
        // Не работает. Удивлены? Я не знаю. Я уже ничего не знаю и ничего не хочу.
        // А все, потому что (endl) это под-выражение, которое не является вызовом функции.
        // Поэтому у ADL лапки в этом случае.
    }
    ```

Давайте теперь испугаемся немного. А испугаемся мы, потому что ADL имеет 9 вариантов работы, в зависимости от аргументов функции. Если готовы, то зажмурьтесь, глубоко вдохните, мы окунаемся в разбор случаев.

### Преддверие ада.

Это место населено нерешительными людьми, которые бояться проходить дальше. Здесь происходит проверка сначала просто unqualified области видимости, без ADL. Если компилятор увидит какую-то функцию, с тем же именем, что у искомой, которая подходит под один из трех следующих случаев, он решит, что запускать ADL не нужно, и что это та самая функция.


* Объявление функции-члена класса.


* Объявление внутри текущего скоупа (но не using внутри текущего скоупа).


* Объявление, которое не является функцией или шаблоном функции. Т.е. какой-то конфликт имен с объектом другой природы.

Например, в следующем коде не будет запуска ADL, код не скомпилируется.

```C++
namespace bar {

void foo(SomeClass x) {}

}

void foo() {}

int main() {
    SomeClass a(...);
    foo(a);
}
```

Если же ни один из трех пунктов не выполнился, мы переходим на следующий уровень. Здесь будет разбираться каждый аргумент. Каждый аргумент добавляет новые области, по которым будет ходить ADL.

### Круг первый. Лимб.

На этом уровне вместе с некрещенными младенцами и добродетельными нехристианами мы вступим в царство фундаментальных типов. Здесь вместе с Гомером, Аристотелем, Сократом и другими известными личностями обитают инты, даблы и прочие простаки. Они не добавляют в поиск ничего. Да, вы верно поняли, что если в прошлой выкладке SomeClass будет, например, интом, ADL не будет работать, даже если убрать строку ```void foo() {}```

### Круг второй. Похоть.

Для аргументов типа класс (даже таких редких зверей, как union) приготовлен третий круг. Здесь в приятной компании Клеопатры и Елены Прекрасной, они добавляют в область поиска ADL следующие места:

* Сам класс.

* Все его прямые и косвенные базовые классы.

* Если класс является внутренним классом другого класса, то ADL будет искать еще и во внешнем классе.

* Внутренние вложенные пространства имен классов, которые уже попали в планы ADL.

### Круг третий. Чревоугодие.

В царстве Цербера гниют под дождем и градом специализации шаблонов классов. Почему чревоугодие, спросите вы? Потому что такие специализации съедают очень много областей в пользу ADL. А именно, кроме класса аргумента, рассматриваются следующие классы и типы, которые добавляют в область поиска все связанные с ними классы и пространства имен:

* Все типы, которые являются аргументами шаблона, которыми специализировали аргумент. Не включаются в область видимости нетипизированные параметры шаблона и параметры шаблона шаблона (если шаблон нам параметризовали другим шаблоном).

* Все пространства имен, в которые входят параметры шаблона.

* Внимание, сложное для понимания предложения, напрягитесь. ADL добавит все классы, в которых параметры шаблона шаблона являются членами этих классов. (Если они оказываются шаблонами членов класса)


### Круг четвертый. Скупость.

    «Тебе узнать их не дано:
    На них такая грязь от жизни гадкой,
    Что разуму обличье их темно»

Для enum-ов в ADL добавится пространство имен, в котором лежит enum, либо класс, если enum лежит в классе.

### Круг пятый. Гнев.

Вы уже достаточно разгневаны на этот билет? Я вполне. Указатели на тип T или на массив типа T тащат за собой все внутренности типа Т, а также все связанные с этим типом классы и пространства имен

### Круг шестой. Стены города Дита.

Здесь в круге еретиков живут функции. Если они являются аргументами функции, они добавляют все типы аргументов и возвращаемый тип функции, а также все связанные с ними классы и пространства имен.

### Круг седьмой. Город Дита.

На этом кругу обитают насильники. В том числе насильники над вашими мозгами: указатели на функцию-член F класса X. Они затащат с собой тип возвращаемого F, типы аргументов F, и, наконец, сам класс X. И, конечно, все связанные с этими типами классы и пространства имен.

### Круг восьмой. Злопазухи. 

Здесь живут на этот раз поля-члены F класса X. С ними все аналогично, они затащат тип F, класс X и все связанные пространства имен и классы.

### Круг девятый. Ледяное озеро Коцит. 

Мы почти закончили разбирать случаи. Здесь во льдах предательства нам нанесут предательский удар наши любимые функции в качестве аргументов и шаблонные функции. А именно:

Если аргумент является именем или адресным выражением для набора перегруженных функций (или шаблонных функций), каждая функция исследуется по отдельности в наших кругах и добавляет все связанные с ней классы и пространства имен.

Кроме того, если набор перегрузок назван с помощью шаблона, все параметры шаблона, а также параметры шаблона шаблона, а также все связанные с ними пространства имен и классы.

### Занимательные дополнения.

Интересные детали предыдущих выкладок.

* using-и внутри связанных пространств имен игнорируются.

* friend-function's внутри пространства имен, которые объявлены в связанном классе видны для ADL, даже если не видны для других поисков.

### Hidden friend. Практическое пособие по поиску друзей.

Если коротко, то друзей можно найти только через ADL.

Про friend-function's из предыдущего пункта вещь важная, запомните.

```C++
#include <iostream>

namespace ns {
    struct Foo {
        friend void foo(Foo) {}
    };

    // void foo(Foo); // (1)
}
// ...
ns::Foo f;
foo(f); // ok
ns::foo(f); // не ok
```

Из минусов мы теперь обязаны эту функцию передавать только как лямбду. 

Можно раскомментировать (1) и функция станет видна.

### Приключения swap и ADL

Пусть вы написали некую функцию swap. 

Как мы уже понимаем, два примера кода будут вести себя по-разному:

```C++
std::swap(a, b);
```

```C++
using std::swap;
swap(a, b);
```

Во втором случае заработает адская машина ADL, которая сама выберет, какой свап использовать, а выберет она исходя из пространств имен аргументов (как мы уже знаем после прохождения по 9 кругам).

Просто знайте это. Выводов не будет. Восторгаться или отторгать - решать вам.

### Выводы.

* Разработчики C++ люди глубоко в своем сознании преисполнившиеся.

* Пользоваться ADL можно, но могут возникать казусы. В коде ```count(vec.begin(), vec.end())``` аргументы это что:
    
    * vector::iterator

    Или
    
    * typedef int* 

    Ответить сложно.
* Если рефакторите код (перемещаете функции, типы) все может сломаться. И в этом нет никакой магии (только если вы прочитали все 9 кругов).

* Всегда пишите ```using std::swap; swap(a, b)```.

## Билет 05
Автор: Венедиктов Роман

### Конвенции именований стандартной библиотеки, отличия stdio.h и cstdio
* В стандартной библиотеке C++ есть кусок под названием STL (standard template library),
  это всякие вектора и алгоритмы.
  Ввод-вывод (`iostream`) туда не входит.
  Но иногда STL путается с "стандартная библиотека C++".
* Конвенция в стандартной библиотеке C++: заголовок пишется без `.h`
  и обычно добавляет имена только в `namespace std`
  * Добавили что-то своё в `namespace std` (за парой исключений) — UB
* В C++ есть два вида заголовков из Си:
  * `<stdio.h>` — всё подключил в глобальный namespace, опционально в `std`
  * `<cstdio>` всё подключил в `std`, опционально в глобальный

### Иерархия потоков ввода-вывода
* Иерархия классов:
![](https://github.com/e2e4b6b7/hse-spb-conspects-2020/blob/master/C%2B%2Bmedia/Ticket5.jpg)
  * Базовый `std::ios` определяет функции для обработки ошибок.
  * В функциях, которые записывают/читают данные вы обычно
    берёте ссылку на базовые `istream`/`ostream`. 
    (Чтобы корректно работать со всеми наследниками)
  * Всякие `basic_istream`, это обобщения на случай, если символ — не `char` 
    (а например, четыре байта).
### Файловый ввод-вывод
* Можно открыть файл из `<fstream>`:
  ```c++
  std::ifstream in("a.txt"); // Если файл не открылся? Будет в состонии "ошибки", надо проверять
  // in.close() // Не нужно, даже если нет проверки на успешность.
  ```

### Байтовый и текстовый режим
Открытие в бинарном режиме:
`std::ifstream f("a.bin", std::ios_base::in | std::ios_base::binary);`.
Разница режимов в том, как обрабатывать специальные последовательности байт для определенный платформ. Под Linux бинарный и не бинарный режим работают одинаково. Под Windows, в текстовом режиме, \r\n при чтении переходит в \n и обратно при выводе.

* `cin.get` — посмотреть один символ, вытащить его из потока, если не удалось — `istream::traits_type::eof()`
* `cin.peek` — посмотреть один символ и не вытаскивать
* `cin.unget` — запихнуть символ обратно, с ним надо аккуратно читать документацию, когда это можно делать (Если не смог, ставит `badbit`)
* `read` — читает символы в буфер
* `seekg`/`tellg` — можно узнать позицию в файле.

### Обработка ошибок
У каждого потока есть три бита состояния, которые можно узнать:

* `badbit` — поток умер: не смог записать байт (место кончилось)
* `failbit` — не удалось прочитать/записать, но поток жив.
  Например, неверный формат.
  Где мы сейчас в потоке — непонятно.
* `eofbit` — мы __уже__ знаем, что поток закончился (аналогично `feof`).
  Например, если в конце файла `"123 "` и мы прочитали число, то мы не знаем, что за пробелом конец потока.

Чтение: 
* `.rdstate()` — полное состояние потока (bitmask)
* `.fail()` = `failbit || badbit`
* `.eof()` = `eofbit`
* `.bad()` = `badbit`
* `operator bool` — отрицание `.fail()`
* `operator!` = `.fail()`

Запись:
* `clear(bitmask)` — сброcить флаги и задать такое состояние 
  (по умолчанию `goodbit`)
  (если соответсвующий stream buffer — nullptr,  то добавляет к состоянию `badbit`)
* `setstate(bitmask)` для __добавления__ флага.

### Проверка конца файла и почему нельзя писать while (!eof)
```c++
while (!in.eof()) {
	in >> a;
	// some code
}
```
На файле `"123 "` считает первое число, потом пойдёт считывать второе и не сможет. Не перезапишет `a` и код выполнится для последнего числа дважды
Более правильно:
```c++
while (in >> a) {
	// some code
}
```
## Билет 06
Автор: Никита Абрамов

#### Конвенции именований стандартной библиотеки, отличия stdio.h и cstdio

Язык С++ позволяет использовать всю стандартную библиотеку языка С, но появляется еще и собственная стандартная библиотека. Заметим, что STL (standard template library) - кусок стандартной библиотеки языка C++. Конвенция в стандартной библиотеке C++: заголовок пишется без раcширений (например, без `.h`). Добавил что-то свое в `std` - за парой исключений получил UB. Для стандартных заголовков из C есть два варианта их подключения:

* `<stdio.h>` - попадает в глобальный namespace (`::fopen`), может положить что-то в `std`
* `<cstdio>` - попадает в `std` (`::std::fopen`), может положить что-то в глобальный

Можно использовать оба, но лучше придерживаться одного стиля и использовать один.
`#include <bits/stdc++.h>` — нестандартный заголовок из GCC, зависит от версии, лучше не использовать.

#### Неформатированный ввод-вывод (get, peek, unget, read, seekg/tellg)
Всё ещё есть отличие между текстовым и бинарным режимом: 
`std::ifstream f("a.bin", std::ios_base::in | std::ios_base::binary);` 
Существуют функции, в которых мы не можем никак форматировать наш ввод-вывод, разберем основные из них подробнее.

*  get 
`std::istream::get` - (`cin.get`) - считывает 1 символ/строку в c-style, бывает: 
```C++
int get(); //считывает символ и возвращает его целочисленный код
istream& get (char& c); //можно записать в переменную
istream& get (char* s, streamsize n); // записать в строку в стиле c-style
istream& get (char* s, streamsize n, char delim); /* считывает n - 1 символ или до того,
как встретит разделитель (по умолчанию - перенос строки). 
Деталь - разделитель не извлекается, его потом можно считать
\0 - автоматически добавляется в конец, можно ставить n = 0, тогда - пустая строка*/
istream& get (streambuf& sb); //используется для работы с stream buffer (не разбиралось)
istream& get (streambuf& sb, char delim);
```
если не удалось — `istream::traits_type::eof()` (возвращает End-of-File value, которое для многих стандартных функций    считается, как неверный символ (ни с чем сравнивать тоже нельзя))
*  peek
`int peek();` - возвращает текущий элемент во входной последовательности, но не извлекает его, если установлены флаги ошибок(или устанавливается в момент выполнения, то возвращает `istream::traits_type::eof()`)
*  ungetа
`istream& unget();`  - вначале очищает eofbit (с С++11), возвращает последний символ, который достали, если есть флаги ошибок, то устанавливает failbit и возвращается. Следует работать аккуратно
*  read
`istream& read (char* s, streamsize n);`- считывает символы в буфер (размер - знаковый аналог size_t) (аналог `fread`)
* seekg/tellg
`streampos tellg();` - возвращает текущую позицию. `streampos` кастуется к `int`, для элементов этого типа существуют: 
`!=` и `==`
`istream& seekg (streampos pos);` - устанавливает позицию на следующий символ, который будет доставаться из потока
Пример:
```C++
// get length of file:
    is.seekg (0, is.end);
    int length = is.tellg();
    is.seekg (0, is.beg);
```
#### Форматированный ввод-вывод, отличия от printf (типобезопасность, поддержка пользовательских типов)
Пример для форматированного ввода-вывода
```C++
std::ostream& operator<<(std::ostream& os, int v) {
    return os;
}
std::istream& operator>>(std::istream& is, int &v) {
    return is;
}
std::cin >> x >> y;
(std::cin >> x) >> y; //так его разбирает компилятор, как раз ради этого и возвращаем ссылку
operator>>(operator>>(std::cin, x), y); //можно еще так
```
Стандартная библиотека перегружает операторы для базовых типов (`int`, `double`, `char`, `char*`) и каких-то своих (`std::string`). Форматированный ввод - потому что мы можем сами задавать формат, какой хотим. Разберем пример с добавлением произвольного класса (сразу про реализацию своих операторов ввода-вывода):
```C++
struct BigInt {
};
std::ostream& operator<<(std::ostream& os, const BigInt &v) {
    return os << (int)v; // алгоритмический костыль(чтобы не уйти в бесконечную рекурсию)
    return os << static_cast<int>(v); // C++-style алгоритмический костыль
}
```
Обычно, когда есть поля, состоящие из базовых типов, то обходится без подобных костылей.
##### Общие правила  
*  Возвращаем ссылку (неконстантная, потому что поток меняется) на левый параметр, потому что не совсем понятно, что такое скопировать поток, особенно, когда он, например, из файла. Также хочется считывать несколько объектов подряд. 
*  Пишем для базовых классов потоков, если не нужно обратное (например, `istream`, а не `ifstream`). 
*  Сам объект для чтения принимает по неконстантной ссылке, потому что мы в него что-то записываем.
*  Можно делать friend, если хотим доставать какие-то приватные поля у класса.
Но так как обычно friend использовать не любят, потому что это нехорошо отражается на архитектуре (цитата Соколова), то можно писать так:
```C++
struct BigInt {
public:
    std::ostream& operator<<(std::ostream& os) {
        os << v;
        return os;
    }
private:
    int v;
};

std::ostream& operator<<(std::ostream& os, const BigInt &v) {
    return v << os
}
```
#### Реализация своих операторов ввода-вывода, включая обработку ошибок
Разберем теперь более подробно обработку ошибок
У каждого потока есть три бита состояния, которые можно узнать:
* badbit — поток умер: не смог записать байт (место кончилось)
* failbit — не удалось прочитать/записать, но поток жив. Например, неверный формат. Где мы сейчас в потоке — непонятно.
* eofbit — мы уже знаем, что поток закончился (аналогично feof). Например, если в конце файла 123, и мы прочитали число, то мы не знаем, что за пробелом конец потока.

Чтение: .rdstate(), .fail(), .eof(), .bad(), operator bool (отрицание fail) и operator!.
`iostate rdstate() const;` - возвращает комбинацию битов, про которые было сказано раннее
`.fail()` - возвращает `failbit` или `badbit`
`.eof(), .bad()` - возвращает каждый конкретный бит(могут быть реализованы через сравнение с `rdstate()`)

Запись:
* clear() для сброса/перезаписи флагов.
* setstate() для добавления флага.
* На контестах достаточно while (cin >> n)
* Для корректного чтения/записи BigInt стоит не просто читать символы, а ещё и флаги ставить при ошибках.
* Чтобы показать совсем разумную ошибку, обычно надо парсить руками

Можно устанавливать исключения (чтобы они вылетали при проставлении битов)
```
std::cout.exceptions(std::cout.failbit | std::cout.badbit);
std::cin.exceptions(std::cin.failbit | std::cin.badbit);
```
#### Реализация своих манипуляторов (например, `read_le_int32` или `eat`)
Если у нас манипулятор без параметров, то можем просто представлять его как функцию:
`ios_base& hex (ios_base& str);` - пример из std, устанавливает флаг(basefield) на hex и работает с ним.
```C++
ostream &tab(ostream &out)
{
    return out « '\t'; // добавляем tab
}

istream &eatline(istream &in) // убираем строку
{
    while(in && in.get() != '\n')
    {
    }
    return in;
}
```
Если же хотим запускать от чего-то (например, `read_le_int32(x)`), то это похоже на вызов конструктора у объекта, поэтому приходится заводить структуру.
Рассмотрим несколько примеров:
Пример с friend - манипулятором
```C++
struct write_le_int32 {
    explicit write_le_int32(int32_t _val) : val(_val) {} //для read - принимаем и храним все по ссылке
    friend std::ostream& operator<<(std::ostream &os, const write_le_int32 &d);/* const&, чтобы лишний раз не копировать,
 а также, так как у нас состояние объекта меняться не будет -
 мы просто его выведем */
private:
    int32_t val;
};
```
Можно снова избавиться от `friend` с помощью трюка, описанного выше (разумеется, можно использовать не только операторы `<<`, но и `()`, например)
```C++
class expand
{
    expand(short to_expand) : value (to_expand) {}
    ostream &operator()(ostream &) const; //как-то выведем число из цифр в формате слов
private:
    short value;
    static const char *const tens[];
    static const char *const units_and_teens[];
};

ostream &operator <<(ostream &out, expand number)
{
   return number(out);
}
```
## Билет 07
Автор: Денис Филиппов

* Синтаксис и пример
	* Появилась возможность наследовать одну структуру / класс от нескольких. Пример:

		``` C++
		struct PieceOfArt { std::chrono::time_point date; };      
		struct Music : PieceOfArt { std::string notes; };
		struct Lyrics : PieceOfArt { ... };
		struct Song : Music, Lyrics {
		Song(...) : Music(...), Lyrics(...), album(...) {}
		std::string album;
		// using Music::date;
		};
		```

	* Синтаксис как в обычном наследовании, только теперь мы через запятую перечисляем несколько предков.

	* Если возникает пересечение по именам, при обращении добавляем квалификатор. Если пересечений нет, то как обычно:

		``` C++
		Song s;
		x = s.Music::date;
		y = s.Lyrics::date;
		z = s.notes;
		```

	* Если есть using `Music::date`, то можно через `.` обращаться к date без `Music::`

		``` C++
		x = s.date;
		```

* Возможное представление в памяти, пример изменения адреса при `static_cast`

	* Возможное представление в памяти: сначала идут базовые объекты в порядке объявления (возможно с повторениями, в примере `PieceOfArt` повторится внутри `Music` и `Lyrics`), потом свои поля (в примере -- `album`).

  * Когда делаем `static_cast` (например, `static_cast<Lyrics *>(&s)`), меняется адрес указателя. Почему? Раньше у нас всегда был один предок, он располагался в начале куска памяти, потом шли поля. Поэтому первый байт у наследника и первый байт у предка совпадали. Теперь же, если мы кастуем к подобъекту, который не первый в памяти, указатель сдвинется до этого подобъекта.


* Порядок инициализации/уничтожения подобъектов и полей, как передать параметры конструкторам

	* Сначала инициализируются базовые объекты, причем в том порядке, в котором они указаны в объявлении класса (получается своеобразный dfs, т.к. заходим в первый базовый класс, у него заходим в первый базовый класс и т.д.). После этого как обычно (в порядке объявляния) инициализируются поля. Параметры конструкторам базовых классов передаются через запятую.

	* Уничтожение происходит в обратном порядке.


* Возможное дублирование базового класса и возникающие неоднозначности при приведении типа.

	* Нельзя кастовать напрямую `Song` к `PieceOfArt`. Это происходит из-за того что в `Song` хранятся два экземпляра `PieceOfArt` и возникает ситуация ambiguous base: непонятно к какому экземпляру кастовать. Сначала нужно прикастовать к `Music` / `Lyrics`, и только потом к `PieceOfArt` (в общем случаи также, на примере понятнее).
## Билет 08 "Виртуальное наследование"
Автор: Владимир Федоров

В множественном наследовании были проблемы с ромбовидным наследованием(мы имели 2 базовых класса, из-за чего возникала неопрделенность во время обращения к полям этого класса). Хотим решение проблем. Для таких случаев есть Виртуальное наследование.

### Синтаксис. Пример.
```C++
struct Person { 
    std::string name;
    Person(...) {
    ...
    std::cout << “Person: 1\n”;
    }
};
struct Student : virtual public Person {
    Student (...) : Person(...), ... { //конструктор Person игнорируется
    ...
    std::cout << “Student: 2\n”;
    }
    ...
};
struct Employee : virtual public Person {
    Employee (...) : Person(...), ... { //конструктор Person игнорируется
    ...
    std::cout << “Employee: 3\n”;    
    }
    ...
};
struct MagicStudent : public Student, public Employee {
    MagicStudent(...) :  Person(...), Student(...), Employee(...) ... {...}
    ... 
};
```

### Порядок инициализации/уничтожения подобъектов и полей, как и где передать параметры конструктором
Теперь у нас один Person и ответственным за его создание является класс MagicStudent. То есть именно вызов конструктора Person в конструкторе MagicStudent создаст единственных объект класса Person.(остальные игнорируются, см Пример)
Если посмотреть на пример, то после вызова конструктора MagicStudent(...) вывод будет такой:
```
Person: 1
Student: 2
Employee: 3
```
### Возможное представление в памяти
Классы Student и Employee имеют указатель на базовый класс Person. Итого получаем, что каждое слово virtual в иерархии это плюс указатель. Есть другой вариант, где Person в начале. Разницы особой нет. Зависит от компилятора.
![ticket8](https://user-images.githubusercontent.com/34138678/83932436-35147200-a7ab-11ea-9870-3ac8fc80586d.png)

### Невозможность простого приведения типа от виртуальной базы к наследнику
Из-за особенностей расположения в памяти не можем сделать так, потому что не можем на этапе компиляции определить, как на самом деле наследуется Person:
```C++
Person *p = new Person();
MagicStudent *s = static_cast<MagicStudent*>(p); // не скомпилируется
MagicStudent *cs = (MagicStudent *)p; // не скомпилируется
MagicStudent *rs = reinterpret_cast<MagicStudent*>(p); // указатель непонятно где
```
Например, в примере выше MagicStudent и Person расположены одним образом относительно друг друга в памяти, а вот например в случае ```class SuperMagicStudent : MagicStudent``` могут быть иным образом расположены, поэтому компилятор не может догадаться, как расположены относительно друг друга классы Person и MagicStudent, поэтому имеем беды с кастами.  

### Использование для интерфейсов (абстрактных классов)
* Абстрактный класс (интерфейс) -- это класс, который имеет в себе только (чисто) виртуальные функции. Полей такой класс не имеет.
* Обычно виртуальное наследование используется именно для таких классов.
* Все конструкторы интерфейсов тривиальны
* При виртуальном наследовании много указателей создаётся
* Каждый метод интерфейса встречается ровно один раз
```C++
struct Person { virtual getName() const; }
struct Student : virtual public Person { virtual getGPA() const; };
struct Employee : virtual public Person { virtual getSalary() const; };
struct final MagicStudent : virtual public Student, virtual public Employee {
    std::string name; virtual getName() override { return name; }
};
```

### Что происходит, если один класс объявляется и виртуальным, и не виртуальным
Все виртуальные схлопываются в одно. Все не виртуальные честно копируются и возникает неоднозначность. 
### Взаимодействие с dynamic_cast
Была проблема с кастами. Проблемы нет, если применить dynamic_cast. Правда, работает только с полиморфными объектами(объектами, которые содержат виртуальные функции) по определению dynamic_cast.
## Билет 09 "Исключения — основы"
Автор: Чистякова Полина
### Предусловия и постусловия конструктора и деструктора, инвариант объекта

Инвариант объекта - то, что определяет его корректное состояние.
Иными словами что-то, что всегда верно про этот объект.

Пример: ```uniq_ptr<T> a``` - владеет указателем, на основе которого он построен. Никто больше этим указателем не владеет.

Как понятно, пока объект живёт - инвариант выполняется. Отсюда вытекают некоторые уловия:

	Постусловие конструктора - инвариант выполняется
	Предусловие конструктора - поля сконструированны
	Постуловие деструктора - объект корректно уничтожен
	Предусловеи деструктора - инвариант выполняется
### Разные стратегии обработки для двух видов ошибок

Существует 2 типа ошибок - "ошибки программирования" (undefined behavior, нарушение инвариантов, невозможно предсказать поведение после) и "ошибки окружения" (некорректный ввод пользователя, теоретически можно предсказать и обработать).
Отличаются они тем, что первые совершил программист и сам находит путём отладки кода (и лучше бы он их нашёл), а вторые от него совсем не зависят (например, обращение к несуществующему файлу) и с ними надо научиться справляться.

Первые ошибки обрабатываются просто - можно поставить `assert`'ы и просто ронять программу, когда они происходят, чтобы программист сразу понимал, что что-то не так.
```C++
assert(2+2 != 4);
// программа упадёт и в стандартный поток вывода ошибок (stderr) выведется чисто эта строчка, с пометкой, что она упала.
```

Со вторым типом ошибок сложнее - так просто уже не поступить, надо сообщить пользователю, что же произошло, и, возможно, сохранить какие-то результаты.

Для этого существует несколько стратегий:
 * Вывод сообщения об ошибке сразу, как её встретили:
    ```C++
    void read_people() {
       File *f = fopen(filename, "r");
       if (!f) {
          printf("сообщение об ошибке");
          return;
       }
    }
    ```
    Проблема этого подхода - не всегда надо сразу писать в стандартный поток вывода (например, мы хотим выводить ошибку как-то в графическом интерфейсе)
    + иногда хочется ошибку обработать не тут (например, ошибка на сервере, а сказать надо что-то тому, кто туда обратился)
 * Возвращать код ошибки
   ```C++
   int sqlite3_open(const char *fname, sqlite3A *out); // Возвращаемое значение - код ошибки. Второй параметр - указатель на результат работы функции
   ```
   Проблема конкретно этого подхода сразу видна - надо знать все значения кода, что не очень удобно для программста
 * Почти возвращение кода ошибки - возвращать структуру, в которой может лежать значение OK или Error
 
   *пример на Rust'е*
   ```Rust
     fn Read_people() -> Result<People, String> {
        match open() {
           OK(f) -> {...}
           Err(err) -> return Err(err);
        }
     }
     let f = try!(open());
   ```
   Здесь Result - как раз такая стурктурка. Если ошибок нет, она вернёт значение OK или значение Err в противном случае.
   Проблема этого подхода - каждая функция очень аккуратно прощупывает остальные, всегда готова поймать исключение и, если сама не может её обработать, прокинуть дальше.
 * Кидать исключения
   ```C++
   std::vector<int> read_vector() {
      int n;
      if (!(cin >> n)){
         throw invalid_vector_format();
      }
   }
   
   try {
      read_vector();
   } catch ( invalid_vector_format() &err ) { /* обработка ошибки */ )
   ```
   Данный подход - просто goto решение проблемы

### Исключения: try, catch, throw, где что ставить для обработки ошибок

В предыдущем пункте мы увидели пример использования исключений.
Чтобы его выбросить используется конструкция `throw exception`.

Для обработки исключения существует блок `try/catch`:
```C++
try {
   /*что-то, что может выкинуть исключение, которое мы хотим обработать*/
} catch (/*исключение, которое мы ловим*/) {
   /*обработка исключения*/
}
```
Почему это удобно?

Потому что это помогает не думать об исключениях там, где мы их не можем обработать.
Просто кидаем что-нибудь, что долетит до тех, кто знает, что делать (или не принимаем исключение, а пускаем его дальше).

Небольшие уточнения к синтаксису:
 * у `catch` есть особый синтаксис - `catch (...)` дословно значит - "поймай всё что угодно"
 * В `catch` иногда полезно что-то сделать, а затем прокнуть ошибку дальше (например, если мы хотим проследить жизненный путь ошибки). Осуществляется конструкцией `throw;`
### Вложенные try/catch, несколько catch подряд и почему важно ловить по ссылке

Вложенные try/catch работают также, как и обычные. Поднявшись до try исключение смотрит на все catch - если не находит нужный, летит дальше.
Исключение из catch вылетает во внешний try. Сами блоки проверяются от внутренних к внешним.

```C++
try {
    // вызвали функцию, в которой
    try {
        throw Bar();
    } catch (Foo &err) {
    }
} catch (Bar &err) {
}
```

Ловят исключение по ссылке, потому что очень активно используется иерархия исключений - хотим избежаьт slicing'а.
### Stack unwinding (раскрутка стэка) и уничтожение локальных ресурсов

Как только исключение бросается, оно летит по строчкам вверх (а не вниз, как каждая уважающая себя программа), и уничтожает всё, что встречается ему на пути (вызываются деструкторы).
Когда оно доходит до первого блока try, оно прекращает лететь вверх и идёт к блокам catch.
Там исключение ищет себе подходящий вход. Когда оно его находит - начнается обработка этого исключения. Внутри блока catch считается, что исключения уже нет.

**WARNING** Поскольку во время размотки стека вызываются деструкторы, то всякие указатели не освободят свои ресурсы (не сипользуйте указатели, ага)

### Идиома Resource Acquisition Is Initialization (RAII)

Расшифровка RAII: resource acquisition is initialization. Конструктор должен полностью проинициализировать класс и убедиться во всех инвариантах. А если не смог — кидаем исключение.

При этом, если из конструктора вылетело исключение, то использовать этот объект мы уже не сможем. Нам просто не дадут :с
### Примеры исключений из стандартной библиотеки (std::exception и его наследники, bad_alloc)

Самый базовый класс для ошибок - `std::exception`. От него наследуются все остальные (и принято наследовать свои классы ошибок).

Примеры классов ошибок и как они наследуются.

```
std::exception
│   virtual const char *what() const;    
│
└───std::logic_error
│   │
│   └───std::invalid_argument
│   │
│   └───std::out_of_range
│   
└───std::runtime_error
│   
└───my_logic_exception
        *этот класс пользовательский, при большом желании можно не наследовать*
```
## Билет 10
Автор: Егор Лебедев
### Исключения, вылетающие из конструктора
В силу того, что у конструктора нет возвращаемого значения, ошибки возникшие на этапе создания объекта обычно обрабатываются с помощью исключений. Очень удобно, что если мы можем обратиться к переменной, то она всегда корректна (поскольку исключение кидается за фигурные скобочки, в которых переменная объявлена). Пример:
```c++
try {
    std::vector<int> a(178'000'000);
    ...
} catch (std::bad_alloc&) {
    ... // вектор уже не существует
}
... // вектор уже не существует
```

Отсюда идиома:

**RAII** - resource acquisition is initialization (получение ресурса есть инициализация): конструктор должен полностью проинициализировать класс и убедиться во всех инвариантах. А если не смог — кидаем исключение.

* Исключения могут вылетать в теле конструктора, тут их они обрабатываются так, как это происходит обычно.


* Также исключения могут вылетать из member initializer list (поля, базовые классы). Тогда не совсем ясно, что можно с этим вообще сделать. Конечно, существует такой синтаксис, называется **function try block**:
    ```c++
    struct Foo {
        Foo() try
            : vec(31'000)
            , f(new int[238])
            , s(new int[31]) {
            // ...
        } catch (...) {
            // ...
            /* throw; */
        }
        std::vector<int> vec;
        int** f;
        int** s;
    };
    ```
    В такой реализации при вылетевшем из строки `s(new int[31])` исключении невозможно будет обратиться к `f`, так как она будет "мертва" уже в момент входа в `catch`. Решение: объекты с автоматическим управлением временем жизни, такие как вектор, у которого деструктор вызовется автоматически.

    _Замечание_: в конца такого блока `catch` всегда неявно будет дописываться `throw` (только в конструкторах).

* В отдельный случай можно выделить **делигирующие конструкторы**:
    ```c++
    struct Foo {
        Foo(int x) {
            some_operation_a(x); // (1)
        }
        Foo() : Foo(10) {
            some_operation_b();  // (2)
        }
        ~Foo() {}
    };
    ```
    1. Если вызвали `Foo(10)` и `(1)` выкинуло исключение,
   то деструктор не вызовется.
    2. Если вызвали `Foo()` и `(1)` выкинуло исключение,
   то деструктор не вызовется.
    3. Если вызвали `Foo()` (а в нем вызывался `Foo(10)`) и `(2)` выкинуло исключение,
   то __деструктор вызовется__.

* Везде лучше использовать RAII:
    ```c++
    new X(new Y); // Тут `X` начинает владеть `Y` и обязан его удалить, "очевидно".
    ```
    1. Если кинул конструктор `Y`, то утечек нет.
    2. Если кинул конструктор `X`, то утечек нет — он _может_ удалить переданный во владение `Y`.
    3. Если кинул исключение `new Y`, то утечек нет.
    4. А вот если исключение кинул `new X`, то **утекло** `new Y`. До конструктора `X` дело не дошло.

    Решение: `X` сам себе создает `Y`, или `unique_ptr`.

* _Замечание (не только для конструкторов)_: в таком коде
    ```c++
    try {
        T** arr = new T[238];  // 1
        ... // 2
    } catch (const std::bad_alloc&) {
    }
    ```
    если `1` бросит исключение, то утечки памяти не будет, поскольку new либо отработает корректно, либо отчистит всю память которую выделил и вызовет все деструкторы. Если же `2` кинет исключение - утечка памяти, поскольку к `arr` мы уже не сможем обратиться, чтобы вызвать оператор `delete`

_Замечание_ про function try block: он может использоваться не только в конструкторах, но его необходимость отсутствует, поскольку он заменяется на привычный try-catch блок. Пример (возможно, на экзамене не нужен):
```c++
int f(int n = 2) try {
   ++n;
   throw n;
} catch(...) {
   ++n; // n все еще видна как параметр функции
   assert(n == 4);
   return n;
   // throw НЕ дописывается неявно
}
```
### Исключения из деструктора
По умолчанию исключения из деструктора бросать **запрещено** (неявно дописан `noexcept`), иначе вызывается `std::terminate`. Причина: деструкторы активно вызываются в момент, когда поймано какое-то другое исключение и происходит раскрутка стека, поэтому не ясно, как с этим справляться, если вылетит еще одно исключение (из деструктора).

### Преимущества и недостатки
* Преимущества:
    * Потенциально меньше кода
    * Явное разделение нормальной работы программы и исправления ошибки
* Недостатки:
    * Время работы программы может пострадать
    * Требуют аккуратности с ресурсами

### Непойманные исключения
Непойманные исключени - аварийно завершают программу, при это возможно такое, что программа поймет, что исключение никто не поймает, и завершится **без** раскрутки стека.

Решение: ловить их (например, оборачивать `main` в `try-catch` блок).

Лично у меня такой код ничего не выводил:
```c++
struct sd {
    ~sd() { cout << "finally"; }
};

int main() {
    sd var;
    throw int();
}
```
## Билет 11
Автор: Глеб Марьин

### Определения и примеры

Следующие понятия характеризуют код с точки зрения безопасности при работе с исключениями: как плохо будет коду, если выкинется исключение.

- No throw: исключения не кидаются, код всегда работает (или в хлам роняет программу, если не повезло).
  - Хороший пример: a = b; для простых типов.
  - Плохой пример: то же самое для сложных (в случае вектора может не хватить памяти).
  - Плохой пример: ввод-вывод.
  - Пример от автора: деструкторы тоже обычно не кидают, чтобы всегда можно было бы успешно произвести stack unwinding.

- Strong guarantee (сильная гарантия): если исключение и вылетело, то ничего не поменялось, например если оно вылетело из Foo::bar(), то Fo все ещё в корректном состоянии, можно без страха продолжать использовать.
  - Пример: list::push_back. Если памяти не хватило, то исключение вылетело, но список не поменялся вообще. Если упал конструктор копирования, то список не поменялся вообще.
  - Пример: vector::push_back. Если памяти не хватило, то исключение вылетело, но вектор не поменялся вообще. Тонкость: для этого надо, чтобы элементы могли копироваться с гарантирей strong. Или перемещаться, но тогда nothrow.

- Basic guarantee (базовая гарантия): если исключение и вылетело, то не произошло UB, все объекты в каком-то корректном состоянии (инварианты есть), нет утечек и прочих проблем.
  - Пример: vector::push_back, если мы не имеем права копировать/перемещать объекты без ошибок. Правда, всё ещё надо уметь уничтожать объекты.

- No guarantee: если исключение произошло, можно только завершить процесс. Если программа дошла до этого момента, то непонятно как давно случилась ошибка, и что плохого сделано уже, поэтому, чтобы не наломать дров стоит убить программу.

### Невозможность обеспечения basic guarantee на основе no guarantee

Если какой-то код не предоставляет даже базовой гарантии, и наш код использует этот небезопасный код, то наш тоже становится небезопасным, потому что если из плохого вылетит исключение, то мало ли что он попортил, он на то и no guarantee. Таким образом наш код тоже no guarantee.

### Обеспечение базовой гарантии при помощи RAII

Как сказал Егор в консультации: RAII помогает нам обеспечивать
базовую гарантию очень сильно. Если мы везде используем умные указатели,
везде пишем RAII, везде корректно пишем деструкторы, то базовая
гарантия всегда есть. То есть никогда не нужно писать явно try/catch, просто всегда есть базовая гарантия.

### Гарантии в шаблонах

В шаблонах мы не знаем заранее, какие гарантии предоставляет шаблонный
тип. Поэтому гарантии нашего кода зависят от гарантий этого типа.
Немного особая ситуация с деструкторами:
все ок, если деструктор типа `No throw`.
Если же это не так, то во время `unwinding`-a может вылететь исключение,
произойдет что-то плохое, везде говорят что
`application will terminate`, возможно `std::abort`, или `std::terminate`.
Так что в этом случае я бы сказал, что не будет гарантии исключений,
хотя вопрос философский, и уверен, что эти дебри не нужны для экзамена.
Если методы класса не предоставляют какой-то гарантии, то мы,
работая с ними, не можем её предоставить. Например, пишем

```C++
template <typename T>
int foo(const T &a, const T &b) {
  if (a == b) {
    return 0;
  }
  T c(std::move(a));
  return 239;
}
```

Тогда гарантия будет определяться как худшая из `T::operator==(const T &)` и `T::T(T &&)`. Соответственно, если мы хотим, чтобы `foo` была
с какой-то гарантией, то нужно её потребовать от вызываемых методов.

### noexcept для функций и методов

Есть спецификатор функции `noexcept`, который говорит, что функция
или метод не может кинуть исключения, синтаксис

```C++
void foo() noexcept {
  some_noexcept_call_1();
  some_noexcept_call_2();
  2 + 2;
}

struct Foo {
  void foo() noexcept {};
};
```

Если внутри такой функции вылетит исключение, то случится ошибка
выполнения, точнее `std::terminate`. Из `noexcept` можно вызывать только `noexcept`
функции и методы, точно также, как с const qualified.
Важно знать, что любая аллокация может кинуть, и все, кто её вызывают.
`new`, `std::make_unique`, `std::make_shared`, везде может вылететь
`std::bad_alloc`, что значит, что на куче не хватило памяти для
выделения места под объект.

### Условный noexcept, оператор noexcept

- Оператор noexcept позволяет узнать, может ли из выражения теоретически вылететь исключение (по спецификаторам noexcept).
- Возвращает true/false на этапе компиляции, не вычисляя выражение.

```C++
int bar()          { return 2; }
// ....
int a = 10;
vector<int> b;
static_assert(noexcept(a == 10));
static_assert(!noexcept(new int{}));   // Утечки не будет: не вычисляется.
static_assert(noexcept(a == foo()));
static_assert(!noexcept(a == bar()));  // bar() не noexcept
static_assert(!noexcept(b == b));      // vector::operator== не noexcept
bool x = noexcept(a = 10);
assert(x);
```

В шаблонах хотелось бы помечать функции и методы noexcept,
если это возможно. Для этого используется условный noexcept.

Можно вызвать оператор внутри спецификатора:

```C++
template<typename T> struct optional {
    optional() noexcept;
    optional(optional &&other) noexcept(    // noexcept только при условии...
       noexcept(  // ...что следующее выражение noexcept...
           T(std::move(other))  // вызов move-конструктора T
       )
   );
}
```

Получаем:

```C++
template<typename T> struct optional {
    optional() noexcept;
    optional(optional &&other) noexcept(noexcept(T(std::move(other))));
}
```

Применение. Полезно для vector со строгой гарантией исключений.
Если у элементов is_nothrow_move_constructible, то можно перевыделять буфер без копирований:

```C++
void increase_buffer() {
    vector_holder new_data = allocate(2 * capacity);  // Может быть исключение.
    for (size_t i = 0; i < len; i++)
        new (new_data + i) T(std::move(data[i]));     // Портим data, боимся исключений.
    data.swap(new_data);                              // Исключений точно нет.
}
```

Иначе мы обязаны копировать. Уже есть готовая функция:

```C++
void increase_buffer() {
    vector_holder new_data = allocate(2 * capacity);
    for (size_t i = 0; i < len; i++)
        new (new_data + i) T(std::move_if_noexcept(data[i]));
    data.swap(new_data);
}
```
## Билет 12
Автор: Кирилл Бриллинатов

### Строгая гарантия в конструкторах (ctor) и деструкторах (dtor)
#### ctor
В **ctor** обеспечить строгую гарантию исключений очень просто, так как до конструктора у объекта 
не было состояния - его не существовало. Тогда если в конструкторе вылетело исключение, 
то после этого состояние не поменяется. Единственное, надо следить за тем, чтобы не утекали 
ресурсы - этого проще всего добится использованием RAII-оберток. 
```cpp
struct HuffmanArchiver {
  HuffamnArchiver(const std::string& inputFilename, const std::string& outputFilename) 
      : inputFilename_{inputFilename}, outputFilename_{outputFilename} {}
      // если std::bad_alloc вылетело при копировании в outputFilename_, то inputFilename_ корректно удалится
private:
  std::string inputFileaname_, outputFilename_;
};
```

#### dtor 
В **dtor** обеспечение строгой гарантии должно быть выполнено, так как неявно все **dtor** помечены **noexcept**

### Общий алгоритм для проведения остальных операций

В общем случае, чтобы обеспечить строгую гарантию исключений для метода класса, можно провести необходимую операцию в два шага: 
1. Сделать все "кидающие" операции, не меняя состояния класса
2. Обновить (если надо) состояние класса с помощью "не кидающих" операций (например мувами)

```cpp
struct Matrix {
  void setColNRow(int cols, int rows) { 
    data_.resize(rows);
    for (auto& row : data_)  {
      row.resize(cols);
    }
  }
  // Плохая реализация, так как внутри цикла может выкинутся bad_alloc, а состояние объекта уже изменено

  void setColNRow(int cols, int rows) { 
    std::vector<std::vector<int>> newdata(rows);
    std::copy(data_.begin(), data_.end(), newdata.begin()); // копирование векторов
    for (auto& row : newdata) { 
      row.resize(cols);
    }
    std::swap(data_, newdata);
  }
  // Лучше, так как swap по умолчанию noexcept

private:
  std::vector<std::vector<int>> data_;
};
```
### Copy-swap trick
```cpp
struct DataHolder {
  DataHolder(const DataHolder& other) : size_{other.size_} { 
      std::unique_ptr<char[]> newdata(new char[size_]);
      std::memcpy(newdata.get(), other.data_, other.size_);
      data_ = newdata.release();
  }
  
  DataHolder& operator=(DataHolder other) { 
    std::swap(data_, other.data_);
    std::swap(size_, other.size_);
    return *this;
  }
  // При вызове создаетсь копия, того что передали (или мувается, но это видимо здесь неважно), 
  // затем происходит обмен полями с other и так как время жизни other ограничено фигурными 
  // скобаками, то он удалится и вызовется деструктор DataHolder и старый data_ удалится.

private:
  char* data_;
  std::size_t size_;
};
  
```
*Замечание* ```cpp std::unqiue_ptr<T[]>``` для того, чтобы если в std::memcpy произойдет исключение не произошло утечки ресурсов.

Из-за такой реализации код сильно упрощается.
### Проблемы с move-семантикой
Проблемы возникают, когда мы работаем с объектами, у которых move оператор присваивания или ctor 
не **noexcept**. Особенно сложно становится, когда мы храним такой объект по значению. Так как в 
таком случае, например, в move операторе приходится явно мувать этот объект. Можно скопировать, 
но у объекта может быть некопируемым (бывает достаточно часто). Получается, что иногда такие проблемы 
не получается решить и лучше для своих структур делать move ctor и оператор **noexcept**
#### Вывод
Пример, когда нельзя решить: пишем контейнер, хотим reserve - выделили новую память, туда
надо, либо мувать, либо копироавть. Move-оператор - не **noexcept**, нет ctor коипрования.

Пример, когда можно решить: все тоже самое - но есть ctor копирования, тогда можно полностью все скопировать в новый буфер, потом свопнуть указтели (это **noexcept**)

### pop в stack
При реализации метода pop в классе stack нельзя одновременно вернуть последний элемент и удалить его. До move-семантики нужно обязательно кипровать возвращаемое значение, но тогда во время возврата значения могло кинуться исключение, а состояние объекта уже поменялось.
```cpp
T pop() {
  return data_[--size_];
}
```
Но move-семантика не до конца решает (опять же может быть кидающий move ctor). В связи с этим разделют данную процедуру на две - top и pop
```cpp
void pop() {
  // как-то удалили последний элемент
  --size_;
}

T top() const {
  return data_[size_ - 1]; 
}
// можно добавить rev-qualified перегрузок - из временного стэка можно мувать, так как он умрет все равно.
```

## Билет 13
Автор: Кирилл Карнаухов

### Объект-функтор
Функтором называется класс (или структура) с перегруженным `operator()`. Могут применяться также, как и функции, однако имеют преимущества. Например, хотим посортировать массив по компаратору `a[i] * x`, где `x` — константа. Для обычной функции-компаратора пришлось бы заводить отдельную глобальную константу, что не очень хорошо. Однако в функторе мы можем хранить `x`, как поле класса. Возможная реализация:
```cpp
struct Comparator {
    int x;
    bool operator()(int a, int b) {
        return a * x < b * x;
    }
};
```
Теперь можно использовать этот функтор, например, для сортировки такого вида:
```cpp
template<typename T, typename Cmp>
void sort(Array<T>& array, Cmp cmp) {...}
```
Плюсом ко всему является то, что нет виртуальных вызовов.

### Применение в алгоритмах 
Функторы имеют огромное применение в `std::algorithm`. Например, имея функтор из предыдущего пункта, можно:
```cpp
std::vector<int> arr = {...};
std::sort(arr.begin(), arr.end(), Comparator{1}); //сортировка по возрастанию
std::sort(arr.begin(), arr.end(), Comparator{-1}); //сортировка по убыванию
```
Сюда можно передавать все, отчего можно вызвать `()` без аргументов. 

Примечание: в таких применениях от функции требуются некоторые свойства, например, антисимметричность и транзитивность. Иначе это UB (в лучшем случае будет Runtime Error). 

### Функторы, как компараторы в ассоциативных контейнерах
По умолчанию, `std::set` хранит значения по возрастанию. Хотим хранить, например, `int` по убыванию. Напишем компаратор:
```cpp
struct Comparator {
	bool operator()(int a, int b) {
		return a > b;
	}
};
```
Тогда, если написать `std::set<int, Comparator>`, то контейнер будет хранить ключи по убыванию. 

В общем, случае, нужно передавать функтор, который для `(a, b)` возвращает `true`, когда `a` должен идти *не позже* `b`. 

То же самое можно делать с `std::map` и другими ассоциативными контейнерами. 

### Лямбды
Все это, конечно, очень круто, но иногда нам нужно использовать функтор всего в одном месте, и как-то не хочется для этого создавать отдельный класс. Или нам хочется создать функцию внутри другой функции. Для этого придумали лямбды. Синтакис такой:
```cpp
auto func = [](int a, int b) {
	return a + b;
};
```
По сути, лямбды — это синтаксический сахар. На самом деле, это просто функтор с неизвестным типом. Применение:
```cpp
std::sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; }); //сортировка по убыванию
```
По умолчанию, в лямбдах нельзя ничего использовать, помимо глобальных переменных. Чтобы была возможность брать переменные из области видимости, есть так называемые захваты:
```cpp
int x = 100;

auto cmp1 = [x](int a, int b) { return a * x < b * x; }; //захват по значению (то есть значение x скопируется)
auto cmp2 = [&x](int a, int b) { return a * x < b * x; }; //захват по ссылке
auto cmp3 = [=](int a, int b, int c, std::string d) { ... }; //захват всей области видимости по значению
auto cmp4 = [&](int a, int b, float f) { ... }; //захват всей области видимости по ссылке

struct smth {
	void func() {
		auto f = [this]() { ... }; //захват всего экземпляра класса
	}
};
``` 

### Подробности лямбды
Как уже говорилось, нельзя явным образом получить тип лямбды. Однако, если мы хотим указать тип, например, для шаблонов, то можно использовать `decltype`.

Лямбда превращается в анонимный класс с `operator()`. 

Также, комппилятор все оптимизирует на этапе компиляции.

### mutable для лямбды
По умолчанию, лямбда создает функтор с `operator()`, который является `const-qualified`. Но иногда нам все-таки хочется менять переменные внутри оператора. Для этого можно написать `mutable`, то есть:
```cpp
int x = 10;
auto func = [x](int a, int b) mutable {
	x--;
	return a * x < b * x;
};
```
В данном случае скопируется значение `x` и его изменения не будут касаться внешнего `x`. Однако, между вызовами `func()` значение `x` внутри лямбды будет сохраняться (то есть `10, 9, 8, ...`).

Если вы хотите, чтобы изменения касались и внешнего `x`, то нужно захватить по ссылке. Тогда `mutable` не нужен. 

### Возвращаемое значение
Лямбда сама узнает, какое возвращаемое значение у `operator()`. Например, здесь это `int`:
```cpp
auto func = [](int x) { return x * x; };
```
Если функция возвращает несколько значений, то компилятор смотрит на первый `return`. То есть следующий код **не** скомпилируется:
```cpp
auto func = [](int x, double y) {
	if (x > 0) {
		return 0;
	} else {
		return y;
	}
};
```
Это происходит, потому что компилятор не понимает, что именно мы хотим вернуть. Однако, можно использовать касты. 

Также можно явно указать тип возвращаемого значения:
```cpp
auto func = [](int a, double y) -> double { ... };
```

### Шаблонные параметры
Пока полноценные шаблоны для лямбд в C++ не завезли (завезли в C++20, но для экзамена это не нужно), но есть `auto`.  Например, можно так:
```cpp
std::vector<std::string> array = { ... };
std::sort(array.begin(), array.end(), [](const auto &fir, const auto &sec) {
	return a.length() < b.length();
});
```
Компилятор сам поймет, какие типы у аргументов. 

### Отличия от `std::function`
Внутри `std::function` хранится указатель на выделенный объект на куче, у которого нужно вызвать `()`. Можно ли хранить лямбды в `std::function`? Да, можно. Нужно ли? Нет, нужно пытаться этого избегать.

Проблема в том, что вызов метода у `std::function` — это виртуальный вызов и он не всегда будет соптимизирован. В то же время, лямбда не имеет виртульаных вызовов. Из-за этого `std::function` может работать сильно медленнее обычной лямбды.

Если хотите сохранить лямбду, можете сохранить ее в шаблон.
## Билет 14
Автор: Валера Головин
### Шаблонные классы
```C
// my_array.h
class IntArray {
private: 
    int *array;
    size_t size;
public:
    ...
}
```
Хотим сделать IntArray не только для int
#### Решение в Си
```C
// my_array.h
#define MyArray(TYPE) class MyArray_##Type { \
private: \
    TYPE *array; \
    size_t size; \
public: \
    ... \
}
// \ - перевод строки, а ## - конкатенация токенов.

// Применение
#include "my_array.h"
MyArray(int);
MyArray(double);

MyArray_int a;
```
##### Проблемы
* среда разработки никак не поможет
* очень странные ошибки могут быть, при опечатке в названии
* не работает с namespace: `MyArray(details::Foo)` не скомпилируется.

#### Решение в C++
```cpp
template<typename T>
class MyArray {
private:
    T *data;
    size_t size;
public:
    Array();
    Array(const Array& other);
    T& get(size_t i) { return data[i]; }
    T& operator[](size_t i);
};

<T>
T& MyArray<T>::operator[](size_t i) { return data[i]; }
<T>
T& MyArray<T>::Array() { ... }
```
* Здесь `MyArray` — шаблон, а `MyArray<int>` — класс.
* Все `MyArray<???>` абсолютно независимые.
* Компилируется методом "скопировали токены, заменили `T` на указанный тип".
  * Нет проблем с именами.
* Шаблон проверяется только на базовую синтаксическую корректность
  (скобочки сошлись), но не компилируется, пока не потребуется.
* В момент первого использования шаблон **инстанцируется** в конкретный класс и происходит компиляция. (_Инстанцирование (англ. instantiation) — создание экземпляра класса_)
  Тут уже можно получить несоответствия типов, не найденные перегрузки функций...
  * Инстанцируется отдельно: все поля класса (когда пытаемся создать объект), методы (когда вызываем конкретный метод; то есть какие-то методы могут для некоторых типов не работать). Пока методы в классе не вызываются они могут вообще не иметь смысла ("утиная типизация").
* Так как работает потенциально с любым типом,
  все реализации должны быть в `.h`.
 Компилятор должен понимать, какой для какого типа он должен компилить.
* До C++11 нельзя было писать `vector<vector<int>>`, потому что `>>` похоже на битовый сдвиг.

### Шаблонные функции
```cpp
template<typename T>
void print(const vector<T>& a) {
    for (const auto& i : a) {
        std::cout << i << '\n';
    }
}

// использование
vector<int> a;
print<int>(a);
print(a); // он решит уравнение и поймет, что T = int
```
Проверка наличия << у типа `T` происходит только в момент инстанцирования.
Если есть несколько перегруженных функций, то компилятор в каждой перегрузке решит
уравнение, если не получилось - выкинет из кандидатов, а среди выживших
проведёт конкурс "кто лучше подходит под параметры".
```cpp
// объявление функций
template<typename T, typename V>
void foo(V x);

template<typename T, typename V>
void goo(T x);

template<typename T = void, typename V>
void hoo(V x);


// вызов этих функций
foo<int>(10.0); // T = int, V = double
foo(10.0); // не хватает информации для T

goo<int>(10.0); // не хватает информации для V
goo(10.0); // не хватает информации для V

hoo<int>(10.0); // T = int, V = double
hoo(10.0); // T = void, V = double
```
Еще один пример с сортировкой
```cpp
template<typename T, typename Cmp>
void sort(Array<T> &arr, Cmp fn);

// вызов
struct Comparator {
    bool operator()(int a, int b) {
        return a < b;
    }
};
Comporator c;
Array<int> arr;
sort<int, Comparator>(arr, c); // явное указание типов
sort(arr, c);
```
Работает быстрее, т. к. нет виртуальных вызовов.
Код можно сократить, используя лямбды.
```cpp
sort(arr, [](int a, int b) { return a < b; });
// Тип лямбды неизвестен, его явно не указать, только автовыводом.
```
### Строгая гарантия исключений
### Неявный конструктор присваивания
В стандарте есть:
```cpp
class Foo {
    Foo(const Foo&)  // Copy constructor
    Foo(Foo&&)       // Move constructor
    Foo& operator=(Foo&&)       // Move assignment
    Foo& operator=(const Foo&)  // Copy assignment (1)
    Foo& operator=(Foo)         // Copy assignment (2) для copy-and-swap.
};
```
* Если не объявлен копирующий конструктор, то его сгенерирует компилятор.
* Даже если есть другой подходящий конструктор

```cpp
class Foo {
    template<typename T>
    Foo(const T&) {}    // (1) не copy constructor.
    // Foo(const Foo&)  // (2) copy constructor.
    // (2) неявно объявлен и определён, приоритет выше (1).
};
```
При вызове `Foo new_foo( foo )` вызовется `Foo(const Foo&)`

## Билет 15
Автор: Егор Лебедев

### Параметры шаблонов
Современный `c++` предоставляет множество возможностей программисту. 

0. Шаблоны могут иметь параметры по умолчанию

В частности параметрами шаблона могут быть 
1. Произвольные типы
2. Целые числа
3. Любые указатели и _ссылки_ на статические переменные
4. Шаблоны
5. В параметрах шаблонах возможно указывать параметры по умолчанию (при этом если у типа C в шаблоне был какой-то параметр по умолчанию, он не "отнаследуется" в шаблон-параметр)
6. `bool`
7. Начиная с `c++20`: к целочисленным типам добавился `float`
8. Начиная с `c++20`: к целочисленным типам добавились какие-то структуры
```c++
struct MyStruct {
    int x;
};

template<typename T = char>        // 0
struct Helper { T x; };

int globalVar = 4;

template<
    typename T,                    // 1
    std::size_t N,                 // 2
    int& P,                        // 3
    template<typename> typename U, // 4
    template<
        typename = T, 
        typename = allocator<T>
    > typename C,                  // 5
    bool B                         // 6
    /*  float f    */ // c++20     // 7
    /*  MyStruct  */ // c++20      // 8
> struct Hell {
    void go() {
        T t = N + P;
        U<T> u{ t };
        C<> c; c.push_back(t);
        assert(B);
    }
};
int main() {
    Hell<int, 10, globalVar, Helper, vector, (100 > 11)> hell; // 9
    hell.go();
}
```
9. Стоит заметить, что `(100 > 11)` обязательно, иначе беды с парсингом.

### Автовывод параметров шаблонов
Шаблонные функции умеют получать информацию (о шаблонах) от своих аргумент, поэтому их не всегда стоит явно указывать:
1. Можно указать лишь несколько шаблонных параметров, остальные выведутся из аргументов функции
2. Шаблонные параметры `U`, `F` в коде ниже функция вывела из своих аргументов.
3. Параметры по умолчанию не обязательно должны быть в конце
```c++
template<typename F, typename T = long long, typename U = void, typename V>
void func(F f, T t, U u, V v) {
    cout << f + t + u + v;
}

func<int>({}, {}, 5, -1);
```
Данный код выведет на экран число `4`

* Начиная с `c++17` аналогичное работает для конструкторами класса, называется `Class template argument deduction` (`CTAD`).

### Специализации шаблонов

Синтаксис:
1. Общий случай
    ```c++
    /* 1.1 */ template<typename T> class Stack { ... };
    /* 1.2 */ template<typename T> class unique_ptr { ... };
    ```

2. Специализация
    ```c++
    /* 2.1 */ template<> class Stack<bool> { ... };
    ```
    Если компилятор где-нибудь увидит `Stack<bool>`, то он будет обращаться именно к специализации, иначе - общий случай. (Понятно, что работает не только для `bool`).

    Важно отметить, что общий случай может не иметь вообще ничего общего со специализацией кроме имени.

3. Частичная специализация
    ```c++
    /* 3.2 */ template<typename T> class unique_ptr<T[]> { ... };
    ```
    Теперь мы можем заменить `delete` из общего случая на `delete[]` в частичной специализации. 

    Эта специализация берется, "если уравнение с `T[]` решается относительной данной переменной", иначе берется общий случай.

4. Вообще любые уравнения
    ```c++
    /* 4.1 */ template<typename T, typename U, std::size_t N>
    class Stack<std::map<T, std::array<U, N>>> { ... };
    ```
    Мораль: вместо `...` в `Stack<...>` можно подставлять вообще любое уравнение на тип.

_Замечание_: частичные специализации есть только у структур/классов, функции - только полные специализации, но это уже совсем другой билет...
## Билет 16
Автор: Илья Онофрийчук

## Псевдонимы шаблонов
Инстанцированный шаблон -- это обычный тип, поэтому для него можно написать `typedef`
```cpp
typedef vector<int> vi;
``` 
Для неинстанцированных шаблонов так писать уже нельзя, будет ошибка компиляции
```cpp
typedef vector v; //compilation error
``` 
В C++11 появился Alias template(псевдоним шаблонов). Конкретные примеры:
```cpp
template<typename T>
using v = vector<T>;

template<typename T>
using enable_if_t = typename enable_if<T>::type;
```
## Шаблонные методы в шаблонных классах
Рассмотрим пример:
```cpp
template<typename T>
struct shared_ptr {
    Storage *s;
    shared_ptr(T *data);
};

struct Base {};
struct Derived : Base {};

int main() {
    shared_ptr<Derived> d = ...;
    shared_ptr<Base> b = d;  // Упс, несовместимые типы.
}
```
Возникает проблема, что мы не можем записать указатель на наследника в указатель на базовый класс. 

Причина: `shared_ptr<Derived>` и `shared_ptr<Base>` -- разные типы, и они друг с другом не связаны. 

Решение: добавить шаблонный конструктор.
```cpp
template<typename T>
struct shared_ptr {
    ...    
    template<typename U>
    shared_ptr(const shared_ptr<U> &p);
};
```
Не смотря на то, что данный конструктор сработает даже если `U*` нельзя будет привести к `T*`, например `U = int` и `T = Derived`, произойдёт ошибка компиляции, то есть всё безопасно.

Аналогично любой метод у класса может быть шаблонным, при этом автовывод шаблонных параметров будет работать также как у шаблонных функций. Также, ***не конструктор*** можно  вызвать, явно указав параметры шаблонного метода. 

## Необходимость слов `typename` и `template` в некоторых контекстах

```cpp
template<typename T> struct A { using x = int; };
template<typename T> struct B {
    void foo() {
        A<T>::x * y; // (1)
    }
};
```
Неочевидно, что делает строчка `(1)`, это либо умножение, либо объявление переменной типа `A<T>::x`. Поэтому обычно компиляторы требуют явно писать слово `typename` перед зависимым типом, иначе они будут трактовать `x` как переменную. Строку `(1)` следует исправить слеующим образом:
```cpp
typename A<T>::x * y;
```
Пример про `template`:
```cpp
template<typename T> struct A { ... };
template<typename T> struct B {
    template<typename U> using C = A<U>;
};
template<typename T> struct D {
    B<T>::C<T>::x ... // (1)
};
```
В строке `(1)` компилятору неясно `C` -- это поле или шаблон. Поэтому нужно добавить перед `C` слово `template`. То есть строка `(1)` должна иметь следующий вид:
* Если `x` -- это переменная: 
```cpp
B<T>::template C<T>::x ...
```
* Если `x` -- это тип: 
```cpp
typename B<T>::template C<T>::x ...
```
Аналогичная проблема может возникнуть при вызове шаблонных функций, которым хотим явно задать параметры:
```cpp
template<typename T> struct Foo {
    template<typename U> 
    void foo();
};

template<typename T>
void bar() {
    Foo<T> x;
    x.template foo<char>();
}
```
Компилятору может потребоваться явное указание того, что `foo` -- это метод, так как он не знает метод ли это, поле или что-нибудь ещё.
## Специализации шаблонов функций
Частичной специализации функций не существует, есть только полная.

Пример специализации функции:
```cpp
template<typename T> 
void my_swap(T &a, T &b) { ... }

template<> 
void my_swap<std::string>(std::string &a, std::string &b) { ... }

template<typename T> 
void my_swap<std::vector<T>>(std::vector<T> &a, std::vector<T> &b) { ... } // compilation error, так как частичной специализации для функций не существует
```
Вместо частичной специализации функций предполагается использовать перегрузки.
```cpp
template<typename T> 
void my_swap(std::vector<T> &a, std::vector<T> &b) { ... } // Ok. Это перегрузка, а не специализация
```
Однако функцию `std::swap` можно по стандарту специализировать, но не перегружать. Стандарт запрещает добавлять свои перегрузки в пространство имён `std` .

## Отличия специализации шаблонов функций и перегрузок
```cpp
template<typename T>
void print(const T &) { } //(1)

template<>
void print<std::vector<int>>(const std::vector<int> &) { } //(2)

template<typename T>
void print(const std::vector<T> &) { } //(3)

int main() {
    std::vector<int> vi;
    std::vector<float> vf;

    print<std::vector<int>>(vi); //вызовется (2), T = std::vector<int>
    print<int>(vi); //вызовется (3), T = int

    print<std::vector<float>>(vf); //вызовется (1), T = std::vector<float>
    print<float>(vf); //вызовется (3), T = float
    return 0;
}
```

## Билет 17
Автор: Юра Худяков

Руководствуясь лекциями Скотта Майерса и Егора.

Есть разные виды вывода типа. 
1. Шаблонный
2. auto
3. Возвращаемое значение функций и лямбд
4. Захват переменных в лямбду
5. decltype

При этом они пересекаются и где-то похожи, где-то отличаются.

Начнём по порядку.

### Шаблоны И auto


```c++
template<typename T>
void f(PARAM param);

f(EXPR);
```

Авотматически выводится, что такое `T` и что такое `PARAM`.

Пример: `T` не всегда такой же, как `PARAM`

```c++
template<typename T> 
void printAll(const vector<T>&);

printAll(vector<int>{10, 20});
```

Здесь `PARAM=const vector<int>&`, `T=int`.

#### PARAM&, PARAM\*    -- ссылки и указатели, ссылки НЕ RVALUE

То есть функция принимает по ссылке или по указателю, притом не забываем, что они могут быть константными (или `volatile`)

Правила:
1. Отбрасываем у `EXPR` ссылку (если есть)
2. Делаем pattern matching, на основе которого выводим тип. 

Важно: здесь `T` никогда не выведется в ссылку или указатель.

Пример:

```c++
template<typename T> void f(T&);

      int    x = 10;   f(x);           // T =       int, PARAM =       int&
const int   cx = 20;  f(cx);           // T = const int, PARAM = const int&
      int  &rx =  x;  f(rx);           // T =       int, PARAM =       int&
const int &crx =  x; f(crx);           // T =       int, PARAM = const int&

template<typename T> void g(const T&);
g(x);                                  // T =       int, PARAM = const int&
```

Разберём этот пример. (очень подробно, можно пропускать, если выше понятно)

Первый вызов: `EXPR` - это `x`. Ссылки у `x` нет, отбрасывать нечего, тогда `T = int`. Получаем, `T& => int&`

Второй вызов: `EXPR` - это `cx`. Ссылки у `cx` нет, отбрасывать нечего, тогда `T = int`. Получаем, `T& => const int&`

Третий вызов: `EXPR` - это `rx`. Отбросили ссылку, получили `int& => int`, тогда `T = int`. Получаем, `T& => int&`

Четвёртый вызов: `EXPR` - это `rx`. Отбросили ссылку, получили `const int& => const int`,тогда `T = const int`. Получаем, `T& => const int&`

Аналогично с вызомом `g`: только теперь `PARAM` имеет ещё и `const`, и то, во что выводится `T`, не поменялось, зато поменяется тип аргумента (что логично, мы его поменяли)



С `auto` удобно: выводится так же, как и для `T` в шаблонах.

```c++
int x = 10;
const int cx = x;
int& rx = x;
const int& crx = x;

      auto&  rx_a1 =   x;  // auto =       int =>       auto& =       int&
      auto&  rx_a2 =  cx;  // auto = const int =>       auto& = const int&
const auto& crx_a3 =  rx;  // auto =       int => const auto& = const int&
const auto& crx_a4 = crx;  // auto =       int => const auto& = const int&

```

#### PARAM&& -- ссылка RVALUE

Здесь также про __Forwarding Reference__

Ведёт себя почти также, как если бы была PARAM&, но в некоторых местах отличается

Если у нас написано некоторое выражение от шаблонного параметра, например, `Foo<T>&&`, то оно себя вести будет точно также, как и в пункте выше: отбрасывать у `EXPR` ссылку, паттерн-матчить. Сюда же относится и `const T&&` !

Если же у нас написано просто `T&&`, происходят <s>костыли</s> другие вещи.

Если `EXPR` - это lvalue (просто переменная, например), то если в предыдущем пункте она вывелась в `E`, то здесь `T` выведется в `E&`. И `PARAM` выведется в `E&` тоже.

Притом если `EXPR` - это rvalue, то она выведется "по-нормальному": `T = E`, `PARAM = E&&`

```c++
template<typename T> void f(T&&);

      int    x = 10;   f(x);           // T =       int&, PARAM = int&
      int  &rx =  x;  f(rx);           // T =       int&, PARAM = int&
                      f(std::move(x)); // T =       int,  PARAM = int&&

const int   cx = 20;  f(cx);           // T =  const int&, PARAM = const int&
const int &crx = cx; f(crx);           // T =  const int,  PARAM = const int&&
// последняя строчка: const int& - это rvalue, так что вывелось "по-нормальному"
```

Возможно, поможет следующее:

```c++

f(T&), зовём f(EXPR&)   => T&
f(T&), зовём f(EXPR&&)  => T&
f(T&&), зовём f(EXPR&)  => T&
f(T&&), зовём f(EXPR&&) => T&&

// "Минимум" по количеству амперсандов :)

```

Но по факту, первые 2 работают вполне стандартно - убирают ссылку, припиливают свою.
Последний работает тоже стандартно - убрал ссылку, припилил свою.
А вот третий работает необычно.

На лекции Скотта Мейерса говорилось примерно следующее: 
Мы пишем в объявлении параметра функции T&&, но при этом при инстантации шаблона он может стать как T&, так и T&&, в зависимости от принимаемого аргумента. 

Поэтому он называет их Universal reference. В стандарте их зовут Forwarding reference.

Итого, суть: `f(T&& t)` сохранит категорию значения `t`: была lvalue, останется lvalue, была rvalue, останется rvalue. При этом она сохраняет и все CV-qualifiers, то есть const и volatile, они не отбрасываются при выводе для __ссылок__ (или указателей, но здесь они нафиг не нужны)

Отсюда вырастает прекрасная возможность делать Perfect Forwarding: мы можем сделать функцию, которая полностью сохраняет категорию значения и все cv-qualifier-ы. Это уже залезает в Perfect Forwarding и здесь вроде не нужно.

`auto&&` тоже можно, например, range-based for
```c++
    for (auto&& x: ar) {
        ...
    }
```

#### PARAM - не ссылка или указатель

То есть функция принимает по значению.

Правила: (очень похожи)
1. Отбрасываем у `EXPR` ссылку (если есть)
2. __NEW!__ Отбрасываем `const` и `volatile` у `EXPR` (если есть)
3. Делаем pattern matching, на основе которого выводим тип. 

Пример:

```c++
template<typename T> void f(T); // ЗДЕСЬ ПОМЕНЯЛОСЬ T& -> T

      int    x = 10;   f(x);           // T = int, PARAM = int
const int   cx = 20;  f(cx);           // T = int, PARAM = int
      int  &rx =  x;  f(rx);           // T = int, PARAM = int
const int &crx =  x; f(crx);           // T = int, PARAM = int



template <typename T>
struct Foo {}

template<typename T> void g(Foo<T>);

const Foo<const int> foo;
g(foo);                                // T = const int, PARAM = Foo<const int>
```

В `auto` поэтому всегда копируем: на это можно напороться (лично я несколько раз точно)

```c++
vector<int> vec = {1, 2, 3, 4};
const vector<int> cvec = vec;
const vector<int> &rvec = vec;
auto avec = vec;    // auto = vector<int>
auto acvec = cvec;  // auto = vector<int>
auto arvec = rvec;  // auto = vector<int>
```

#### braced-initializer list

__Нет типа__

А выводится в `std::initializer_list`

```c++
auto x2 {1,2,3};     // не компилируется
auto x1 = {1, 2, 3}; // auto = std::initializer_list<int>
auto x3 {1};         // auto = int
auto x4 = {1};       // auto = std::initializer_list<int>
```


### Что там в лямбдах и auto func()?

#### Тип возвращаемого значения

Возвращаемый тип лямбды - тот же, как если бы мы сделали `auto func()`
Но он выводится не как обычная auto, он выводится как шаблоны выше. 

Потому мы не можем вернуть braced-initializer list - у него нет типа, хотя он и выводится auto

```c++
auto  lambda = [](int x) { return x; }   // T=int, retval=int
auto  foo(int x) { return x; }           // auto=int
auto  foo(int &x) { return x; }          // auto=int
auto& foo(int &x) { return x; }          // auto=int, auto&=int&
auto  foo(const int &x) { return x; }    // auto=int, retval=int
auto& foo(const int &x) { return x; }    // auto=const int, auto&=const int&
```

Притом оно должно полностью сойтись с первым встреченным `return`-ом:

```c++
auto fac1(int n) { // Окей
    if (n == 1) return 1;
    else        return n * fac1(n - 1);
}
auto fac2(int n) { // Ошибка компиляции: пытаемся вывести тип из выражения `n * fac2(n-1)`, которое зависит от `T`, не выходит, компилятор не может решить такое уравнение.
    if (n > 1) return n * fac2(n - 1);
    else       return 1;
}
auto foo() {
    return 1;
    return 1.0;  // Не сошлось, ошибка компиляции.
}
```

#### Захват аргументов лямбдой

Зависит от того, как захватывать

* По ссылке - выводим как в шаблонах для ссылок
* init captute
    То есть `[x = vector<int>(10)] () {}` - как для auto, здесь по значению
    Можно делать auto по ссылке: `[&x = vector<int>(10)] () {}`
* По значению - выводим как для шаблонов, НО СОХРАНЯЕМ CV-QUALIFIERS
    Не уверен, кажется, этого нет в плане Егора, но есть у Мейерса. __Спросить__ на консультации.
    То есть, мы сохраним `const` и т.д.
    ```c++
        const int cx = 0;
        auto lam = [cx] { ... };

        // внутри лямбды равзернулось
        class lambda_name // зависит от компилятора, кажется
        {
            private:
                const int cx;
        }
    ```
    Довольно логично сохранять, если мы хотим внутри константную переменную.

#### Можно явно указать тип

И у лямбд, и у функций с auto, поддерживается следующий синтаксис:
```c++
    // лямбды
    auto lam = [] () -> int { return 1.0; };
    
    // функции
    auto foo() -> int { return 1.0; }

    // Вполне можно и темплейтные функции
    template <typename T>
    auto foo() -> T { }

    // например, с forwarding-reference-ом (можно не говорить, чтобы не попутать всё)
    template <typename T>
    auto foo(T&&) -> T&& { }
```

### А ещё есть decltype

Выводит тип выражения, это оператор из выражения в тип.

Даёт `declared type` выражения, то есть то, как он был объявлен.

В отличие от auto, никогда никуда не девает const, volatile, references.

```c++
int x = 10;             // decltype(x) = int
const auto& rx = x;     // decltype(rx) = const int&
```

Притом важно, что если брать decltype от lvalue, то будет T&, не T.
`decltype(lvalue expr of type T) = T&`

Например,
```c++
int arr[10];

// decltype(arr[0]) = int&
```

Есть какие-то мелкие особенности, они не очень важны, их Скотт Мейерс упомянул и пропустил.

#### decltype(auto)

Можно это рассказать немного раньше, это относится к предыдущему пункту.

Можно выводить тип не с помощью шаблонного вывода, а с помощью decltype-а: смотреть на decltype того, что мы пытаемся вернуть, и от этого определять тип
```c++
    int ar[10];
    decltype(auto) declauto_foo1() { // int
        int x = 1;
        return x; 
    }
    
    decltype(auto) declauto_foo2() { // int&
        return ar[0];
    }
    decltype(auto) declauto_foo3() { // int&, потому что declval((x)) - это int&, так как x - lvalue => (x) - lvalue, и она так объявлена
        int x = 1;
        return (x);
    }
```

decltype(auto) вполне может и void вывести, если ничего не возвращается.


## Билет 18
Автор: Тарасов Денис

* ### `static_cast<Target>(expr)`
  Почти всегда, когда нам необходим какой-то cast следует использовать `static_cast`. Позволяет делать все неявные преобразования из `expr` в `Target`, а так же все обратные к ним.
  * Преобразования между числовыми типами, в том числе с потерей точности.
  ```C++
  char c = 1;
  int i = 2;
  i = c; // Неявное расширяющее преобразование
  i = static_cast<int>(c); // То же самое
  c = i; // Обратное к неявному
  c = static_cast<char>(i); // То же самое
  ```
  * Знает о конструкторах типа.
  ```C++
  struct Foo1 {};
  struct Foo2 {};
  struct Bar {
      Bar() : val(1) {}
      Bar(Foo1) : val(2) {}
      explicit Bar(Foo2) : val(3) {}
      int val;
  };  
  Bar bar;
  bar = static_cast<Bar>(Foo1());
  assert(bar.val == 2);
  bar = static_cast<Bar>(Foo2());
  assert(bar.val == 3);
  ```
  * Перобразование от базового типа к наследнику. `static_cast` следит за положением базовых классов в памяти и корректно пересчитывает указатели.
  ```C++
  struct Base1 {int x};
  struct Base2 {int y};
  struct Derived : Base1, Base2 {int x};
  Derived *d = new Derived;
  Base1 *b1 = d; // Можно неявно
  Base2 *b2 = d; // Можно неявно
  assert(b1 != b2);
  Derived *d1 = static_cast<Derived*>(b1); // Нужен static_cast
  assert(b1 == d1);
  Derived *d2 = static_cast<Derived*>(b2); // Нужен static_cast
  assert(b2 != d2);
  ```
  * Используется для преобразований от/к `void*` (может понадобиться например при вызове C-функций), при этом значение указателя не меняется. Нельзя таким образом делать преобразование между произвольными указателями.
  ```C++
  char *pc;
  int *pi;
  pc = static_cast<char *>(pi); // CE
  pi = static_cast<int *>(pc); // CE
  void *pv = static_cast<void*>(pi);
  assert(pv == pi);
  int *pi1 = static_cast<int*>(pv);
  assert(pi == pi1);
  ```
  * Можно глушить предупреждение о том, что переменная не используется.
  ```C++
  Foo foo;
  static_cast<void>(foo); // Убирает warning
  ```

* ### `reinterpret_cast<Target>(expr)`
Нужен очень редко, небезопасен. Говорит компилятору интерпретировать `expr` как `Target`. Не компилируется в процессорные инструкции.
  * Не дает никаких гарантий на промежуточные преобразования,
  ```C++
  int *a = new int();
  void *b = reinterpret_cast<void*>(a); // Нет гарантии, что a == b
  int *c = reinterpret_cast<int*>(b);
  assert(a == c); // Лишь здесь есть гарантия
  ```
  * Может преобразовывать любые указатели/ссылки в любые другие, но часто ведет к UB из-за strict aliasing (кажется, на лекциях о нем не было).
  ```C++
  float *d = reinterpret_cast<float*>(a);
  cout << *d; // UB: нарушение strict aliasing: доступ к int через несовместимый float*
  ```
  * Преобразование из пункта выше разрешаются для `char*` и `unsigned char*` (но не `signed char*`, который является отдельным типом). Является одним из немногих разумных использований.
  ```C++
  Foo *f = new Foo();
  char *c = reinterpret_cast<char*>(foo);
  unsigned char *uc = reinterpret_cast<char*>(foo);
  cout << *c << *uc; // Не UB
  ```
  * Может конвертировать указатели в числа и обратно, если хватает места.
  * Не следит за корректностью указателей при работе с наследованием, как это делает `static_cast`.

* ### `const_cast<Target>(expr)`
Отбрасывает константность у `expr`. UB, если `expr` был константным. Используется редко, не безопасен.
  * Пример с UB и без.
  ```C++
  vector<int> vec;
  const auto &rvec = vec;
  const_cast<vector<int>&>(rvec).clear();  // Окей, т.к. vec не const
  const vector<int> cvec;
  const_cast<vector<int>&>(cvec).clear();  // UB
  ```
  * Разумное использование при написании `operator[]`. Уже реализована константная перегрузка, при этом в неконстантной нужны те же действия. В обратную сторону может быть UB.
  ```C++
  const T& operator[](size_t i) const { .. }
  T& operator[](size_t i) {
      return const_cast<T&>(static_cast<const vector<T>&>(*this)[i]); // Нет UB
  }
  ```
  * Второе разумное использование: совместимость со старым C.
  ```C++
  void println(char *s); // Мы уверены, что s не меняется внутри функции
  println(const_cast<char*>("foo"));
  ```

* ### `dynamic_cast<Target>(expr)`
    Единственный каст, позволяющий работать с полиморфными объектами (те у кого есит виртуальные функции). Позволяет узнать тип объекта во время выполнения программы. В случае неверного преобразования возвращает `nullptr` для указателей и кидает исключение для ссылок. Безопасен.

    ```C++
    struct Base { virtual ~Base(); };
    struct Foo : Base {};
    struct Bar : Base {};
    struct Derived : Foo, Bar {};

    Foo *f = ..;
    Base *b = f;  // Неявное преобразование (basecast).
    Derived *d1 = static_cast<Derived*>(f);  // Derivedcast. UB, если f не был Derived.
    Derived *d2 = dynamic_cast<Derived*>(f);  // Derivedcast. nullptr, если f не был Derived.
    Bar *bar = dynamic_cast<Bar*>(f);  // Crosscast. static_cast не умеет. Сначала преобрзует
        // к Derived (derivedcast), а затем к Bar (basecast). В случае неудачи nullptr.

    Foo &rf = f;
    Derived &rd1 = static_cast<Derived&>(rf);  // Возможно UB.
    Derived &rd2 = dynamic_cast<Derived&>(rf);  // Возможно исключение std::bad_cast.
    ```

* ### ` C-style-cast`
  Пытается применить какую-то цепочку преобразований, чтобы код скомпилировался.
  * Синтаксис (есть и другой).
  ```C++
  int i = (int)10.5;
  T foo = (T)expr;
  ```
  * Пробует следующую цепочку преобразований
    * const_cast
    * static_cast и разрешает ещё пару преобразований
    * reinterpret_cast
    * На каждый вариант пытается ещё навесить const_cast
  * Не надо использовать совсем. Лучше попробовать `static_cast`, вызов конструктора или расписать цепочку явно.

* ### `dynamic_cast`, виртуальное наследование и еще примеры
```C++
struct Base { virtual ~Base() {} };
struct Foo : virtual Base {};
struct Bar : virtual Base {};
struct Derived : Foo, Bar {};
struct Derived2 : Derived {};
int main() {
    Derived *d = new Derived2; // Неявно от наследника к базе
    Derived2 *d2 = static_cast<Derived2*>(d); // Обратно нужен static_cast
    Derived *dd = d2; // Снова неявно как в первый раз
    const Base *a = d; // Можно неявно, т.к. Base только один (виртуальное наследование)
#if 0
    // Код внутри этого #if не компилируется из-за виртуального наследования.
    // Т.к. не знаем на этапе компиляции расположения Foo и Base.
    Foo *f = static_cast<Foo*>(a);
#endif
    const Foo *f = dynamic_cast<const Foo*>a; // Единственный выход,
        // т.к. он сможет изучить строение объекта во время выполнения.
    const Bar *b = dynamic_cast<const Bar*>(f); // Кажется, здесь crosscast.
    const Derived *ddd = static_cast<const Derived*>(f); // Foo не виртуальная база Derived, 
        // поэтому static_cast достаточно, но можно и dynamic_cast
    Derived *cddd = const_cast<Derived*>(static_cast<const Derived*>(f)); // Один нельзя, 
        // необходимо быть увереным в наших действиях
}
```
## Билет 19
Автор: Глеб Марьин, исправления/расширения - Игорь Энгель

### Явные (explicit) и неявные (implicit) приведения типов

Как я понимаю, и как на консультации рассказал Егор: явные преобразования -
когда явно пишем круглые, или фигурные скобки, зависит от вызываемого конструктора,
то есть [direct initialization (cppreference)](https://en.cppreference.com/w/cpp/language/direct_initialization). Явным также является `static_cast`, например.

Если же пишем равно, или принимаем в функцию, или возвзращаем из функции, то
происходит неявное преобразование типа, то есть происходит [copy initialization (cppreference)](https://en.cppreference.com/w/cpp/language/copy_initialization#:~:text=The%20effects%20of%20copy%20initialization,destination%20object%3A%20see%20copy%20elision).

Определения direct и copy из конспекта, эти виды важны в этом билете.

Direct initialization: `T t(foo, bar)`, `T(foo, bar)`, `new T(foo, bar)`, `: member(foo, bar)` - Вызов конструктора `T` с параметрами `foo` и `bar`.

Для конструкторов от одного аргумента - `static_cast<T>(foo)`. (`static_cast<T>(foo, bar)` это не конструктор от двух аргументов, это `static_cast<T>(foo.operator,(bar))`)

В C++11 добавили: `T t{foo, bar}`, `T{foo, bar}`, `new T{foo, bar}`, `: member{foo, bar}`.

Copy initialization: `T t = ..`, `T t = {..}`, `f(t)` (если `f` принимает по значению), `return ...`, `throw ...` - Вызов не-`explicit` конструктора `T` с параметрами.

В C++11 можно делать несколько параметров - `T t = {foo, bar}` вызовет `T(int, int)` но не `explicit T(int, int)`

Примеры:

```C++
struct Point {
    int x, y;
    Point() : x(), y() /* value initialization */ {}
    Point(int x_, int y_) : x(x_), y(y_) /* direct initialization */ {}
};
Point foo(Point p) { return {p.y, p.x} /* copy initialization */; }
int main() {
    foo(Point(10, 20));  // direct initialization
    foo({10, 20});       // copy initialization
    Point p1{10, 20};    // direct initialization
    Point p2 = {10, 20}; // copy initialization
}
```

### Оператор приведения типа, конструктор приведения

Можно приводить типы двумя способами:

- Сделать конструктор от любого другого типа

```C++
struct From { ... };
struct To {
    To(const From &) { ... }
};
```

В таком случае получится конструктор приведения типа.

- Сделать оператор приведения

```C++
struct To { ... };
struct From {
    operator To() { ... }
}
```

Получится оператор приведения типа.

Эти способы абсолютно симметричны, каждая команда выбирает способ приведения,
какой ей больше нравится (от Егора: лучше конструкторы).

### Модификатор `explicit` для конструкторов и операторов приведения

По умолчанию, если написан конструктор, или оператор приведения типа, то
могут выполняться неявные преобразования к этому классу, или из него соответственно.
Чтобы избежать нежелательных неявных преобразований, нужно использовать модификатор
`explicit`, который говорит, что конструктор или оператор приведения явный.

```C++
class A {};
class B {};
class C {
public:
    explicit C(const A &) { ... } // конструктор приведения из A -> C
    explicit operator B() { ... } // оператор приведения C -> B
};

int main() {
    A a;
    // C c = a; неявное преобразование, забанено explicit
    С с(a); // все еще можно, если определено - преобразование явное.
    // B b = c; тут уместно было бы использовать operator B(), если бы он не был explicit
    B b(c); // так можно, если определено - явное преобразование.
}
```

Без `explicit` могут происходить неожиданные вещи, поэтому 10 раз подумать, прежде чем
писать не `explicit` оператор.

### Особенности `explicit operator bool()` по сравнению с остальными `explicit`-операторами

С лекции:

Например, когда пишем свой `unique_ptr`, может захотеться проверять его на `nullptr`, как с обычным указателем:

```C++
unique_ptr<Foo> f = ...;
if (f) { ...  }
// или
if (!f) { ... }
```

Можно сделать `operator bool()`. Но тогда неявные преобразования врубятся вообще везде, включая: `10 + f` (преобразовали в `bool`, преобразовали в `int`, сложили). В C++03 для этого использовались костыли под названием "Safe bool idiom" (там возвращали хитрый тип, который нельзя в `int`, но можно в `bool`), в C++11 можно написать `explicit operator bool()`. Тогда можно будет преобразовать в `bool`, но только явно, как с `explicit` конструкторами (`static_cast<bool>(...)`, `bool(...)`). Конкретно для `bool` захардкожено, что можно использовать в: `if`/`while`/`for`, `!`, `||`, `&&`, `?:` и ещё паре мест.

И добавить нечего, могу только пример привести

```C++
struct my_unique_ptr {
    explicit operator bool() { ... }
};

int main() {
    my_unique_ptr<int> a;
    if (a) {
        assert(false);
    }

    // bool a = p; explicit запрещает
    // int a = 10 + a; тоже неявное преобразование
    a.reset(new int(10));
    std::cout << (a ? *a : 0) << std::endl;
}
```

Не уверен, что это нужно, но вроде где-то это есть.

Можно делать шаблонные операторы приведения (ну вроде понятно, как делать конструкторы приведения). Например, написали свой `BigInteger`, тогда хочется написать операторы приведения к `char`, `int`, `long long`. В простом варианте так

```C++
#include <cstdint>
#include <iostream>

struct BigInteger {
    std::int64_t first = 0;
    std::int64_t second = 0; // пусть храним 2 половины числа
    template <typename T>
    explicit operator T()
    {
        return first + second; // какое-то осознанное приведение к типу, это, понятно, некорректно
    }
};

int main() {
    BigInteger i;
    std::cout << static_cast<int>(i) << std::endl;
    std::cout << static_cast<long long>(i) << std::endl;
}
```

Это работает, я проверил. Еще можно добавить SFINAE, чтобы было совсем красиво.

```C++
#include <cstdint>
#include <iostream>
#include <string>

struct BigInteger {
    std::int64_t first = 0;
    std::int64_t second = 0; // пусть храним 2 половины числа
    template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
    explicit operator T()
    {
        return first + second; // какое-то осознанное приведение к типу, это, понятно, некорректно
    }
};

int main() {
    BigInteger i;
    std::cout << static_cast<int>(i) << std::endl;
    std::cout << static_cast<long long>(i) << std::endl;
    // std::cout << static_cast<std::string>(i) << std::endl; // не компилируется
}

```

Это тоже работает, я проверил.

Ещё из экзотических примеров: можно использовать неявный шаблонный оператор приведения для реализации "перегрузки по возвращаемому значению":

```C++

struct read_by_return_val {
    template<typename T>
    operator T() {
        return read<T>(); 
    }
}

void func(std::string s) {}

int main() {
    int i = read_by_return_val(); //Вызывает read<int>()
    func(read_by_return_val()); //вызывает read<std::string>()
}
```

Но как и с любыми неявными операторами можно получить проблемы, особенно с `auto` или другими шаблонами.
## Билет 20
Автор: Денис Филиппов

* Placement new обязателен перед использованием объекта в куске памяти (reinterpret_cast не начинает жизнь), явный вызов деструктора

  * Проблема: может не быть `T()`.  Например, у `Employee` (`Developer`, `SalesManager`), есть конструктор только от имени, возраста и т.п. Тогда `new T[10]` не сработает.

  * Надо сначала выделить кусок памяти, а потом руками вызывать конструкторы и деструкторы. После этого сделать placement new -- создание элемента с помощью оператора `new`, при этом память не будет выделяться, а будет браться по переданному указателю (см. в примере). Важно: обязательно делать placement new, без него объект не существует, вызов конструктора обязателен, просто сделать `reinterpret_cast` недостаточно (даже если это тривиальный тип --`int` и т.п.).

  * После окончания работы с объектом нужно обязательно вручную вызвать деструктор для всех объектов, созданных с помощью placement new (см. пример). После чего нужно удалить память, выделенную изначально под все объекты.

   ``` C++
    #include <memory> // Чтобы не было ошибки "no matching function to call to 'operator new(sizetype, void*&)`"
    struct Foo { Foo(int) {} };
    int main() {
        void *data = aligned_alloc(alignof(Foo), sizeof(Foo) * 3);  // Или malloc(sizeof(Foo) * 3)
                                                                    // или new char[sizeof(Foo) * 3]
        Foo *a = new (data) Foo(10);  // placement new
        Foo *b = new (static_cast<char*>(data) + sizeof(Foo)) Foo(20);
        Foo *c = new (static_cast<char*>(data) + sizeof(Foo) * 2) Foo(30);
        c->~Foo(); // Явный вызов деструктора.
        b->~Foo();
        a->~Foo();
        std::free(data);
    }
    ```

* Для большинства объектов хватает (по выравниванию) выделить память через `new char[]`

  * Выравнивание -- требование, по которому указатель на выделенную память делится на какое-то число. Чаще всего это нужно, чтобы соблюдать требования процессора и т.п., в общем техническое требование.

  * В большинстве случаев хватает хватает выделения памяти с помощью `new char[]`,там выравнивание равно `max_align_t == 8` либо `16`обычно (либо `malloc(...)`, но мы вроде как на плюсах прогаем).

* `aligned_alloc` и `free` для объектов с большим требованием на выравнивание

  * Бывают ситуации, когда выравнивание типа очень большое. В таких случаях используют `std::aligned_alloc(std::size_t aligment /* выравнивание */, std::size_t size /* размер памяти для выделения */)`. `aligment` можно получить с помощью оператора (не функция) `alignof(Foo)` (без `std::`).

  * Освобождение выделенной памяти осуществляется с помощью `std::free`.

* Трудности с обработкой исключений при управлении массивом объектов, `uninitialized_copy` и схожие функции.

  * Всё выше указанное классно работает, когда мы выделяем память под один объект. Когда их больше, начинаются трудности с обработкой исключений. С одним элементом можно легко поймать исключение, обработать его, т.к. тут либо `new char[]` не сработал (тут вообще ничего делать не надо, память не выделилась, объект не создался), либо конструктор выкинул исключение (объект не создался, но нужно вызвать `delete []` буффера, выделенного с помощью `new char[]`), либо остальные функции выкинули его (нужно вызвать деструктор и повторить шаги из предыдущего случая). Когда объектов много, то все случаи обработать трудно.

  * Обычно же нужно выделять массив под несколько элементов (когда пишем свой `vector`, например). Тогда эти объекты нужно в каком-то порядке создавать, или копировать массив объектов, тогда возникает куча проблем с тем что мы не имеем право использовать оператор присваивания. Нужно везде вызывать placement new, а если кто-нибудь выкинул исключение нужно все объекты удалить. А там могут быть или не быть требования к порядку удаления.

  * Можно это всё написать руками, а можно использовать такие функции как:

    * `std::uninitialized_default_construct(T* first, T* last)`, удаляет объекты в __неопределённом__ порядке. Устроена так: есть цикл, который  вызывает конструкторы по умолчанию. Если вылетает исключение, то он всё подчищает, все необходимые деструкторы вызывает и т.д.
    * `std::uninitialized_copy(T* first, T* last, T* out)`. Тоже вызывает деструкторы при выброшенном исключении. Устроена похожим образом, только вызываются  копирующие конструкторы, а не конструкторы по умолчанию.

* Вспомогательный  `stack_impl` для упрощения управления памятью с массивов объектов
  * Можно вместо встроенных функций `uninitialized_*` написать вспомогательный класс, поддерживающий количество созданных элементов и удаляющий всё необходимое в деструкторе. Как он примерно выглядит на примере лабы по вектору:

  ``` C++
  struct my_vector_holder final {
    std::size_t
      _cap,
      _len; // _len обновляем при добавлении нового элемента
    T *_data;
    my_vector_holder() noexcept; // просто обнуляем все поля
    my_vector_holder(std::size_t cap); // выделяем память в _data
    my_vector_holder(const my_vector_holder &) = delete;
    my_vector_holder & operator=(const my_vector_holder &) = delete;
    ~my_vector_holder(); // вызываем _len деструкторов и делаем delete [] _data
  };
  ```
## Билет 21
Автор: Венедиктов Роман
### Проблемы
1. Много копирований не по делу:
   ```c++
   struct Foo {  // Например, сотрудник.
       string a, b;  // Например, имя и фамилия.
       Foo(string /*const&*/_a, string _b) : a(_a), b(_b) {}
   };
   // ...
   string readString() {
       string result;
       cin >> result;
       return result;
   }
   // ...
   vector<Foo> v = ...;
   std::string a = readString();
   std::string b = readString();
   v.push_back(Foo(a, b)); // Переменные хочу, чтобы явно указать порядок.
   ```
   Копируем и в конструктор `Foo` (хотя там можно ссылку вставить), и в поле,
   а потом ещё и сам `Foo`.
2. `unique_ptr` нельзя копировать, но надо возвращать из функций.
   Надо "гарантированное" RVO или что-то похожее.
3. Возвращение вектора из функции, зачем-то копируем, хотя потом всё равно удалять

### Категории значений
* Ссылки
  * https://en.cppreference.com/w/cpp/language/value_category
  * https://habr.com/ru/post/441742/
* Чистые категории:
  * lvalue — у этого есть имя, нельзя разрушать.
    * Имя переменной: `var`
    * Обращения к полям: `a.m` (тут `a` — lvalue)
    * Обращение по указателю: `p->m` (тут `p` — что угодно)
    * То, что возвращает `T&`: `*p`, `a[i]` (если `a` lvalue для встроенных массивов), `getLval()` (если `int& getLval()`), `static_cast<int&>(x)`
    * Свойства:
      * Можно взять адрес
      * Можно написать "слева"
  * prvalue (как бы были раньше) — имени нет, сейчас помрёт, можно разрушить.
    * Литералы: `42`, `nullptr`
    * То, что возвращает по значению: `a + b`, `getVal()` (если `int getVal();`)
    * Обращения к полям: `a.m` (где `a` — prvalue)
    * `this` (именно сам указатель)
    * Лямбда
    * Свойства:
      * Не полиморфное, мы точно знаем тип.
  * xvalue — новая категория — имя есть, но можно разрушить.
    * То, что возвращает `T&&`: `static_cast<int&&>(x)`, `std::move(x)` (это просто `static_cast` внутри).
    * Обращения к полям: `a.m` (тут `a` — xvalue).
* Смешанные категории:
  * glvalue — то, у чего есть имя. lvalue или xvalue.
  * rvalue — то, из чего можно мувать. prvalue или xvalue.
* Тонкость: `return v;` из функции — в стандарте стоит костыль, чтобы тут вызывался
  move, а не copy, несмотря на то, что `v` — lvalue.

### Где происходит копирование/перемещение в зависимости от категории и куда пытаемся передать
Если объект — rvalue, то везде move
Если — lvalue, то везде копирование
(( Исключение — конструктор от `initializer_list` в виду реализации в языке 
(https://stackoverflow.com/questions/8193102/initializer-list-and-move-semantics) ))

### `std::move` для смены категории значения, реализация

Это все из коробки уже работает, но если мы знаем, что испольуем объект последний раз, то можем перевести его из lvalue в xvalue с помощью `std::move`

Реализация: 

```c++
template<typename _Tp>
constexpr typename std::remove_reference<_Tp>::type&& move(_Tp&& __t) noexcept{ 
	return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); 
}
```
### Где можно/нужно/нельзя ставить std::move, примеры, в том числе unique_ptr
Можно:
* В конструкторе муваем дальше в переменную
* Последний раз используем объект

Нельзя:
* Использум объект не в последний раз

Нужно:
* Для `unique_ptr` при передаче в функцию/конструктор/другую переменную
## Билет 22
Автор: Тарасов Денис

Я мог что-то упустить, так что осторожно!

* ### Правило нуля
  Если все поля нашего класса примитивные типы или типы, поддерживающие move-семантику (например вместо обычных указателей использовать `unique_ptr` из стандартной библиотеки, где у всего поддерживается move-семантика), то необходимости в каких-либо дополнительных действиях нет. Не нужно каким-либо специальным образом переопределять деструктор, конструктор копирования/перемещения, оператор присвоения копированием/оператор присваивания перемещением, их можно оставить стандартными, если только вы не хотите делать что-то специфическое.


* ### Ref-qualifier
  В сигнатуры методов можно добавлять следующие модификаторы:

  * `&` - позволяет вызывать метод только от lvalue объектов.

  * `&&` - позволяет вызывать метод только от rvalue объектов.

  Примеры:

  * Например у стека не имеет смысла вызывать метод `push` от rvalue объекта, который просто умрет после этого.
  ```C++
  struct Stack {
      ..
      void push(const T&) &;
  };
  Stack s;
  s.push(..); // Ок
  Stack().push(..); // CE, если нет перегрузки с &&
  ```

  * В `lab_15` у нас создавалась цепочка из временных объектов, другого использования методов класса `enumerator` не предполагалось.
  ```C++
  ..
  struct enumerator {
  public:
      auto drop(int count) && noexcept {
          return drop_enumerator<T>(*this, count);
        }
        ..
  };
  enumerator().drop(0); // Ок
  enumerator en;
  en.drop(); // CE, если нет перегрузки с &
  ```

  * Для вектора, например, можно сделать 3 перегрузки `operator[]`
  ```C++
  struct vector {
      const T& operator[](size_t) const; // T var1 = v[i];
      T& operator[](size_t) &; // v[i] = var2;
      T&& operator[](size_t) &&; // Объект умрет, поэтому можно соптимизировать
          // и сделать move из нужного элемента.
  };
  ```

* ### Типичная реализация конструктора с компировниями

  * Простой пример
  ```C++
  struct Person {
      Person(std::string name) : name_(std::move(name)) {
        ..
      }
      std::string name_;
    };
  ```
  Наш конструктор принимает копию какой-то строки, после выхода из функции эта копия исчезнет, и никем не будет использоваться, поэтому имеет смысл сделать move из нее, чтобы измбежать лишних копироваий. `std::move` здесь по делу, иначе произойдет копирование.

  * Подобные вещи могут происходить и в других методах класса (почему-то в интернете есть примеры лишь на констркуктор, но то же самое можно делать в set-методах, например).

* ### Rvalue-ссылки
  Пояснения что такое lvalue, rvalue и компания должны быть в билете 21. Обычные ссылки привязываются только к lvalue значениям, константные к чему угодно. В C++11 появляются rvalue-ссылки: `Foo &&x = foo();` (это лишь демонстрация синтаксиса, в данной ситуации код не имеет смысла, т.к. объект умрет и `x` сошлется в мертвый объект). Они привязываются только к rvalue (xvalue, prvalue). Важно не путаться с ***forwarding reference*** `template<typename T> void foo (T &&x) // "Forvanding referece"`, см. билет 23.

* ### Правила привязывания ссылок
  * `Foo &f = ..; // glvalue, CE для prvalue`
  * `const Foo &f = ..; // что угодно, попытается продлить жизнь у prvalue`
  * `Foo &&f = ..; // только rvalue`

  После привязки ссылки во всех случаях `f` станет lvalue! `&&` это лишь пометка того, что объект умрет. Все то же самое для аргументов функций. `Foo &&f = ..;`, как говорилось, не имеет особого смысла, оно имеет смысл для аргументов функций: `func(Foo &&f)`, здесь `f` будет жить и им можно пользоваться внутри `func`.

  `const Foo &&f` может привизаться только к `rvalue`, при этом из-за константности из нее нельзя сделать move, который мы обычно применяем к rvalue-ссылкам. Поэтому конструкция бесполезна, но есть какие-то специфические случаи, описаные [здесь](https://www.codesynthesis.com/~boris/blog/2012/07/24/const-rvalue-references/).

  * Пример Егора
```C++
  Foo f;
  Foo &x = f;
  Foo &&y = std::move(f);
  x // lvalue
  x.field // lvalue
  y // lvalue
  y.field // lvalue
  std::move(x).field  // xvalue
  std::move(y).field  // xvalue
  x.field + 10  // prvalue, если field был типа int (а то вдруг operator+ возвращает ссылку).
```

  * Небольшой пример использования rvalue-ссылки. Возможно, не очень удачный пример. Снова напомню про билет 23, т.к. с шаблонами все сложнее.
  ```C++
  struct Foo {
      ..
      void storeString(std::string &&val) {
          data_ = std::move(val);
      }
      std::string data_;
  };
  ```

* ### Move-конструктор, оператор перемещающего присваивания
  *  Move-конструктор и оператор перемещающего присваивания это просто новые перегрузки.
  ```C++
  struct Foo {
      ..
      Foo (Foo &&other) noexcept : data1_(std::move(other.data1_)),
       data2_(std::move(other.data2_)){
          ..
          /* Сделали что-то нужное для нового объекта и
             перевели other в какое-то новое состояние, если надо. */
      }
      // А еще можно было так
      Foo (Foo &&other) noexcept : data1_(std::move(other).data1_),
  data2_(std::move(other).data2_)) // поле xvalue тоже xvalue

      Foo & operator=(Foo &&other) noexcept {
          // Почистили себя, если надо
          ..
          data1_ = std::move(other.data1_);
          data2_ = std::move(other.data2_);
          // Поменяли состояние other
          ..
          return *this;
      }
      std::unique_ptr<T> data1_, data2_; //  Поля могут быть другими, это лишь пример
      ..
  };
  ```
  При вызове конструктора копирования `stack s(VAL);` вызовется более подходящий в зависимости от категории `VAL`, у move приоритет больше, т.к. он более специфичен, чем `Foo (const Foo &other)`, который можно вызвать от любого выражения.

  * Нам очень хочется иметь гарантию исключений, т.к. после move состояние объектов нам не известно и в случае ошибки скорее всего не получится что-либо гарантировать. Например, `std::vector` требует от move-конструктора `noexcept`. Более подробно можно посмотреть [здесь](https://xinhuang.github.io/posts/2013-12-31-when-to-use-noexcept-and-when-to-not.html).

* ### Правило пяти
  После появления move-семантики знакомое нам правило трех превратилось в правило пяти: к конструктору копирования, оператору присваивания и деструктору добавились конструктор перемещения и оператор присваивания перемещением.
## Билет 23
Автор: Валера Головин
### Оборачивание кода библиотечным
#### `std::reference_wrapper`
Поставим 3 задачи и найдем из решение
1. Ссылки в C++ не могут выступать в качестве типа элементов массива или контейнера STL:
2. Инициализация ссылки происходит при её объявлении. После объявления ссылки её невозможно привязать к другой переменной.
3. Многие алгоритмы в STL могут принимать функторы (функциональные объекты) в качестве своих аргументов. Передача аргументов алгоритму, в том числе и функторов, происходит по значению. Это затрудняет использование внутреннего состояния функторов. К примеру: как подсчитать количество операций сравнения в алгоритме `std::sort`?
#### Решение 3 задачи -- `std::ref` и `std::cref`
```cpp
template<typename T>
struct SortPredicate {
    // Счетчик
    uint64_t count = 0;
    
    bool operator()(T a, T b) {
        ++count; 
        return a < b;
    }
};

std::vector<int> v = {7,3,8,5,4,6,1,9,2};

// Создаем функтор-предикат, который считает "сравнения"
SortPredicate<int> p;

std::sort(v.begin(), v.end(), p); 
// sort копирует p и после завершения p.count = 0, хотя массив отсортировали

// Используем std::ref, чтобы передать функтор по ссылке, а не по значению
std::sort(v.begin(), v.end(), std::ref(p)); 
// Теперь p.count = 27
```
Но как они работают? Лучше всего будет взглянуть на их примерную реализацию.
`ref` `cref` принимают свой аргумент по ссылке или константной ссылке и создают экземпляр типа `reference_wrapper`
```cpp
template<typename T>
class reference_wrapper {
    T* data;
public:
    reference_wrapper(T& data) : data{ &data } {}
    
    operator T&() const { return *data; }
    
    reference_wrapper& operator=(const reference_wrapper<T>& other) {
        data = other.data;
        return *this;
    }
};
```
При копировании `reference_wrapper(value)` ссылка на `value` не меняется, а главное определены копирующий конструктор и оператор присвоения, а это значит, что объекты этого типа могут легко инициализироваться повторно в отличии от ссылок. И определен оператор приведения к ссылке и в нужный момент ведет себя, как обычная ссылка.
Итак, когда мы используем для передачи аргумента функции `ref` или `cref`, мы передаем не копию объекта, не ссылку на него, а экземпляр `reference_wrapper`, который внутри себя хранит указатель на передаваемый объект.
#### Решение 2 задачи
Мы можем сделать обертку `reference_wrapper`, которая будет ссылкой на тип, и она умеет все поставленные задачи. 
Пример задачи и ее решение.
Допустим есть список, который хранит `string`. Необходимо найти самую длинную строку.
```cpp
typedef std::reference_wrapper<std::string> string_ref;
    // Список, в котором очень много строк
    std::list<std::string> list; 

    // Временная переменная, а-ля "ссылка" на std::string
    std::reference_wrapper<std::string> t = list.front();
    
    // Очень простой цикл без синтаксиса указателей и итераторов
    for (std::string& i : list) {
        if (i.size() > t.get().size()) t = x; // Копирования не происходит! 
    }
    f.get() // ответ
```
Когда компилятор не может привести тип, приходится вызывать метод `get()`. Этот метод явно возвращает ссылку на “обернутый” объект.
#### Решение 1 задачи 
Если копирование элементов требует избыточных затрат ресурсов, или нужно, чтобы несколько контейнеров размещали одни и те же элементы - приходится использовать “умные” указатели. Но есть и другой вариант. Использование reference_wrapper. 
```cpp
// Исходный контейнер с элементами типа int
    std::list<int> l = {-4, -3, -2, -1, 0, 1, 2, 3, 4};
 
    // Контейнер, хранящий "ссылки" на элементы первого контейнера
    std::vector<std::reference_wrapper<int>> v(l.begin(), l.end());
    
    // Теперь если мы изменим значение в векторе, то они изменятся и в списке.
    v[0].get() = 124;
    std::cout << l.front(); // 124
```
### std::forward
#### Reference collapsing
Как известно, взятие ссылки на ссылку в С++ не допускается, но это иногда может происходить при реализации шаблонов: 
```cpp
template <typename T>
void foo(T t) {
  T& k = t;
}

// вызов функции
int n = 0;
foo<int&>(n);
```
При инстанцировании шаблона `T` установится равным `int&`. Какой же тип будет у переменной `k` внутри функции? Компилятор «увидит» `int& &` — а так как это запрещенная конструкция, компилятор просто преобразует это в обычную ссылку. 
```cpp
/*
 * T = int&;  T&  = int&
 * T = int&;  T&& = int&
 * T = int&&; T&  = int&
 * T = int&&; T&& = int&&
 */
```
#### Forwarding reference
Передавать всегда в `std::ref` не удобно. Хочется, чтобы функции сами понимали какое значение надо передавать дальше. 

То есть если в нас передали `lvalue`, то дальше хотим тоже передать `lvalue`. Передали `rvalue`, дальше хотим передать `rvalue`.
```cpp
template<typename T>
void foo (T &&x) // "Forvanding referece"

// Not a "Forvanding referece"
template<typename T>
void foo (vector<T> &&x)
void foo (int &&x)
```
Если в функцию передали `T` `&&x`, то это единственный случай с Forvanding referece.
Попробуем в `foo` передавать разные значения.
```cpp
template<typename T>
void foo (T &&x) // "Forvanding referece"
int v = 1;
const cv = 2;

foo(10);             // T = int,        x = int&&
foo(v);              // T = int&,       x = int&
foo(cv);             // T = const int&, x = const int&   
foo(std::move(v));   // T = int,        x = int&&
foo(std::move(cv));   // T = const int, x = const int&&
```

#### Perfect forwarding
Если в `foo` передать `rvalue` ссылку, то `x` будет `rvalue` ссылкой, а если `lvalue`, то и `x` будет `lvalue` ссылкой.
Если мы хотим передать такой же тип, как и принимали, то надо передать `static_cast<decltype(x)>(x)`, но это долго и для этого есть `std::forward<T>(x)` или просто `std::forward(x)`
```cpp
template<typename T>
std::forward(T &&x) { return static_cast<T&&>(x); }
```
Также можно сделать и для функций 
```cpp
template<typename Fn, typename Arg>
decltype(auto) wrap(Fn &&fn, Arg &&arg) {
    return std::forward<Fn>(fn)(std::forward<Arg>(arg));
}
```
### Сравнение двух методов
#### `ref/cref`
Мы копируем все элементы и тогда мы спокойно удалять, сразу после вызова, или мы используем `ref` и это наша забота, следить за ними.

#### Perfect forwarding
Все аргументы должны жить все время действия программы.

### declval(auto)
Разберемся сначала, как работает `auto`, затем `declval` и тогда все будет понятно (нет). 
#### auto
Итак, как же `auto` выводит тип? К сожалению, здесь нет простого правила на все случаи жизни, кроме, пожалуй, того, что `auto` при выводе типа в общем случае отбрасывает cv квалификаторы и ссылки. Ниже я перечислю самые важные моменты.
1. ```cpp
   auto val = some_expression;
   ```
   Если тип some_expression T* или const T*, то тип var также будет T* или const T* соответственно. Пока без сюрпризов. Дальше — интереснее. Пожалуй, самое важное с практической точки зрения правило заключается в том, что если тип some_expression — T, const T, T& или const T&, то типом var будет T. Это, впрочем, если задуматься, вполне логично, ведь в этом случае значение, возвращаемое some_expression копируется в var и можно смело писать вот так:
   ```cpp
   auto foo() {
       return boo();
   }
   ```
   Это не работает, если `boo` возвращает ссылку.
2. ```cpp
   auto& val = some_expression;
   ```
   В этом случае, ожидаемо, если тип `some_expression` — `T` или `const T`, компилироваться это не будет, так как `lvalue` ссылку нельзя инициализировать `rvalue`. Если тип `some_expression` — `T&`, то и `var` будет иметь тип `T&`. Здесь важным моментом является то, что если тип `some_expression` — `const T&`, то и тип `var` будет `const T&`. Все хорошо, но тогда мы не обрабатываем значения в такой реализации.
   ```cpp
   auto& foo() {
       return boo();
   }
   ```
3. ```cpp
   auto&& val = some_expression;
   ```
   В этом случае, ожидаемо, если тип `some_expression` — `T` или `const T`, компилироваться это не будет, так как `lvalue` ссылку нельзя инициализировать `rvalue`. Если тип `some_expression` — `T&`, то и `var` будет иметь тип `T&`. Здесь важным моментом является то, что если тип `some_expression` — `const T&`, то и тип `var` будет `const T&`. Все хорошо, но тогда мы не обрабатываем значения в такой реализации.
   ```cpp
   auto& foo() {
       return boo();
   }
   ```
Всегда при этом можно сделать 
```cpp
auto foo(int a) -> decltype(boo(a)) {
   return boo(a);
}
```
Но это может быть очень длинным.
#### decltype
Итак, следует различать два основных случая применения `decltype`.
1. `decltype(var)`, когда var — это объявленная переменная (например, в функции или как член класса). В этом случае `decltype(var)` будет иметь в точности тот тип, с которым объявлена переменная.
2. `decltype(expr)`, `expr` — выражение. В этом случае типом `decltype(expr)` будет тип, которое могло бы вернуть это выражение, с той оговоркой, что `decltype(expr)` будет иметь тип `T& (const T&)`, если `expr` возвращает `lvalue`, `T`, если `expr` возвращает rvalue типа `Т` (`const T`) и `T&&` (`const T&&`), если `expr` возвращает `xvalue` (rvalue reference).
```cpp
int i;
const int foo();
int&& foo1();

decltype(i);      // int
decltype(i + 1);  // int
decltype((i));    // int&
decltype(i = 4);  //int&
decltype(foo());  // int
decltype(foo1()); // int&&
```
#### decltype(auto)
При совмещении этих двух особенностей мы получаем правильный результат и выражение 
```cpp
decltype(auto) foo () {
    return boo(); // обязательно надо написать return
}
```
Это будет работать, даже если `boo() -> void`.
Не будет работать 
```cpp
decltype(auto) foo (int x) {
    return(x) // decltype( (x) ) = int& см пример 3 в разделе decltype(expr)
}
```
Мы не можем возвращаемое значение сохранить в переменную
```cpp
decltype(auto) foo (int x) {
    auto a = boo(); // type a = void?
    return a;
}
```

## Билет 24
Автор: Пётр Сурков

### STL

* Containers libary
* Iterators libary
* Algoritms libary

Этот билет — Containers libary. В следующих билетах есть подробнее про каждый из видов контейнеров в нём. 

А ещё тут спрашиваются отличия, например, stdio.h и cstdio. В C используем первый, в C++ — второй, он не загрязняет глобальное пространство имён, а кладёт всё в `std::`

### Containers libary
Хранит объекты и управляет их временем жизни.

Должен быть

* Деструктор
* Хотя бы некоторые из конструкторов (копирования, перемещения, создания с параметрами, в зависимости от вызываемых методов)
* Обычно должны быть операторы присванивания (копирования, перемещения)

Контейнеры инвариантны по типам: `vector<Base*>` и `vector<Derived*>` - независимые контейнеры. Скопировать второй в первый не получится.

#### Аллокатор

Памятью управляет аллокатор - шаблонный класс, умеющий выделять, удалять память, инициализировать и удалять объект. 

Обычно используется `std::allocator`, он вызывает `new/delete`, которые можно [перегружать](https://habr.com/ru/post/490640/).

Аллокатор - сложный объект. должен уметь выделять не только `T`. Например, в `list<>` нужно уметь выделять внутренний тип (структуру с `T` и указателями на следующий элемент).

К тому же, до C++11 аллокаторы не могли иметь глобального состояния.

Из-за этого есть специфичные требования к написанию собственных аллокаторов.

#### Сложность и гарантии исключения
Стандарт обещает какое-то время работы. Например, копирование `vector<T>` происходит за `O(n)` копирований `T`. 

Базовая гарантия есть всегда, про строгую каждой операции надо читать в стандарте. Но если move T кидает исключения, то многие строгие гарантии рушатся. 

#### Виды контейнеров

* Последовательные (хранят элементы в фиксированном пользователем порядке): `vector`, `deque`, `list`, `forward_list`.
* Ассоциативные (сортируют элементы по ключу): `map`, `set`, `multimap`, `multiset`.
* Неупорядоченные ассоциативные (хэшируют элементы по ключу): `unordered_*`.
* Адаптеры (надстраиваются над другими контейнерами): `queue`, `priority_queue`, `stack`.

#### Стандартные операции, есть всегда:

* Конструктор по умолчанию `O(1)`
* Конструктор перемещения `O(n)` (при копировании `T` за `O(1)`)
* `a.swap(b)`, `swap(a,b)` за константу для всех, кроме `std::array`
* `.empty()` (константа)
* `.size()` (константа, даже у списка)
* Конструктор копирования, если `CopyInsertable` (есть конструктор копирования у `T`):
* `==`/`!=`, если объекты можно сравнивать на `==`/`!=`:    
* Для обобщённого программирования:
    * `vector<T>::value_type`
    * `vector<T>::reference_type`
    * `vector<T>::const_reference`
    * `vector<T>::size_type`
    * `vector<T>::difference_type`

#### Некоторые из гарантий исключений
##### noexcept
* `erase` (если только не бросит исключение move/copy оператор/конструктор в `vector`/`deque`)/`clear`/`swap`
* `pop_back`/`pop_front` (если есть)

##### Строгая гарантия
* `insert`/`emplace` (если вставляет один элемент, а не много сразу; и то только если с нужного конца, см. `vector`/`deque`)
* `push_back`/`push_front`/`emplace_back`/`emplace_front` (если есть)


#### Range-based for
Синтаксический сахар:
```cpp
for (DECL : EXPR) BODY
```
для экзамена нам хватит следующего приближения (со слов Егора):
```cpp
{
    auto range = EXPR;
    auto begin = std::begin(range);
    auto end = std::end(range);
    for (auto it = begin; it != end; ++it) {
        DECL = *it;
        BODY
    }
}
```
На самом деле, разворачивается чуть сложнее. Можете почитать об этом [тут](https://stackoverflow.com/questions/8164567/how-to-make-my-custom-type-to-work-with-range-based-for-loops/31457319#31457319).

Функции `std::begin`/`std::end` вызывают внутренние `begin`/`end`, но перегружены для обычных массивов.

Есть тонкость. В `for (int &x : foo().bar()) { ... }` временное значение `foo()` не живёт, но `bar()` живёт. 

[Пример](https://cppinsights.io/) развёртки сахара.

Как видно из раскрытия, не стоит удалять/добавлять элементы в контейнер проходясь range-based for по нему.

В билете №28 можно прочитать про ranged-based ещё раз и найти информацию про связь с ADL, но в данном билете это не требуется.

#### Удаление, Инвалидация
Функция `.erase` возвращает итератор на элемент, который теперь занимает место первого удалённого элемента, либо `end()` при его отсутствии. 

Если идём по контейнеру, удаляя элементы по текущему итератору, то пишем `it=v.erase(it)`, вместо просто `v.erase(it)`. Иначе сделав `it++` на следующем шаге можем получить инвалидированный итератор, так как `it` указывал на уже удалённый элемент.

Про другие варианты инвалидации можно почитать в билете №28. 
## Билет 25
Автор: <Имя Фамилия>
## Билет 26
Автор: Саврасов Михаил

Этот билет содержит: 

* Ассоциативные контейнеры в STL
* Их свойства, требования к хранящимся классам
* Особенности map и unordered_map


>Тут спрашиваются отличия, например, stdio.h и cstdio. В C используем первый, в C++ — второй, он не загрязняет глобальное пространство имён, а кладёт всё в std::

>Автор: Сурков Пётр, билет 24

### `set`, `multiset`, `map`, `multimap`

Элементы хранятся в порядке `<`.

Все операции с элементами по умолчанию производятся за `O(log n)`.

При добавлении итераторы и ссылки никогда не инвалидируются.
При удалении инвалидируется ссылка и итератор на удаляемый элемент. (При вызове метода `extract()` инвалидируется только итератор).

Подробнее про инвалидацию итераторов и ссылок можно почитать [тут](https://stackoverflow.com/questions/6438086/iterator-invalidation-rules "stackoverflow").


Удаление по итератору работает амортизированно за `O(1)`.
Удаление по значению за `O(log n)`.

Для вставки можно использовать подсказки (метод `emplace_hint`). Если подсказка верна, то добавление работает амортизированно за `O(1)`.

#### Компараторы

По умолчанию `set` сравнивает на `less<T>(a, b)`.

```c++
template<typename T, typename Cmp = std::less<T>>
class set {
    Cmp cmp;
    set() : cmp() {}
    set(Cmp cmp_) : cmp(cmp_) {}
    ....
        if (cmp(node->key, key_to_find)) { .... } else { .... }
    ....
};
template<typename T>
class less {
     bool operator()(const T &a, const T &b) const/*!!!*/ {
        return a < b;  // Должен ли a быть строго раньше b?
    }
}
```

#### Функторы 

Можно использовать для сравнения свои функторы. У них должен быть определен `bool operator()` с определенной сигнатурой:

```c++
bool operator()(T a, T b) const;
``` 

Пример кода:

```c++
// объявление
struct CompareK {
    int k;
    CompareK(int k_) : k(k_) {}
    bool operator()(int a, int b) const {
        return a * k < b * k;
    }
};

// использование
set<int, CompareK> values(CompareK(-1));
values.insert(1);
values.insert(2);
// {2, 1}
```


#### Лямбды и функции

При их использовании всегда нужно явно указывать тип.

Например:

```c++
bool compare(int a, int b) { return a > b; }
....
set<int, bool(*)(int, int)> values(compare);
values.insert(2);
values.insert(1);
// {2, 1}
```

Или

```c++
bool compare(int a, int b) { return a > b; }
....
set<int, decltype(&compare)> values(compare);
values.insert(2);
values.insert(1);
// {2, 1}
```

И для лямбд:


```c++
auto compare = [](int a, int b) { return a > b; };
set<int, decltype(compare)> values(compare);
values.insert(2);
values.insert(1);
```


### `operator[]` для `map` и `multimap`

При обращении по несуществующему ключу, создается элемент с таким ключом и значением, созданным конструктором по умолчанию.

Например:

```c++
map<int, int> values{{1, 100}, {2, 200}};


assert(values[3] == 0); // Не упадет
``` 


Есть метод `at()`, который бросает исколючение в случае, если элемента с таким ключом нет.

### `unordered_set`, `unordered_multiset`, `unordered_map`, `unordered_multimap`

Элементы лежат в порядке, который зависит от хеш-функции. 
Все операции с элементами по умолчанию работают за `O(1)` амортизированно.


Из-за возможного rehashing, при добавлении элементов, могут испортиться все итераторы.

При удалении инвалидируется ссылка и итератор на удаляемый элемент. (При вызове метода `extract()` инвалидируется только итератор).

Подробнее про инвалидацию итераторов и ссылок можно почитать [тут](https://stackoverflow.com/questions/6438086/iterator-invalidation-rules "stackoverflow").

У них тоже есть `emplace_hint()`.

#### Свои хеш-функции

Объект должен уметь сравниваться на `==`

Хеш-функция должна возвращать `size_t`

Например:

```c++
struct point {
    int x = 0, y = 0;
    point() {}
    point(int x_, int y_) : x(x_), y(y_) {}
    bool operator==(const point &other) const {
        return x == other.x && y == other.y;
    }
};
struct PointHasher {
    size_t operator()(const point &p) const {
        return std::hash<int>()(p.x) * 239017 + std::hash<int>()(p.y);
    }
};
....
unordered_set<point, PointHasher/*, std::equal_to<point>*/> points;
points.emplace(10, 20);  // points.size() == 1
points.emplace(20, 10);  // points.size() == 2
points.emplace(10, 20);  // points.size() == 2
```

### `operator[]` для `map` и `multimap`

При обращении по несуществующему ключу, создается элемент с таким ключом и значением, созданным конструктором по умолчанию.

Например:

```c++
unordered_map<int, int> values{{1, 100}, {2, 200}};


assert(values[3] == 0); // Не упадет
``` 


Есть метод `at()`, который бросает исколючение в случае, если элемента с таким ключом нет.
## Билет 27
Автор: Кирилл Бриллиантов
### Адаптеры

Основное свойство - построены на основе других контейнеров.

#### stack и queue

Дек, у которог убрали половину методов

```cpp
template<typename T, typename Container = std::deque<T>>
struct stack {
    Container c;
    ... // методы связанные с итераторами
    void push(const T &value) { c.push_back(value); }
    void push(T &&value) { c.push_back(std::move(value)); }
    void pop() { c.pop_back(); }
    T& top() { return c.back(); }
    const T& top() const { return c.back(); }
};
template<typename T, typename Container = std::deque<T>>
struct queue {
    Container c;
    ....
    void push(const T &value) { c.push_front(value); }
    void push(T &&value) { c.push_front(std::move(value)); }
    void pop() { c.pop_front(); }
    T& front() { return c.front(); }
    const T& front() const { return c.front(); }
};
```
Следствием того, что они хранят контейнер является, то что инвалидация ссылок и итератров происходит тогда же, когда и у **Conatiner**. 

Вместо deque можно подставить что-то у чего есть соответсвующие методы.

#### priority_queue

Адаптор, представляющий собой двоичную кучу. Помимо контейнера использует компаратор и бибилиотечные функции связанные с кучей
```cpp
template<typename T, typename Container = std::vector<T>, typename Compare = std::less<T>>
struct priority_queue {
    Container c;
    ....
    const T& top() { return c[0]; }
    void push(const T &value) {
        c.push_back(value);
        std::push_heap(....);
    }
    void push(T &&value);
    void pop() {
        std::pop_heap(....);
        c.pop_back();
    }
};
```
- Итераторов нет. Можно получить доступ только к голове куче. 
- Методы что-то_heap можно вызывать самостоятельно. 
- Рабоатет быстрее, чем ```set<T>```

### bitset
Контейнер, хранящий последовательно ``` N ``` (известно на этапе компиляции) битов.
- конвертируется в строки для вывода на экран
- операции с индивижульными битами происходят медленее, чем в ```vector<char>```
- массовые же наоборот во много раз быстрее (Егор говорит в 10 раз)
- полезно для ускорения динамического программирования
```cpp
bitset<10> bs(   "0000010011");
bs.set(2);     // 0000010111
assert(bs.test(2));
assert(bs[2]);
bs.reset(2);   // 0000010011
bs.flip();     // 1111101100
assert(bs.count() == 7);
bs ^= bitset<10>("1100000001");
               // 0011101101
assert(bs.count() == 6);
```
## Билет 28
Автор: Саврасов Михаил

Этот билет содержит: 

* Итераторы (константные и неконстантные)
* Использование итераторов


>Тут спрашиваются отличия, например, stdio.h и cstdio. В C используем первый, в C++ — второй, он не загрязняет глобальное пространство имён, а кладёт всё в std::

>Автор: Сурков Пётр, билет 24


## Итераторы и операции с ними

У каждого контейнера также есть __итератор__ `vector<T>::iterator` (похож на `T*`) и `vector<T>::const_iterator` (похож на `const T*`).
Это некоторый небольшой объект, который умеет ходить по контейнеру (копируется и присваивается без исключений).
В общем случае это что угодно (например, у `map` надо обходить двоичное сбалансированное дерево).

* Итератор можно получить у любого контейнера:
  * Картинка с `begin`/`end`
  * `.begin()`/`.end()` — возвращает __итераторы__ на начало и элемент-после-конца `[begin; end)`. Типа указателей, но более общее.
  * `.cbegin()`/`.cend()` — аналогично, но итераторы константные (`const T*`).
* Итераторы можно разыменовывать:
  * `*i` и `i->foo()` у любого итератора: mutable/constant.
  * У mutable даже `*i = foo`.
* У любого контейнера есть специтератор, указывающий на элемент "после последнего".
  Его нельзя разыменовывать никогда и никак, это UB.
* Пара итераторов задаёт полуинтервал range.
  Если задали кривой, то UB.
* Все операции с итераторами работают за константу (амортизированно) или не работают вообще.


## Инвалидация итераторов

Инвалидация может произойти после каких-либо изменений контейнера. Например, при добавлении в `unordered_set`, может произойти rehash, в результате чего инвалидируются все итераторы.


## Иерархия итераторов
* Input/output iterator: можно сравнивать `==` и `!=`, можно `++r` и `r++`.
  При этом нельзя предполагать, что если `a == b`, то `++a == ++b`.
  Ещё есть алгоритмы `std::prev` и `std::next`.
  Считывать можно много раз, а вот записывать через `*r = foo` только один раз.
  Нельзя писать в input, нельзя читать из output.
  Пример: `istream_iterator`/`ostream_iterator`/`back_insert_iterator`/`front_insert_iterator`/`insert_iterator` для вставки в контейнер.
  Следствие: single pass algorithm.
* Forward iterator.
  Гарантируется, что итераторы ведут себя нормально: если `a == b`, то `++a == ++b`
  и если поменять копию итератора, то сам итератор не поменяется.
  Следствие: бывают multi pass algorithm.
* Bidirectional iterator. Добавили ещё и `--`.
* Random access iterator.
  Добавили `+=`, `+`, `-`, `<` и `>`, как в арифметике указателей.
  Вычитание даёт `difference_type`, но так можно только для связанных итераторов.

## Алгоритмы с итераторами

### Немодифицирующие
* `bool all_of(first, last, pred)` и друзья
* `Pred for_each(first, last, pred)`, `for_each_n` (только первые `n` элементов)
* `difference_type count(first, last, value)`, `count_if(...., pred)`
* `find(first, last, pred)`, `find_if`, `find_if_not`



### Сравнения
* `min`/`max`/`minmax` из двух значений или из фигурных скобок. Осторожно: возвращают ссылку:
  https://www.youtube.com/watch?v=s9vBk5CxFyY
  ```
  const Foo &x = foo();  // Работает.
  const Foo &x = std::min(foo1(), foo2());  // Не работает, потому что lifetime extension только с самым внешним значением.
  ```
* `clamp(value, lo, hi)` — обрезаем значение. Возвращает ссылку.
* `equal(f1, l1, f2[, pred])`, ещё есть лексикографическое `<`
* `std::pair<> mismatch(first1, last1, first2)`, первое место с отличием
* `min_element`, `max_element`, `minmax_element` — первый минимум/максимум. Возвращают итератор.
  Пример, когда вектор непустой: `vec.erase(min_element(vec.begin(), vec.end()));` 

Из numeric library:

* `accumulate(first, last, init = 0)` для `operator+`

### Модифицирующие
Осторожно с пересечениями входа и выхода!

* `copy(f, l, out)`/`move`{,`_backward`}
  Если куда-то копия, то конечный итератор не даём, он выводится.
  Этот и дальше стараются работать даже для `ForwardIt`, по этому поводу могут активно возвращать указатель на "конец".
* `fill(f, l, value)`, `fill_n(first, count, value)`
* `generate(f, l, g)`, `OutputIt generate_n(first, count, gen)`, есть частные случаи в Numerics library вроде 
* `OutIt transform(f, l, out, unary_op)` как map из Haskell
* `sort` (необязательно стабильный, гарантированный NlogN)/`stable_sort`/`nth_element`,
  есть частичные сортировки...

Из numeric library:

* `partial_sum`, `inclusive_scan`, `exclusive_scan`

### Сужающие
* `{remove}{,_copy}{,_if}`: `(first, last, [out], value|pred)`, возвращает итератор на конец.
* `{replace}{,_copy}{,_if}`: `(first, last, [out], old_value|pred, new_value)`, возвращает итератор на конец.
* `unique{,_copy}(f, l, [pred])`, удаляет __подряд идущие__ одинаковые.

Пример:
```
vector<int> v = { 1, 3, 2, 3 };
v.erase(remove_if(v.begin(), v.end(), [](int x) { return x % 2 == 0; }), v.end());
v.erase(unique(v.begin(), v.end()), v.end());
```

### Binary search
* `bool binary_search(f, l, [pred])`
* `pair<> equal_range(f, l, val, [pred])`
* `lower_bound` и `upper_bound` как крайние случаи.

### Прочие операции
* `swap(a, b)` для значений
* `swap_ranges(f1, l1, f2) --> l2`
* `iter_swap(a, b)` для обмена значений по итераторам
* `reverse{_,copy}` — угадайте, какие параметры?
* `rotate{_,copy}` (сделай элемент первым)
* `partition(f, l, pred) --> mid` за линию, есть модификации и проверка `is_partitioned`
* Merge отсортированных с дополнительной памятью и без
* Операции с отсортированными множествами в векторах: объединение, симметрическая разность, проверка принадлежности...
* Операции с кучей на массиве
* Операции с перестановками на массиве (проверить, получить следующую)

### Свои алгоритмы
#### `value_type`
* Хотим написать `min` по range:
  ```
  template<typename It>
  auto min_element(It first, It last) {
      auto found = *first;
      for (++first; first != last; ++last) {
          if (*first < found) {
              found = *first;
          }
      }
      return found
  }
  ```
* До C++11 нельзя было написать `auto`.
  Поэтому у итераторов и контейнеров есть `value_type`:
  ```
  typename It::value_type min_element(....) { .... }
  ```

#### Tag dispatching
* Хотим сделать свой `std::next`:
  ```
  template<typename It>
  It my_next(/*std::random_access_iterator_tag, */It x, typename It::difference_type count) {
      return x += count;
  }
  ```
* Тут работает только для RandomAccess. Для ForwardIterator:
  ```
  template<typename It>
  It my_next(/*std::forward_iterator_tag, */It x, typename It::difference_type count) {
      for (; count; --count)
          ++x;
      return x;
  }
  ```
* А теперь фокус (tag dispatching): есть специальный тип `It::iterator_category`.
  Там бывает `std::random_access_iterator_tag` (пустая структура), наследуется
  от `std::bidirectional_iterator_tag`, наследуется от `std::forward_iterator_tag`.
  Так можно надо на этапе компиляции поставить `if`.
  Можно добавить фиктивный параметр и сделать перегрузки,
  а общую реализацию такую:
  ```
  template<typename It>
  It my_next(It x, typename It::difference_type count) {
      return my_next(typename It::iterator_category(), x, count);
  }
  ```
* Это не сработает с `T*`, хотя они тоже указатели.
  Поэтому `std::iterator_traits<It>::iterator_category`.
  Костыль вроде `std::begin`/`std::end`


## Range-based for
* Бывает `std::begin`/`std::end` и range-based-for:
  * https://cppinsights.io/
  * `std::begin`/`std::end` вызывают внутренние `begin`/`end` и перегружены для обычных массивов.
  * Тонкость: в `for (int &x : foo().bar()) { ... }` временное значение `foo()` не живёт, а `bar()` живёт.
  * Range-based for — синтаксический сахар для https://en.cppreference.com/w/cpp/language/range-for :
    ```
    for (DECL : EXPR) BODY
    // ~~~~
    {
        auto range = EXPR;
        auto begin = std::begin(range);
        auto end = std::begin(end);
        for (auto it = begin; it != end; ++it) {
            DECL = *it;
            BODY
        }
    }
    ```
* Не стоит менять то, по чему итерируемся

## `reverse_interator`

Как обычный итератор, только двигающийся в обратную сторону. Могут все то же, что и обычные итераторы для этого контейнера. 

Можно получить с помощью функции `make_reverse_iterator()`. Обычный итератор можно получить, вызвав метод `base()`.

## Билет 29
Автор: <Имя Фамилия>
## Билет 30
Автор: Илья Онофрийчук

## Как передавать параметры в функции

#### По значению:
Практически всегда параметры передаются по значению, `&&` и умные указатели нужны редко. 
Например, рассмотрим функцию, которая не хочет портить ничего из того, что ей передали:
```cpp
void foo(vector<int> foo_data) { sort(foo_data.begin(), foo_data.end(); .. };
```
Удобно тем, что если мы в какой-то момент, захотим с оптимизировать и сказать, что данные, которые мы передаём в функцию, нам больше не нужны, то достаточно будет их просто замувать.
```cpp
int main() {
    vector<int> data = {1, 2, 3, 4, 5};
    foo(data);  // Тут скопируем, вектор ещё нужен.
    data.emplace_back(6);  // {1, 2, 3, 4, 5, 6}
    foo(std::move(data));  // Разрешили не копировать.
    data.clear();  // Вектор мог остаться непустым, не определено moved-from.
}
```

#### Параметры только для чтения, только для записи:
* Если нам вcегда передают объект, а мы его только читаем:
    ```cpp
    void printVector(const vector<int> &data);
    ```
* Если иногда не передают — std::optional (не указатель!):
    ```cpp
    void maybePrintVector(const std::optional<vector<int>> &data);
    ```
* Если нам всегда нужно передать наружу объект (не указатель!):
    ```cpp
    void readAndAppendToVector(vector<int> &data);
    ```
    Осторожно: а что, если data исходно непуст? Тогда неясно куда записываются данные или что происходит со старыми. Верните по значению или задокументируйте.

* Если пользователь не всегда хочет ответ — указатель.
    ```cpp
    void readAndMaybeAppendToVector(vector<int> *const data);
    ```

#### Rvalue-ссылки в параметрах:
* Не нужно, если объект умеет только `move` (например, `unique_ptr`). Следующие два случа компилируются абсолютно одинакого:
    ```cpp
    void foo(unique_ptr<Foo> &&x);
    ```
    ```cpp
    void foo(unique_ptr<Foo> x);
    ```
    ```cpp
    unique_ptr<Foo> bar;
    foo(bar);             // Не скомпилируется в обоих случаях.
    foo(get_bar());       // Скомпилируется в обоих случаях.
    foo(std::move(bar));  // Скомпилируется в обоих случаях.
    ```
* Если объект можно копировать, то обычно rvalue ссылки не нужны. Если же вы в данном случае из написали, то возможно вы нарушили ожидания у большинства C++ программистов.
    ```cpp
    void foo(Foo &&x);
    Foo bar;
    foo(bar);             // Не компилируется.
    foo(Foo(bar));        // Надо явно копировать, но так не принято.
    foo(std::move(bar));  // Явно мувать можно всегда.
    ```
* Иногда `&&` нужно для оптимизаций или move-конструкторов:
    ```cpp
    void push_back(const T&);
    void push_back(T&&);
    ```


#### По умным указателям:

Умный указатель — пара `(данные, владение)`. В параметрах — только если нам важно, как именно им владеет вызвавший. Обычно неважно.

* `const unique_ptr<T>&` — лучше заменить на `T&` (const явно исчез).
* `unique_ptr<T>&` — если пишем `swap` `unique_ptr`-ов, то нужно; в других случаях почти никогда не используется
* `const shared_ptr<T>&` — почти никогда
* `shared_ptr<T>&` — почти никогда

Примеры умных указателей в парметрах:

* Если надо явно передать функции владение объектом, который не хочется копировать/перемещать, который мы выделили на куче и завернули в `unique_ptr` и мы хотим передать владение, то стоит использовать `unique_ptr`:
    ```cpp
    void passToAnotherProcessAndForget(std::unique_ptr<SomeData> iOwnItNow);
    ```
* Пусть у нас есть оконный менеджер и в нём есть окошки. Окошко нельзя ни копировать, ни перемещать, поэтому мы создали его один раз и везде передаём на него `shared_ptr`-ы. 
    ```cpp
    // Функция хочет скопировать владение `window` куда-то ещё.
    void addToAnotherDesktop(shared_ptr<Window> window) {  // shared_ptr по значению.
        recentlyMovedWindows.emplace_back(window);
        myWindows.emplace_back(std::move(window));
    }
    ```
* Пусть у нас есть бинарное дерево и мы пишем конструктор для его нодов.
 
    Конструктор должен выглядеть следующим образом:
    ```cpp
    Node(Node left_, Node right_)
        : left(make_unique<Node>(std::move(left_))), .... {}
    ```
    Конструктор от `unique_ptr` появляется только с целью оптимизиции:
    ```cpp
    // Оптимизация: всегда оборачиваем в `unique_ptr`, давайте сразу его возьмём.
    Node(unique_ptr<Node> left_, unique_ptr<Node> right_)  // Без &&
    : left(std::move(left_)), right(std::move(right_)) {}
    ```
## Как возвращать значения

Практически всегда возвращать нужно по значению, это самый простой и безопасный способ.

Возврат по ссылке происходит реже, при этом важно следить за тем, что объект, на который возвращается ссылка должен жить и после выхода из функции. Обычно так возвращаются параметры функции, которые мы приняли по ссылке.

Возврат по умным указателям происходит ещё реже. 

Пример с `unique_ptr`: функция возвращает владение объектом:
```cpp
std::unique_ptr<SomeData> readFromAnotherProcess();
```


## Особенности умных указателей для массивов
Для массивов умные указатели следует использовать следующим образом:
```cpp
// квадратные скобки в параметре шаблона
std::unique_ptr<int[]> ptr(new int[10]); 
std::shared_ptr<int[]> ptr(new int[10]); 

std::make_unique<int[]>(10);
std::make_shared<int[]>(10);
```
Это нужно для того, чтобы удаление происходило правильно, с помощью верного `delete[]`. Пример UB:
```cpp
std::unique_ptr<int> ptr(new int[10])
```
В данном случае UB так как массив выделился с помощью `new[]`, а удаляться будет с помощью `delete`

Более хорошая идея -- использовать просто `std::vector`.
## `string_view`, `span`, когда использовать 
Пусть мы хотим написать функцию `print_line` и у нас есть два варианта, как принимать строку:
```cpp
void print_line(const char *);        // 1
void print_line(const std::string&);  // 2
```
Если мы используем первый вариант, то чтобы передать в `print_line` `std::string`, нужно воспользоваться методом `c_str()`. Если же мы используем второй вариант, то при вызове `print_line("123")` будет создаваться `std::string`, то есть будет происходить лишнее выделение на куче.

Решение проблемы: принимать `std::string_view`.

 `string_view` используется для ***невладеющего доступа*** к отрезкам строки.  
```cpp
struct string_view {  // C++17
    const char *data; size_t length;
    string_view substr(size_t pos = 0, size_t count = npos) const;
    ...
};
```
Многое методы из `string` есть и у `string_view`. Также есть возможность получить у `string_view` подстроку без каких-либо изменений памяти (просто создаётся новый `string_view`).

Начиная с C++20 появился `span`. Он аналогичен `string_view`, но работает с произвольными типами.
```cpp
template<typename T>
struct span {  // C++20
    const T *data; size_t length; 
    ...
}
```
Пример использования `spаn`: Если не понятно принимать в функцию константный вектор или `T*`, наверно стоит принимать `span`.

С помощью `string_view` пишется человеческий `split`, который работает без лишних копирований. 
```cpp
std::vector<std::string_view> split(std::string_view str, std::string_view sep);
```

Если нужно получить строчку и только на чтение стоит использовать `string_view`.

## `unique_ptr` для единоличного владения
`unique_ptr` обычно используется если у нас есть рекурсия в том, что надо хранить, или нужно передовать владение объектом, но владелец всегда один. Например, при хранении дерева:
```cpp
struct SearchTreeNode {
    std::unique_ptr<SearchTreeNode> left, right;
    int key; std::string value;
};
```
Ещё и деструктор писать не надо, так как при удалении родителя, автоматически вызовутся деструкторы `left` и `right`.

Если мы что-то выделяем на стеке, то `unique_ptr` обычно совершенно не нужен. 

`unique_ptr` занимает столько же места, сколько обычный указатель.

Можно указать свой функтор удаления (вроде `fclose`), но в случае файлов лучше полностью написать RAII-обёртку (вроде `istream`/`ostream`).

Также у `unique_ptr` существуют методы для совместимости с C:
* Можно узнать значение указателя. При этом владение всё ещё остаётся у `unique_ptr`, поэтому если в блоке ниже вызвать `delete` у `ptr2`, то произойдёт double free.
```cpp 
{
    std::unique_ptr<SomeData> ptr = ....;
    SomeData *ptr2 = ptr.get();
}  // unique_ptr сам вызовет delete
```
* Можно вытащить владение указателя. `unique_ptr` в данном случае перестаёт владеть объектом, поэтому нужно самостоятельно очистить память.
```cpp
{
    std::unique_ptr<SomeData> ptr = ....;
    SomeData *ptr2 = ptr.release();
}  // утечка
```
## Необходимость `make_unique`
`make_unique` нужен для того, чтобы не разделять момент создания объекта и передачи управления в умный указатель. 
```cpp
foo(unique_ptr<Foo>(new Foo), unique_ptr<Bar>(new Bar));
```
До C++17 компилятор мог сначала выполнить все new, а потом все конструкторы. Поэтому если компилятор сначала вызовет `new Foo`, затем `new Bar` и только потом начнёт оборачивать чистые указатели в `unique_ptr`, то если `new Bar` кинет исключение, произойдёт утечка (утекла память выделившаяся при вызове `new Foo`).

`make_unique` решает эту проблему:
```cpp
foo(make_unique<Foo>(), make_unique<Bar>());
```

## Билет 31
Автор: Александр Морозов

### `shared_ptr` и `weak_ptr` для кэша

* Хотим реализовать кеш текстур, есть игровой движок, какие-то текстурки подгружены, эти текстурки используют разные куски программы, пока текстурка кому-то нужна, она должна жить, как только она никому не нужна, она удаляется, идеальный пример для `shared_ptr`...
* [Код с практики](https://github.com/yeputons/hse-2019-cpp/blob/master/24-200409p/solutions/03-misc/01-cache.cpp)

### Особенности умных указателей для массивов

* Нужно использовать `unique_ptr<A[]>(arr)`, чтобы в деструкторе вызвался `delete[]`, а не `delete`. Впрочем, если можно, лучше использовать `make_unique<A[]>(size)` (почему - написано ниже).

### `shared_ptr` ковариантен. Он преобразуется, как обычные указатели (к базовому неявно, к наследникам явно).

---

### Простые переменные и поля

* Если вы всегда владеете объектом единолично — по значению, идеальный вариант:
  ```c++
  struct Dsu {
      vector<int> parent;
      Dsu(int n) : parent(n, -1) {}
  };
  ```
* Если надо иногда не хранить объект и нет рекурсии — `std::optional` (C++17, +1 байт, нет дополнительных выделений памяти):
  ```c++
  struct Config {
      optional<string> outputFileName;
  };
  ```

---
### Умные указатели: `unique_ptr`
* Если есть рекурсия или надо передавать владение объектом, но владелец всегда один — `std::unique_ptr`
  ```c++
  struct SearchTreeNode {
      std::unique_ptr<SearchTreeNode> left, right;
      int key; string value;
  };
  ```
* Если надо явно передать функции владение объектом, который не хочется копировать/перемещать
  ```c++
  void passToAnotherProcessAndForget(std::unique_ptr<SomeData> iOwnItNow);
  ```
* Если надо вернуть владение из функции:
  ```c++
  std::unique_ptr<SomeData> readFromAnotherProcess();
  ```

---
### Про `unique_ptr`
* Используется часто.
* Можно указать свой функтор удаления (вроде `fclose`), но лучше полностью написать RAII-обёртку (вроде `istream`/`ostream`).
* Можно узнать значение указателя для совместимости:
  ```c++
  {
      std::unique_ptr<SomeData> ptr = ....;
      SomeData *ptr2 = ptr.get();
  }  // delete;
  ```
* Можно вытащить владение указателя для совместимости:
  ```c++
  {
      std::unique_ptr<SomeData> ptr = ....;
      SomeData *ptr2 = ptr.release();
  }  // утечка
  ```

---
### Умные указатели: `shared_ptr`
* Владельцев несколько и никак не сделать одного:
  ```c++
  class Window1 {
      std::shared_ptr<SuperImportantData> data;
  };
  class Window2 {
      std::shared_ptr<SuperImportantData> data;
  };
  ```
* Выделит в куче счётчик активных ссылок.
  Удалит данные, когда тот упадёт до нуля.
* Сильно дороже `unique_ptr` из-за счётчика и многопоточности.
* Если создать второй `shared_ptr`, будет новый счётчик:
  ```c++
  {
      shared_ptr<Data> x = ....;
      shared_ptr<Data> y = x.get();
  }  // `x`, `y` вызовут `delete`
  ```

---
### Умные указатели: `weak_ptr`
* `shared_ptr` не работает с циклами:
  ```c++
  class SuperImportantData {
      std::vector<std::shared_ptr<SuperImportantData>> children;
      std::shared_ptr<SuperImportantData> parent;  // Упс, цикл.
  };
  ```
* Для разрыва циклов можно делать ссылки наверх через `std::weak_ptr`:
  ```c++
  class SuperImportantData {
      std::vector<std::shared_ptr<SuperImportantData>> children;
      std::weak_ptr<SuperImportantData> parent;
  };
  ```
* Чтобы использовать `weak_ptr`, надо его преобразовать в `shared_ptr`
  (потому что многопоточность).
* `weak_ptr` автоматически обнулится при удалении родителя.

`shared_ptr`/`weak_ptr` используется очень редко, обычно владелец один.

---
### Чистые указатели
* Совместимость с Си (лучше сразу обернуть в RAII или умный указатель).
* Ссылаемся на объект, который точно нас переживёт:
  ```
  struct SearchTreeNode {
      std::unique_ptr<SearchTreeNode> left, right;
      SearchTreeNode *parent;
      int key; string value;
  };
  ```
* Пишем свой умный указатель

---
### Создание умных указателей
Всегда используйте `make_unique`, не пишите `new`:
```c++
foo(unique_ptr<Foo>(new Foo), unique_ptr<Bar>(new Bar));
```
До C++17 компилятор мог сначала выполнить все `new`, а потом все конструкторы.
Это утечка, если один из `new` бросал.

Лучше так:
```c++
foo(make_unique<Foo>(), make_unique<Bar>());
```
.
### Наследование
```c++
unique_ptr<Derived> d = ....;
unique_ptr<Base> b = d;
```
---
### Передача параметров в функции
Смотри [GotW 91](https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/) (Guru of the Week, автор — Herb Sutter).

* Практически всегда по значению, `&&` и умные указатели не нужны:
    ```c++
    void foo(vector<int> foo_data) { sort(foo_data.begin(), foo_data.end(); .. };
    int main() {
        vector<int> data = {1, 2, 3, 4, 5};
        foo(data);  // Тут скопируем, вектор ещё нужен.
        data.emplace_back(6);  // {1, 2, 3, 4, 5, 6}
        foo(std::move(data));  // Разрешили не копировать.
        data.clear();  // Вектор мог остаться непустым, не определено moved-from.
    }
    ```

* Если хотим отдать что-то с именем (даже `&&`) — пишем `std::move`:
    ```c++
    template<typename T> struct MyVector {
        vector<T> data;
        MyVector(vector<T> data_) : data(std::move(data_)) { /* data_ = ?? */ }
        void push_back(T &&value) { data.emplace_back(std::move(value)); }
    };
    ```

---
### Параметры только для чтения/для записи
* Если нам вcегда передают объект, а мы его только читаем:
  ```c++
  void printVector(const vector<int> &data);
  ```

* Если иногда не передают — `std::optional` (не указатель!):
  ```c++
  void maybePrintVector(const std::optional<vector<int>> &data);
  ```

* Если нам всегда нужно передать наружу объект (не указатель!):
  ```c++
  void readAndAppendToVector(vector<int> &data);
  ```
  _Осторожно_: а что, если `data` исходно непуст? Верните по значению или задокументируйте.

* Если пользователь не всегда хочет ответ — указатель.
  <!-- Указатель здесь лучше ссылки только потому что в нём может быть `nullptr`. В указатель запишем ответ. Владеет им вызывающий. -->
  ```c++
  void readAndMaybeAppendToVector(vector<int> *const data);
  ```

---
### Rvalue-ссылки в параметрах
Не нужно, если объект умеет только `move` ([`unique_ptr`](https://stackoverflow.com/a/8114913/767632)):
```c++
void foo(unique_ptr<Foo> x /* unique_ptr<Foo> &&x */);
unique_ptr<Foo> bar;
foo(bar);             // Не скомпилируется в обоих случаях.
foo(get_bar());       // Скомпилируется в обоих случаях.
foo(std::move(bar));  // Скомпилируется в обоих случаях.
```
<!--
Это может быть чуть менее эффективно в общем случае: тут
мы вызываем лишний конструктор перемещения и деструктор.
Для `unique_ptr` всё равно.
-->

Обычно не нужно, если объект можно копировать:
```c+++
void foo(Foo &&x);
Foo bar;
foo(bar);             // Не компилируется.
foo(Foo(bar));        // Надо явно копировать, но так не принято.
foo(std::move(bar));  // Явно мувать можно всегда.
```

Иногда `&&` нужно для оптимизаций или move-конструкторов:

```c++
void push_back(const T&);
void push_back(T&&);
```

---
### Умные указатели в параметрах
Умный указатель — пара `(данные, владение)`.
В параметрах — только если нам важно, как именно им владеет __вызвавший__.
Обычно неважно.

* `const unique_ptr<T>&` — лучше заменить на `T&` (`const` явно исчез). <!-- константен только сам указатель; а вдруг у нас вообще объект на стеке? Тоже уникальный владелец -->
  * Это не семантика &laquo;у объекта один владелец&raquo; — стэк, поле...
* `unique_ptr<T>&` — почти никогда <!-- пример: swap, за деталями — в GotW -->
* `const shared_ptr<T>&` — почти никогда <!-- пример: когда иногда хотим себе скопировать, за деталями — в GotW  -->
* `shared_ptr<T>&` — почти никогда

```c++
// Функция хочет скопировать владение `window` куда-то ещё.
void addToAnotherDesktop(shared_ptr<Window> window) {  // shared_ptr по значению.
    recentlyMovedWindows.emplace_back(window);
    myWindows.emplace_back(std::move(window));
}
```
```c++
Node(Node left_, Node right_)
    : left(make_unique<Node>(std::move(left_))), .... {}
// Оптимизация: всегда оборачиваем в `unique_ptr`, давайте сразу его возьмём.
Node(unique_ptr<Node> left_, unique_ptr<Node> right_)  // Без &&
    : left(std::move(left_)), right(std::move(right_)) {}
```

###  Далее представлены переводы двух статей, которые упоминал Егор, они перескаются с лекциями, которые расположены выше.
### Краткий перевод [GotW 89](https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/)
#### Когда использовать `shared_ptr`, а когда `unique_ptr`?

Если сомневаетесь, используйте `unique_ptr`, его всегда можно будет сконвертировать через `move` в `shared_ptr`. Если сразу знаете, что нужно общее владение, используйте `shared_ptr`, создавая его с помощью `make_shared`. Есть три причины по умолчанию использовать `unique_ptr`:
* Во-первых, нужно использовать самую простую сущность, которая достаточна. Если `unique_ptr` позже станет недостаточно, его можно сконвертировать.
* Во-вторых, `unique_ptr` быстрее, чем `shared_ptr`, потому что не отслеживает информацию о числе ссылок и не хранит `control block` (описано [тут](https://en.cppreference.com/w/cpp/memory/shared_ptr))
* В-третьих, если изначально использовать `unique_ptr`, указатель можно будет сконвертировать в `shared_ptr`, а в обратную сторону - нет.

#### Почему всегда стоит использовать `make_shared`? 

Примечание: если вам нужно создать объект с пользовательским аллокатором, можно использовать `allocate_shared`.
Есть два случая, в которых не получится использовать `make_shared`: (a) нужен пользовательский `deleter`, например, когда данные лежат не в памяти, или лежат в нестандартной области памяти (`make_shared` не поддерживает пользовательский `deleter`); и (b) когда нужно создать `shared_ptr` из сырого указателя, переданного из другого (обычно наследственного) кода. 

Использовать же `make_shared` предпочтительно, потому что: 
* Во-первых, код с `make_shared` проще. При написании кода на первое место нужно ставить его ясность и корректность.
* Во-вторых, код с `make_shared` более эффективен. В случае `make_shared` данные объекта могут аллоцироваться вместе с `control block`, тогда как при написании `shared_ptr<Data>{new Data{}}` сначала аллоцируется `Data`, и только потом `shared_ptr` аллоцирует свой `control block`.


#### Почему всегда стоит использовать `make_unique`?

Случаи, когда `make_unique` не подходит, те же, что и для `make_shared`. Причины использовать `make_unique` тоже те же, но есть еще две:

* Нужно использовать `make_unique<T>()` вместо `unique_ptr<T>{new T{}}`, потому что нужно избегать явного использования `new`. 
* `foo(make_unique<T>(), make_unique<T>())` помогает избежать проблем с утечкой памяти в случае выброса исключения, которые возникают при использовании `foo(unique_ptr<T>{new T{}}, unique_ptr<T>{new T{}}`

### Краткий перевод [GotW 91](https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/).
#### Почему не стоит передавать `shared_ptr` в функцию по значению? 
	При передаче по значению нужно скопировать аргумент (обычно) и уничтожить его при выходе из функции (всегда). Это значит, что нужно производить увеличение и уменьшение числа ссылок на объект, на который указывает `shared_ptr`.
* Первая и главная проблема производительности здесь это то, что число ссылок это атомарная `shared` переменная, и ее увеличение и уменьшение это синхронизированные `read-modify-write` операции
* Вторая и менее значимая причина это то, что в каждый момент только одно ядро процессора может иметь доступ к кэш-линии переменной, отвечающей за число ссылок, а это может вызвать проблемы, если, например, несколько процессов в цикле постоянно изменяют число ссылок на некоторый объект (или даже на разные объекты, но в одной кэш-линии).

#### Каким способом лучше передавать `input-only` параметр в функцию?

* Лучше передавать объект по ссылке или указателю(**Егор говорит, что нужно использовать `optional`, а не указатель!**), если известно, что время жизни ссылки или указателя не меньше, чем время жизни аргумента. Как обычно, указатель нужно использовать, если параметр может быть пустым, а ссылку - если не может. Также нужно не забыть `const`. 
* Передача `unique_ptr` в функцию по значению означает, что владение объектом передается от вызывавшего вызываемому. 
* Передача `unique_ptr` по ссылке используется в случае, когда выполняются операции над самим `unique_ptr`, и функция потенциально может сделать так, что этот параметр будет указывать на другой объект после выхода из нее. 
* Передача `shared_ptr` по значению подразумевает взятие общего владения. Она имеет место, когда функция хочет сохранить копию `shared_ptr`, и в этом случае стоимости копирования не избежать. Если нужно передать `shared_ptr` дальше, можно просто использовать `std::move`.
* Передача `shared_ptr` по ссылке используется в случае, когда выполняются операции над самим `shared_ptr`, и функция потенциально может сделать так, что этот параметр будет указывать на другой объект после выхода из нее. В случае, если функция может захотеть сохранить копию `shared_ptr`, но не обязательно это сделает, можно передать `const shared_ptr&`, и скопировать его при надобности.

## Билет 32
Автор: <Имя Фамилия>
## Билет 33
Автор: Кирилл Карнаухов

### `std::tuple` и его друзья
У нас есть `std::pair<T, U>`, но работает только для двух параметров. Хотим больше. На помощь приходит `std::tuple<Args...>`, так называемый гетерогенный список (кортеж). Пример использования:
```cpp
std::tuple<int, vector<int>, string> t1(10, vector<int>(2), "foo");
auto t2 = std::make_tuple(10, vector<int>(2), "foo");  // t1 и t2 совпадают
int a = std::get<0>(t1);     // получить нулевой элемент
string c = std::get<2>(t1);  // Цикла по tuple<> нет
```

Теперь подробнее про функции, связанные с `std::tuple`:

* `std::get<index>(tuple)`. Получает элемент с номером `index` из `tuple`. Важно: `index` должен быть `constexpr` и находиться в полуинтервале `[0, std::tuple_size<tuple>::value)`.
* `std::tuple_size<tuple>::value` возращает размер кортежа.
* `std::tuple_element<size_t I, template Tuple>::type` возвращает тип `Tuple` на позиции `I`. Возможное применение:
```cpp
auto mytuple = std::make_tuple (10, 'a');
std::tuple_element<0, decltype(mytuple)>::type first = std::get<0>(mytuple);
std::tuple_element<1, decltype(mytuple)>::type second = std::get<1>(mytuple);
```
* `std::make_tuple(Args...)` создает `std::tuple` из переданных аргументов. Пример выше.
* `std::tuple_cat` объединяет два кортежа:
```cpp
auto tuple1 = std::make_tuple(10, 10.0, 'c');
auto tuple2 = std::tuple_cat(t, t); //получится (10, 10.0, 'c', 10, 10.0, 'c')
```
* `std::apply(Func, Tuple)` вызывает `Func` с аргументами, взятыми из `Tuple`.

Полезный факт: есть каст из `std::pair<T, U>` в `std::tuple<T, U>`.
    
### Ссылки внутри `std::tuple`
Внутри можно хранить ссылки, пример:
```cpp
int a = 10; string b = "foo";
std::tuple<int&, string&> t(a, b);
t = std::make_tuple(20, "bar"); 
assert(a == 20);
assert(b == "bar");
```

### `std::tie` 
Пусть есть функция, которая возвращает `std::tuple<>` (или `std::pair<>`, так как есть каст), и мы хотим сопоставить каждому элементу из кортежа свою переменную. С C++11 можно делать так:
```cpp
std::tuple<int, int, char> func() { return { 1, 2, 'a' }; }
//здесь какой-то код

int first;
int second;
char third;

std::tie(first, second, third) = func();
assert(first == 1);
assert(second == 2);
assert(third == 'a');
```
Примечание: `std::tie` появился в C++11, но возможно реализовать уже с C++03.

### Structured binding (базовое)
Это более современная замена `std::tie`. Синтаксис:
```cpp
std::tuple<int, int, std::string> tuple(10, 15, "hello");
auto [first, second, third] = tuple; //происходит копирование
assert(first == 10);
assert(second == 15);
assert(third == "hello");
```
Можно навешивать `const/&/static`.

Полезные факты:

* Есть direct initialization (`auto [a, b, c](tuple)`) и list initialization(`auto [a, b, c]{tuple}`).
* Нельзя указать типы отдельных элементов.
* Нельзя вкладывать друг в друга (т.е. нельзя `[[a, b], c]`).
* Происходит на этапе компиляции, поэтому массивы можно (дальше будет подробнее), а вектора — нет.
* Может разворачивать простые структуры.

### Structured binding (применение)
* Получить результат `insert`:
```cpp
map<int, string> m = ...;
if (auto [it, inserted] = m.emplace(10, "foo"); inserted) {
	cout << "Inserted, value is " << it->second << '\n';
} else {
    cout << "Already exists, value is " << it->second << '\n';
}
```
* Итерирование по `map`:
```cpp
for (const auto &[key, value] : m) {
	cout << key << ": " << value << '\n';
}
```

### Structured binding (как работает и раскрывается)
Пусть есть выражение:
```cpp
map<int, string> m = { ... };
//здесь какой-то код
auto [key, value] = *m.begin();
```
Тогда произойдет следующее:

* Создается невидимая переменная:
```cpp
auto e = *m.begin();
using E = pair<const int, string>;
``` 
* Проверяется, что количество аргументов совпадает:
```cpp
static_assert(std::tuple_size_v<E> == 2);
```
* Объявляются новые переменные:
```cpp
std::tuple_element_t<0, E> &key   = get<0>(e);  // Или e.get<0>()
std::tuple_element_t<1, E> &value = get<1>(e);  // Или e.get<1>()
```

Важная особенность состоит в том, что возвращаемое значение не должно быть обязательно `std::tuple`. Можно туда сунуть все, что умеет делать `std::get<>` и `std::tuple_size<>` (метод или функция), которое можно найти с помощью `ADL`. 

### Structured binding (массивы, кортежи и структуры)
Есть три формы привязки:

* Массив фиксированного размера:
```cpp
Foo arr[3];
auto [a, b, c] = arr;
// превращается в
auto e[3] = { arr[0], arr[1], arr[2] };
Foo &a = e[0], &b = e[1], &c = e[2];
```

* Кортежоподобная структура (умеет `std::get<>` и `std::tuple_size<>`). Тогда будет включен `ADL` (упоминалось выше).
* Простые структуры данных:
```cpp
struct Point {
	int x, y;
}; // Привяжется.

struct Good { int a, b; }
struct GoodDerived : Good {};

struct BadPrivate { int a; private: int b; }  // Не привяжется: приватные запрещены.
struct BadDerived : Good { int c; }  // Не привяжется: все поля должны быть в одном классе.
```

### Structured binding (дополнительно)
В зависимости от `auto`/`auto&`/`const auto&` и инициализатора у нас получаются немного разные типы:

* `auto&` попробует привязать ссылку.
* `const auto&` продлит жизнь временному объекту.
* `auto` всегда скопирует объект целиком, а не просто его кусочки.

Если внутри объекта лежали ссылки, то может сломаться время жизни:
```cpp
namespace std {
    std::pair<const T&, const T&> minmax(const T&, const T&);
}
auto [min, max] = minmax(10, 20);  // Только копирование значений?
// перешло в
const pair<const int&, const int&> e = {10, 20};
// Сам `e` — не временный, поэтому продления жизни нет.
// e.first и e.second ссылаются на уже умершие 10 и 20.
const int &min = e.first;   // Oops.
const int &max = e.second;  // Oops.
```

Рекомендация: осторожно с функциями, которые возвращают ссылки.
С ними лучше `std::tie`.
## Билет 34
Автор: Александр Морозов

## Специализации шаблонов
### Синтаксис для `stack<bool>`
```
template<typename T> struct stack { ... }; // Общий случай
template<>
struct stack<bool> { // Для конкретных параметров.
    // Абсолютно независимая реализация.
};
```

### Частичная специализация
```
template<typename T> struct unique_ptr {
    T *data;
    ~unique_ptr() { delete data; }
};
template<typename T> struct unique_ptr<T[]> {
    T *data;
    ~unique_ptr() { delete[] data; }
};
```

Работает pattern matching.
Можно зачем-нибудь специализировать как `template<typename A, typename B> struct unique_ptr<map<A, B>> { ... }`.

### Немного type traits
Так можно делать вычисления над типами и значениями на этапе компиляции:
```
template<typename T> struct is_reference { constexpr static bool value = false; };
template<typename T> struct is_reference<T&> { constexpr static bool value = true; };
template<typename T> struct is_reference<T&&> { constexpr static bool value = true; };
//
printf("%d\n", is_reference<int&>::value);
```

Это один из способов реализовывать `<type_traits>` (второй будет в 4 модуле, называется SFINAE).

Ещё пример:
```
template<typename U, typename V> struct is_same { constexpr static bool value = false; };
template<typename T> struct is_same<T, T> { constexpr static bool value = true; };
```

А ещё это можно использовать в своих библиотеках.
Например, для сериализации: вы пишете общий случай `template<typename T> struct serializer {};`,
а дальше для каждого типа реализуете `struct serializer { static std::string serialize(const T&); static T deserialize(std::string); }`

## Специализация функций
Для функций есть только полная специализация:
```
template<> void swap(Foo &a, Foo &b) { ... }
```
Частичной нет.
Вместо неё предполагается использовать перегрузки, если очень надо:
```
template<typename T> void swap(vector<T> &a, vector<T> &b) { ... }
```
По техническим причинам это не всегда хорошо, правда, но таков факт жизни.

## Прокси-объекты
### Для `vector<bool>` 
Если мы делаем битовую упаковку в `vector<bool>`, то мы больше не можем вернуть `bool&`.

Но надо вернуть что-то такое, чтобы `a[i] = false;` работало.
В C++03 и раньше хорошей идеей были прокси-объекты:

```
template<>
struct vector<bool> {
private:
    struct vector_bool_proxy {
        vector_bool_proxy operator=(bool value) {
            // Установка бита.
        }
        operator bool() {
            return // Чтение бита.
        }
        // А ещё надо operator</operator== для bool по-хорошему, брр...
    };
public:
    vector_bool_proxy operator[](std::size_t i) { return vector_bool_proxy(....); }
    bool operator[](std::size_t i) const { return ....; }
};
```

### Проблемы
[Ссылка с таймкодом](https://youtu.be/YJ2TKViIkSU?t=4460)

Написали `auto x = v[10];`, а потом захотели написать `auto y = x`, вызвалось присваивание прокси-объектов, а хотелось присваивание булов. Можно добавить костыль в виде rvalue-ref-qualifier'а в оператор присваивания, но проблемы останутся. 

#### auto&&
Если были forwarding-ссылки: можно использовать хитрость и писать `auto&&` (называется universal reference или forwarding reference, и является ссылкой, если передать lvalue, или значением, если передать rvalue). 

Если сделать `for (auto i : v)`, то из-за того, что `i` - прокси, изменение `i` повлечет изменение элемента `v`. В `vector<int>` не повлечет. Если же написать `for (auto&& i : v)`, то изменяться содержимое вектора будет вне зависимости от того, лежит внутри `bool` или `int`.

То есть, если мы хотим сохранить ссылку на элемент вектора с произвольным типом, то можно написать `auto&& elem = v[0]`, и это будет работать в том числе для `vector<bool>`.
Кроме того, можно написать `vector<T>::reference_type elem = v[0]`.



## Tag dispatching
* Хотим сделать свой `std::next`:
  ```
  template<typename It>
  It my_next(/*std::random_access_iterator_tag, */It x, typename It::difference_type count) {
      return x += count;
  }
  ```
* Тут работает только для RandomAccess. Для ForwardIterator:
  ```
  template<typename It>
  It my_next(/*std::forward_iterator_tag, */It x, typename It::difference_type count) {
      for (; count; --count)
          ++x;
      return x;
  }
  ```
* А теперь фокус (tag dispatching): есть специальный тип `It::iterator_category`.
  Там бывает `std::random_access_iterator_tag` (пустая структура), наследуется
  от `std::bidirectional_iterator_tag`, наследуется от `std::forward_iterator_tag`.
  Так можно надо на этапе компиляции поставить `if`.
  Можно добавить фиктивный параметр и сделать перегрузки,
  а общую реализацию такую:
  ```
  template<typename It>
  It my_next(It x, typename It::difference_type count) {
      return my_next(typename It::iterator_category(), x, count);
  }
  ```
* Это не сработает с `T*`, хотя они тоже указатели.
  Поэтому можно использовать `std::iterator_traits<It>::iterator_category` вместо `typename It::iterator_category()`.
	Также есть `std::begin(arr)`, `std::end(arr)`, которые умеют получать начало и конец как у стандартного контейнера, так и у массива. 

## Билет 35
Автор: Петя Сурков

### Мотивация метапрограммирования

#### Обобщения
* `std::distance` должен работать для разных итераторов по-разному:
    * Для random access iterator: `last - first`
    * Для остальных: `while (first != last) ++first;`
* `vector<T>::resize` может вести себя по-разному:
    * Если есть nothrow move constructor, то можно сразу перемещать элементы из буфера в буфер
    * Если нет, то надо всегда копировать, чтобы была strong exception safety.
* `std::any`/`std::function` — хотим small object optimization (если объект маленький, то выделим его на стеке, а не в куче). Т.е. поведение объекта зависит от типа, который скормили конструктору.

#### Компилятор делает рутину за нас
##### Пример 1:
```c++
int dijkstra(const Graph &g, int start, int end);
int floyd(const Graph &g, int start, int end);
int random_shuffle(const Graph &g, int start, int end);
// Хотим, чтобы можно было писать так:
check_answer_same(dijkstra, floyd, random_shuffle)(some_graph, 0, n - 1);
```
##### Пример 2:
Хотим сделать Serialize, аргументы которого представляют собой названия параметров и откуда их брать.
```c++
using PersonSerializer =
    Serialize<"name", &Person::getName, // &Person::getName - указатель на функцию
              "age", &Person::getAge>;
PersonSerializer s(std::cin); 
s << getPerson();  // name=Ivan, age=23
```
##### Пример 3:
Пишем калькулятор, хотим добавлять в него функции.
```c++
CalculatorFunctions functions = {
    {"sin", std::sin},
    {"func", [](double a, double b, double c) { return a + b * c; }}
};
```
##### Пример 4:
DFS в compile time (dependency injection): есть куча классов с конструкторами, надо собрать объект.

### Constexpr-вычисления

* Можно использовать многие конструкции языка: нельзя `goto` и не-`constexpr` функции.
* Можно использовать скалярные типы и типы с `constexpr`-конструктором и тривиальным деструктором (пояснение ниже).
* С C++14 можно менять переменные внутри функций!
* До C++20 нельзя выделять память => нельзя `vector`

Пример: напишем функцию для вычисления факториала на этапе компиляции.
```c++
constexpr int factorial(int n) {
    int res = 1;
    for (int i = 1; i <= n; i++)
        res *= i; // Менять переменные можно с C++14
    return res;
}
static_assert(factorial(5) == 120); // работает!
std::array<int, factorial(5)> arr; // тоже работает: std::array надо знать размер на этапе компиляции, а factorial(5) вычислима на этапе компиляции
```

В `constexpr-`функции мы могли бы создать, например,  `optional<T>`, где `T` - какой-нибудь тривиальный тип, допустим `int`. Потому что у `optional<int>` есть `constexpr`-конструктор, тривиальный деструктор.

А начиная с 20 плюсов, могли бы создавать и вектора в `constexpr` функциях.
### "Функции" из типов в типы
Ещё с C++98 бывают функции из типов в типы:
```c++
template<typename T>
struct iterator_traits {  // Общий случай
    using value_type = typename T::value_type;
    using difference_type = typename T::difference_type;
};
template<typename T>
struct iterator_traits<T*> {  // Частный случай
    using value_type = T;
    using difference_type = std::ssize_t;
};
```

Можно несколько входов, можно несколько выходов, можно
простые типы в качестве параметров шаблона.

Вызов:
```c++
typename iterator_traits<Iterator>::value_type x = *it;
```
Важно указать `typename`, иначе компилятор не поймёт смысл `<`, распарсит как знак меньше.

### "Функция" из типов в один тип
Если такая "функция" возвращает ровно один тип, есть конвенция:
```c++
template<typename T> struct remove_const {
    using type = T;
};
template<typename T> struct remove_const<const T> {
    using type = T;
};
```
В C++11 появились псевдонимы шаблонов (alias template), конвенция:
```c++
// В библиотеке делаем псевдоним с суффиксом _t
template<typename T> using remove_const_t = typename remove_const<T>::type;
// В коде
remove_const_t<const int> x = 10;
```
Получаем вызов функции, только `<>` вместо `()`, и в качестве параметров — и значения, и типы.

### "Функция" из типов в число
Напишем функцию, вычисляющую кол-во размерностей переданного массива
```c++
template<typename T> struct rank { // общий случай
    static constexpr size_t value = 0;
};
template<typename T> struct rank<T[]> { // передали массив, мы не знаем его размер
    static constexpr size_t value = rank<T>::value + 1;
};
template<typename T, size_t N> struct rank<T[N]> { // передали массив, мы знаем его размер
    static constexpr size_t value = rank<T>::value + 1;
};
static_assert(rank<int[][10]>::value == 2);
```
Раньше, такое [писали](https://stackoverflow.com/a/205000/767632) так `struct rank { enum { value = 10 }; }` из-за багов компилятора. Сейчас так не надо.

Заметим, что `constexpr`-функции тут не хватит. Она не сможет заглянуть внутрь типа.

С C++17 есть конвенция создавать template variable:
```c++
// В библиотеке делаем псевдоним с суффиксом _v
template<typename T> constexpr size_t rank_v = rank<T>::value;
// Тогда в коде сможем писать чуть короче
static_assert(rank_v<int[][10]> == 2);
```

Снова получаем вызов функции с `<>` вместо `()`.

### Стандартные вспомогательные классы
```c++
template<typename T> struct rank
    : std::integral_constant<size_t, 0> {}; // разобрали общий случай
template<typename T> constexpr size_t rank_v = rank<T>::value; // завели вспомогательный using
template<typename T> struct rank<T[]>
    : std::integral_constant<size_t, rank_v<T> + 1> {}; // частный случай
template<typename T, size_t N> struct rank<T[N]>
    : std::integral_constant<size_t, rank_v<T> + 1> {}; // частный случай
static_assert(rank<int[][10]>::value == 2);
```
Обычно пишут через них, так короче.

В библиотеке реализованы примерно так:
```c++
template<typename T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    constexpr operator T() const noexcept { return v; }
    ....
};
template<bool v>
struct bool_constant : integral_constant<bool, v> {};
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;
```

### Тонкости с числами в параметрах
Бывают ограничения. В специализации нельзя фиксировать значение, не фиксируя тип значения:
```c++
template<typename T, T N> struct fac { .... };
template<typename T>      struct fac<T, 0> { .... };  // Нельзя( Ну вдруг 0 не типа T на самом деле
```

Но их можно обходить, если специализировать и тип тоже, в этом поможет `integral_constant`:
```c++
template<typename /*N*/> struct fac {};  // Базовый случай, вызовется только если не integral_constant
// Не будет value, поэтому если нам дадут какую-то фигню а не число, то, скорее всего, будет ошибка компиляции
// это хорошо
template<typename T, T N> constexpr auto fac_v =
    fac<std::integral_constant<T, N>>::value;
template<typename T, T N> struct fac<std::integral_constant<T, N>>
    : std::integral_constant<T, N * fac_v<T, N - 1>> {};
template<typename T>      struct fac<std::integral_constant<T, 0>>
    : std::integral_constant<T, 1> {};
static_assert(fac_v<int, 5> == 120);
```
Если передать отрицательный `N`, то компилятор зациклится и на глубине примерно 1000 выдаст ошибку компиляции.
Так как это дело "открывали", могут быть ещё сюрпризы...

### Простые type traits
Классы или структуры, которые только таскают информацию в типах, называются "типажи" (traits).

Есть встроенные в язык "кирпичики" из `type_traits`, которые можно сделать самому:

* `is_same<A, B>` совпадают ли типы? 
* `is_convertible<From, To>` — можно ли сконвертировать `From` в `To` неявно? Это позволит узнать, например, будет ли компилиться `To foo() { return From{}; }`
* `is_nothrow_convertible<T, U>` — то, что выше, но и `noexcept`? Важно: просто смотрит на пометку `noexcept`, никак не смотрит на реализацию.
* `is_constructible<T, A, B>` — есть ли конструктор `T` из `A` и `B`?

### Пример алгоритма на типах на type traits
```c++
template<typename T> struct is_reference { constexpr static bool value = false; };
template<typename T> struct is_reference<T&> { constexpr static bool value = true; };
template<typename T> struct is_reference<T&&> { constexpr static bool value = true; };
```

### Ещё пример. Для сериализации
Пишем общий случай `template<typename T> struct serializer {};`, а дальше для каждого типа реализуем 
```c++
struct serializer {
    static std::string serialize(const T&);
    static T deserialize(std::string);
}
```
### Сложные type traits
Некоторые принципиально требуют поддержки компилятора:

```c++
// Цитата из libc++ Егора: вызываем кусок компилятора  __is_polymorphic
template<typename _Tp> struct is_polymorphic
  : public integral_constant<bool, __is_polymorphic(_Tp)> { };
```

Какие-то можно писать самому, но лучше не надо:
```c++
template<typename> struct is_integral       : false_type {};
template<>         struct is_integral<int>  : true_type {};
template<>         struct is_integral<char> : true_type {};
// И так далее; зависит от компилятора и библиотеки.
```

Некоторые есть в библиотеках (например, `boost::function_traits`. Позволяет узнать кол-во аргументов, их типы, тип возвращаемого значения). 

Для функций одного аргумента легко реализовать самим:
```c++
template<typename> struct function_traits {};
template<typename Ret, typename Arg0>  // Можно написать обобщённо для N аргументов.
struct function_traits<Ret(*)(Arg0)> {
    static constexpr std::size_t arity = 1;
    using return_value = Ret;
    using arg_0 = Arg0;
};
```

### Расширяемые type traits
Некоторые traits предполагаются для расширения пользователем.

Пример: `iterator_traits`. Это такое хранилище свойств (как и любой traits) итераторов. Например,  чтобы мы могли одинаковым кодом спросить `value_type` и у итератора на вектор, и у указателя на массив. По умолчанию берёт `typename` изнутри типа, но можно сделать что-нибудь своё для своего итератора:
```c++
namespace std {
    template<typename T> struct iterator_traits<MyMagicIterator<T>> {
        using value_type = typename MyMagicIterator<T>::magic_value_type;
        // ....
    };
}
```
в примере выше мы захотели, чтобы у нашего итератора в качестве `value_type` брался не просто `value_type` нашего итератора, а его `magic_value_type`.

Ещё пример: `char_traits` задаёт логику работы с "символами", [пример с SO](https://stackoverflow.com/a/5319855/767632):

```c++
  struct CaseInsensitiveTraits : std::char_traits<char> {
      static bool lt(char a, char b) { return tolower(a) < tolower(b); } 
      static bool eq(char a, char b) { return tolower(a) == tolower(b); }
      static int compare (const char *a, const char *b, size_t length) {
          ....
      }
  };
  using CaseInsensitiveString = std::basic_string<char, CaseInsensitiveTraits>;
```

* Получили строчки `CaseInsensitiveString`, которые сравнивается без учёта регистра.
* И заодно дают UB на не-латинице из-за `tolower`.
* Говорят, что из-за своих `char_traits` получается неудобный ужас :(
## Билет 36
Автор: Петя Сурков

Если вам попался этот билет на экзамене, сначала прочтите конец прошлого билета, начиная с type traits. Это нужно для понимания этого билета и это скорее всего спросят в доп вопросах.

То, что будет под следующим заголовком, не согласуется с определением type traits из предыдущего билета. Егор подтвердил, что тут есть путаница в названиях. В следующей строчке правильнее опустить слово "type", но я пока что оставил для соответвия названий билетам.

### Свои расширяемые type traits
Допустим, написали такую библиотеку
```c++
template<typename T> struct serialization_traits { // базовый случай, зовём serialize и deserialize у самого объекта
    static void serialize(ostream &os, const T &x) {      x.serialize(os); }
    static T deserialize(ostream &is)              { T x; x.deserialize(is); return x; }
};
template<> struct serialization_traits<int> { // специализировали для int
    static void serialize(ostream &os, int x) { os.write(...); }
    static int deserialize(istream &is)       { int x; is.read(...); return x; }
};
// А тут идут разные полезные функции, работающие через serialization_traits, к примеру
template<typename T>
void saveToFile(string fileName, T data) {
    ofstream os(fileName, std::ios::binary);
    serialization_traits<T>::serialize(os, std::move(data));
}
```

Тогда в пользовательском коде можем обернуть даже "не свой" тип, про который библиотека ничего не знает:
```c++
template<typename T>
struct serialization_traits<vector<T>> {
    static void serialize(ostream &os, const vector<T> &data) {
        serialization_traits<size_t>::serialize(os, data.size());
        for (const auto &item : data)
            serialization_traits<T>::serialize(os, item);
    }
    
    // тут аналогично deserialize, если захотим использовать "полезные функции" в библиотеке, которые его юзают.
    
};
saveToFile("foo.txt", std::vector<int>{1, 2, 3, 4}); // Работает!
```

Таким образом, позволили пользователям нашей библиотеки расширять её. Зачем нужно? Нам меньше писать (не надо поддерживать все типы, которые захочет использовать пользователь), а пользователь библиотеки может легко добавить поддержку своих типов.

### Оператор `noexcept`
Про типы всё можем узнавать, теперь давайте что-нибудь узнаем про выражения и функции.

Оператор `noexcept` позволяет узнать, может ли из выражения теоретически вылететь исключение (просто смотрит на спецификаторы `noexcept`!). Возвращает `true`/`false` _на этапе компиляции_, **не** вычисляя выражение.


```c++
int foo() noexcept { return 1; }
int bar()          { return 2; }
// ....
int a = 10;
vector<int> b;
static_assert(noexcept(a == 10));
static_assert(!noexcept(new int{}));   // Утечки не будет: не вычисляется.
static_assert(noexcept(a == foo()));
static_assert(!noexcept(a == bar()));  // bar() НЕ noexcept
static_assert(!noexcept(b == b));      // vector::operator== не noexcept по историческим причинам
bool x = noexcept(a = 10);
assert(x);
```

### Спецификатор `noexcept`
У _спецификатора_ (не оператора) `noexcept` есть две формы:

```c++
template<typename T> struct optional {
    optional() noexcept;  // Не кидает никогда. Если же кинула, то terminate
    optional(optional &&other) noexcept(  // noexcept только при условии...
        std::is_nothrow_move_constructible_v<T>
    );
    // В данном случае - если у T move конструктор не бросает исключений.
};
```

А что если у нас нет type_traits на нужное условие? Давайте посмотрим, как бы мы могли реализовать сами то, что выше, но без `std::is_nothrow_move_constructible_v<T>`. 

Воспользуемся оператором `noexcept` внутри спецификатора:

```c++
template<typename T> struct optional {
    optional() noexcept;
    optional(optional &&other) noexcept(noexcept(T(std::move(other))));
}
```
Пояснение:
```c++
template<typename T> struct optional {
    optional() noexcept;
    optional(optional &&other) noexcept(    // noexcept только при условии... (тут noexcept - спецификатор)
       noexcept(  // ...что следующее выражение noexcept...  (тут noexcept - оператор)
           T(std::move(other))  // вызов move-конструктора T
       )
   );
}
```

### Применение `noexcept`
Полезно для `vector` со строгой гарантией исключений.

Если у элементов вектора `is_nothrow_move_constructible`, то можно перевыделять буфер без копирований:

```c++
void increase_buffer() {
    vector_holder new_data = allocate(2 * capacity);  // Может быть исключение.
    for (size_t i = 0; i < len; i++)
        new (new_data + i) T(std::move(data[i]));     // Портим data, боимся исключений.
    data.swap(new_data);                              // Исключений точно нет.
}
```

Иначе просто копируем.

Подобная ситуация встречается часто, поэтому есть уже готовая функция `std::move_if_noexcept`, тогда специализировать не надо:

```c++
void increase_buffer() {
    vector_holder new_data = allocate(2 * capacity);
    for (size_t i = 0; i < len; i++)
        new (new_data + i) T(std::move_if_noexcept(data[i]));
    data.swap(new_data);
}
```

`std::move_if_noexcept` проверяет, кидает ли исключения `T` при move (просто смотрит на noexcept, не более!), если не кидает, то возвращает rvalue (как обычный `move`), иначе lvalue.

### Функция `declval<>`
Внутри `noexcept` иногда не хватает переменных:
```c++
template<typename T>
constexpr bool is_nothrow_move_assignable_v = noexcept(
    /* переменная типа T */ = std::move(/*что-нибудь типа T???*/)
);
```
При этом конструкторов у `T` может вообще не быть:
```c++
template<typename T>
constexpr bool is_nothrow_move_assignable_v = noexcept(
    /* переменная типа T */ = T{} /* rvalue, но не всегда скомпилируется */
);
```

Для решения этой проблемы есть `std::declval<T>()`. Она создаёт значение любого типа, даже если у `T` нет конструкторов:
```c++
template<typename T>
static constexpr is_nothrow_move_assignable_v = noexcept(
    std::declval<T&>() = std::declval<T/*&&*/>()
);
```

Это легально только внутри _невычислимых контекстов_.

`int x = std::declval<int>();  // Ошибка компиляции`

### Оператор `sizeof`
Ещё невычислимый контекст: оператор `sizeof`

* Можно вызвать от типа:
  ```c++
  static_assert(sizeof(char) == 1);
  ```
* Можно вызывать от выражения, оно не будет вычислено:
  ```c++
  char& foo();
  static_assert(sizeof(foo()) == 1);
  static_assert(sizeof(&foo()) == sizeof(char*));
  ```

Самый первый оператор такого вида, единственный в C++03,
из-за этого часто применяется в костылях.

### Оператор `decltype`
Есть с C++11: `decltype(expr)` — это некоторый тип.

Если в скобках имя сущности, то её тип из объявления:
```c++
int a = 10; int &b = a;
struct { int& field; } c{a};
decltype(a) x = a;              // int x = a;
decltype(b) y = b;              // int& y = b;
decltype(s.field) z = c.field;  // int& z = c.field;
```

Если в скобках стоит выражение, то 
1) Берём чистый тип выражения: с константностью, но без ссылок.
2) Смотрим на категорию и добавляем соответствующую ссылку.

Поясняющий пример:
```c++
Foo func1();
Foo& func2();
Foo&& func3();
Foo a;
// ....
decltype(func1()) x = func1();  // prvalue, Foo x = func1();
decltype(func2()) y = func2();  // lvalue,  Foo &y = func2();
decltype(func3()) z = func3();  // xvalue,  Foo &&z = func3();
decltype(std::move(a))  v2 = std::move(a);  // xvalue,  Foo &&v2 = std::move(a);
decltype(Foo{})         v3 = Foo{};         // prvalue, Foo v3 = Foo{};
```
В билете просят пример, когда `declval`, может использоваться в `decltype`. Например, если нужно узнать тип не `static` функции класса: `decltype(std::declval<T>().foo)`
### Тонкости оператора `decltype`
Дополнительные скобки делают из имени выражение, а по правилам `decltype` для выражений:

```c++
Foo a;
const Foo &b = a;
decltype( a ) v1 = a; //  a  — имя.               Foo v1 = a;
decltype((a)) v2 = a; // (a) — выражение. lvalue, Foo &v2 = a;
decltype( b ) v3 = b; //  b  — имя.               const Foo &v3 = b;
decltype((b)) v4 = b; // (b) — выражение. lvalue, const Foo &v4 = b;
```

Сильно отличается от `auto`: второй снимает ссылки и константность.
```c++
auto x = a;  // Foo v1 = a;
auto y = b;  // Foo v3 = b;
```

 `decltype` используется:

* Когда нужно отличать типы друг от друга (до С++11 использовались костыли с `sizeof`)

* Для _очень_ правильного вывода типов параметров и
  возвращаемого значения функций:
    ```c++
    decltype(auto) v1 = a;    // Foo v1 = a;
    decltype(auto) v2 = (a);  // Foo &v2 = a;
    decltype(auto) v3 = b;    // const Foo &v3 = b;
    decltype(auto) v4 = (b);  // const Foo &v4 = b;
    ```

### `if constexpr`
* Хотим сделать метод `void printAll(const T &value)` для `int` и `vector<T>`, но без перегрузок.
* Разберём случай `int`: сделаем `if(is_same_v<T, int>)`. Не сработает, потому что компилируется то обе ветки. Поэтому для `int` мы всё равно будем пытаться скомпилить функции в `else`, т.е. пробовать вызвать `operator[]` и тд. 
* До C++17 приходилось писать шаблонный класс, специализировать, вызывать.
* В C++17 можно писать `if constexpr`. И даже работает автовывод возвращаемого `auto` типа функции.
* Даже внутри `if constexpr (false)` всё равно должен быть корректный синтаксис.

### `static_assert`
* Проверяет условие на этапе компиляции. Если не удалось — ошибка компиляции.
* Если мы хотим сделать `static_assert(false)` внутри `if constexpr`, то будет ошибка
  компиляции всегда.
  * Причины технические. Надо обмануть компилятор.
  * Надо дать ему выражение, которое как-то теоретически может зависеть от `T`, делаем 
  ```cpp
  template<typename> struct AlwaysFalse : std::false_type{};
  ```
  и уже `static_assert(AlwaysFalse<T>::value)`

### `std::conditional`
* Для выражений у нас есть тернарный оператор `cond ? t : f`, для `constexpr` тоже работает.
* Для типов такого нет. Надо писать свой if: `std::conditional<cond, T, F>`.
  * `typename std::conditional<true, T, F>::type` — это `T`.
  * `typename std::conditional<false, T, F>::type` — это `F`.
* Помогает объявлять поля.
 
Реализация (спрашивают в билете)
```c++
template<bool B, typename T, typename F>
struct conditional { typedef T type; };
 
template<typename T, typename F>
struct conditional<false, T, F> { typedef F type; };
```
## Билет 37
Автор: Глеб Марьин

### std::addressof

`operator&` можно перегрузить, чтобы точно взять адрес объкта нужно взять `std::addressof`

```C++
struct S { int operator&() const { return 7; } };
void some_c_api(const void*);
template<typename T>
void CallSomeCApi(const T &value) {
    some_c_api(static_cast<const void*>(&value));
}
// ....
S s;
CallSomeCApi(10);  // Компилируется.
CallSomeCApi(s);   // Почему ошибка компиляции внутри CallSomeCApi?
```

К счастью, там был static_cast, иначе бы оно передало число 7 как значение указателя.

Решение:

```C++
// Так в обобщённом коде правильно.
some_c_api(static_cast<const void*>(std::addressof(value)));
```

Упрощённая реализация:

```C++
template<typename T> T* addressof(T& value) {
    return reinterpret_cast<T*>(&reinterpret_cast<const char&>(value));
}
```

Вроде все, вот [ссылка на cppreference](https://en.cppreference.com/w/cpp/memory/addressof)


### Тип "функция"

Да, функции тоже имеют типы.

```C++
void func1();
void func2(int x);
void func3(int y);
int func4(int x, char y);
// ....
TD<decltype(func1)>{}; // Ошибка компиляции: TD<void()> is incomplete
TD<decltype(func2)>{}; // Ошибка компиляции: TD<void(int)> is incomplete
TD<decltype(func3)>{}; // Ошибка компиляции: TD<void(int)> is incomplete
TD<decltype(func4)>{}; // Ошибка компиляции: TD<int(int, char)> is incomplete
```

Особенности

- Объявить переменную такого типа нельзя.
- В метапрограммировании обычно применяется для упрощения синтаксиса: `function<void(int)>`.
- Неявно приводится к указателю на функцию.

### Тип "указатель на функцию"

Просто указатель на функцию, что сказать.
Добавили между типом и аргументами (*), получили void(*)(int).

```C++
char foo(int);
// ....
auto x = [](int val) -> char { return val; };
auto y = [&](int val) -> char { return val; };
char (*func1)(int) = &foo;  // Ок.
char (*func2)(int) = foo;   // Ок, функция неявно преобразуется в указатель на себя.
char (*func3)(int) = x;     // Ок: лямбда без захвата — почти свободная функция.
char (*func4)(int) = y;     // Не ок: лямбда с захватом должна знать своё состояние.
```

А ещё функции и данные могут вообще в совсем разной памяти лежать:

```C++
void *x = static_cast<void*>(&foo);  // Ошибка компиляции.
```

*Но Linux пофиг: там какие-то функции возвращают void\* вместо указателей на функции.*

Между собой указатели на функции несовместимы:

```C++
void (*func5)() = func4; // из примера выше
```

Вообще дальше вам скорее всего не нужно, но может быть в качестве
классного примера использования.

Можно написать `function_traits` для простых функций, для лямбд это не работает,
потому что они не матчатся под тип функций.

```C++
std::string f1(char c, int u) { return "Hello"; }
int f2(long long) { return 0; }
template <typename R, typename... Args>
struct function_traits {};
template <typename R, typename... Args>
struct function_traits<R(Args...)> { // вот тут матчим функцию
    using return_type = R;
    using argument_types = std::tuple<Args...>;
    static constexpr std::size_t arity = sizeof...(Args);
    template <std::size_t i>
    using arg = std::tuple_element_t<i, argument_types>;
};

template <typename T> struct TD {};

int main() {
    std::cout << function_traits<decltype(f1)>::arity << std::endl; // 2
    std::cout << function_traits<decltype(f2)>::arity << std::endl; // 1
    // TD<function_traits<decltype(f1)>::arg<0>>::me_please;           // char
    // TD<function_traits<decltype(f1)>::arg<1>>::me_please;           // int
}

```

С лямбдами сложнее, вот пример, но он точно не нужен: [stackoverflow](https://stackoverflow.com/questions/7943525/is-it-possible-to-figure-out-the-parameter-type-and-return-type-of-a-lambda).

### Как взять указатель на перегруженную функцию и static_cast

Если у функции более одной перегрузки, то возникают пробелемы.

```C++
void foo(int x);
char foo(char x);
// ....
TD<decltype(&foo)>{};  // Ошибка компиляции: какую перегрузку выбрать decltype?
```

Вывод: у &foo нет типа (примерно как у {1, 2, 3}).

```C++
void (*func1)(int)  = &foo;  // Если в точности указать тип, то перегрузка разрешится.
char (*func2)(char) = &foo;
```

Вызывает проблемы в шаблонных функциях или с auto:

```C++
template<typename Fn> void bar(Fn fn) { fn(10); }
// ....
bar(&foo);  // no matching function for call to 'bar(<unresolved overloaded function>)'
bar(static_cast<void(*)(int)>(&foo));  // Ок, потому что указатели на разные функции разных типов не кастуются.
bar([](int x) { return foo(x); });     // Ок, у лямбды фиксированный параметр.
```

### Указатель на поле класса

Нам когда-то в интрузивном списке нужно было узнавать o том, на сколько
байт определенный член класса выпирает относительно начала структуры,
тогда мы использовали `offsetof`, в плюсах есть типобезопасный и более
красивый способ это делать. На самом деле не очень красивый.

```C++
struct S { int x = 1, y = 2; };
S s;
S *sptr = &s;
int (S::*a) = &S::x;  // Можно даже без скобок слева.
int (S::*b) = &S::y;  // А вот &(S::y) уже нельзя.
assert(s.*a == 1);
assert(sptr->*a == 1);

a = b;  // Теперь `a` "указывает" на поле `y`.
assert(s.*a == 2);
assert(sptr->*a == 2);

// Но вообще рекомендуют typedef или using:
using IntMemberOfS = int S::*;
IntMemberOfS c = &S::x;

// С наследниками тоже работает.
struct S2 : S { int z = 3; };
S2 s2;
assert(s2.*a == 2);  // Можно пользоваться указателем из родителя.
int (S2::*d) = a;  // Можно неявно преобразовать типы.
assert(s2.*d == 2);
IntMemberOfS e = static_cast<IntMemberOfS>(d);  // Можно явно.
```

### Указатель на метод класса

Синтаксис аналогичный:

```C++
struct S {
    int field = 100;
    int foo1(int x) { return x + 10 + field; }
    int foo2(int x) { return x + 20 + field; }
    int bar1(int x) const { return x + 30 + field; }
    int bar2(int x) const { return x + 40 + field; }
};
S s;
int (S::*a)(int) = &S::foo1;
assert((s.*a)(9) == 119);  // Сначала скобки вокруг .*!
a = &S::foo2;
assert((s.*a)(8) == 128);
```

Важно сохранить const-qualifier:

```C++
int (S::*b)(int) const = &S::bar1;  
assert((s.*b)(7) == 137);
b = &S::bar2;
assert((s.*b)(6) == 146);
```

Есть все стандартные проблемы с выбором перегрузки.

Можно добиться этой проблемы например так:

```C++
struct S {
    int foo1(char x) { return x + 15; }
    int foo1(int x) { return x + 15; }
};

int main() {
    S s;
    // auto b = &S::foo1; error: unable to deduce ‘auto’ from ‘& S::foo1’
    int (S::*a)(int) = &S::foo1;  // OK
    int (S::*b)(char) = &S::foo1; // OK
}
```
## Билет 38
Автор: Кирилл Карнаухов

### SFINAE (начало)
Расшифровка: Substitution Failure Is Not An Error.

Означает, что если при подстановке типовых параметров в функцию/специализацию/конструктор что-то не удалось вывести через `::`, то просто забиваем на конкретную перегрузку функции/специализацию/конструктор и пробуем дальше.

Мотивация: хочется, чтобы работали всякие `is_move_constructible` — они смотрят только на объявление, не определение.

Пример:
```cpp
template<typename T>
void duplicate_element(T &container, typename T::iterator iter) {
    container.insert(iter, *iter);
}

template<typename T>
void duplicate_element(T *array, T *element) {
   assert(array != element);
   *(element - 1) = *element;
}

int main() {
    std::vector a{1, 2, 3};
    duplicate_element(a, a.begin() + 1);
    int b[] = {1, 2, 3};
    duplicate_element(b, b + 1);  // Нет ошибки, когда пробуем первую перегрузку: не бывает int[]::iterator, но это не ошибка компиляции. SFINAE.
}
```

Отличается от hard compilation error тем, что если произошла ошибка при подстановке, то это ошибки компиляции не будет (будет только тогда, когда ни одна специализация/перегрузка не подошла). 

Важна следующая тонкость: SFINAE работае только на один уровень. То есть, если сделать свою структуру, а внутри `using`, то он должен быть нормальным. Пример:
```cpp
struct BotvaHolder {
    using botva = int;
};

//****рабочая версия****
template<typename T> using GetBotva = typename T::botva;

template<typename T>
void foo(T, GetBotva<T>) {  // Просто псевдоним, так можно, проблемы возникают как бы "тут".
    std::cout << "1\n";
}
//****конец рабочей версии****
//****нерабочая версия****
template<typename T>
struct GetBotva {
    using type = typename T::botva;  // hard compilation error.
};

template<typename T>
void foo(T, typename GetBotva<T>::type) {  // Ошибка компиляции, потому что проблема возникла уже внутри GetBotva.
    std::cout << "1\n";
}
//****конец нерабочей версии****

template<typename T>
void foo(T, std::nullptr_t) {
    std::cout << "2\n";
}

int main() {
    foo(BotvaHolder(), 10);  // 1
    foo(BotvaHolder(), nullptr);  // 2
    // foo(10, 10);  // CE
    foo(10, nullptr); // 2
}
```

### SFINAE (`auto` + `decltype`)
Первый способ вырезать перегрузку (и т.д.). Пример:
```cpp
template<typename T>
auto add(const T &a, const T &b) -> decltype(a + b) {
    return a + b;
}

auto add(...) { 
    return 239;
}

int main() {
    std::cout << add(10, 20) << "\n";
    std::cout << add(nullptr, nullptr) << "\n";
}
```
Пояснения. Если `a` и `b` можно сложить, то `a + b` корректно определено, то есть можно выполнить `decltype(a + b)` и получить правильный тип. Тогда эта перегрузка не будет вырезана. А так как аргумент `...` имеет приоритет ниже, то будет использована именно первая перегрузка. Таким образом, если два объекта можно сложить, то это произойдет.

Иначе эта перегрузка будет вырезана по SFINAE, так как произошла ошибка подстановки. В таком случае будет вызвана вторая функция, так как осталась только она.

Если хотим проверить, можно ли сложить два числа, то можно сделать так:
```cpp
template<typename T>
auto isAddable(const T &a, const T &b) -> decltype(a + b, true) {
    return true;
}

auto isAddable(...) { 
    return false;
}
```
Если `operator,` не перегружен для `T`, то это сработает следующим образом. Выполнится выражение `a + b` и проверится, что это возможно. И если это было успешно, то возвращаемое значение будет `decltype(true) = bool`, так как `operator,` возвращает то, что справа. Иначе будет вызвана вторая перегрузка.

Заключение. Метод хороший, если хочется проверить лишь корректность выражения. Не работает для конструкторов, потому что нет возвращаемого значения.

### SFINAE (Фиктивный шаблонный параметр-тип, `decltype` и `nullptr`)
Второй способ. Пример:
```cpp
struct Foo {
    template<typename T, typename = decltype(std::declval<T>().foo())>
    Foo(T) {
        std::cout << "1\n";
    }

    template<typename T>
    explicit Foo(T) {
        std::cout << "2\n";
    }
};

struct Bar {
    void foo() {}
};

int main() {
    Foo f1 = Bar();  // 1, потому что 2 недоступно из-за explicit
    Foo f2(10);      // 2, потому что 1 недоступно из-за SFINAE
}
```
Пояснение. Пытаемся подставить `int`. Но возникает проблема, что у `int` нет `.foo()`, поэтому по SFINAE конструктор вырезается.

К сожалению, для `Bar` оба конструктора одинаково подходят, поэтому, как вариант, необходим `explicit`. 

Также можно изменить `typename` на конкретный тип. Например:
```cpp
struct Foo {
    template<typename T, std::void_t<decltype(std::declval<T>().foo())>* = nullptr>
    Foo(T) {
        std::cout << "1\n";
    }

    template<typename T>
    explicit Foo(T) {
        std::cout << "2\n";
    }
};
```
*Насколько я понял, то, что дальше в этом пункте, — не для экзамена, но на всякий случай напишу*

Мотивация предыдущего изменения в том, что мы не можем два раза использовать что-то вроде `template<typename T, typename = decltype(std::declval<T>().foo())>`, так как в таком случае компилятор не различит перегрузки. Но если использовать `void* = nullptr`, то все будет хорошо.

Но есть еще один подводный камень. Он состоит в `std::void_t`. Компилятор просто соптимизирует и скажет, что это всегда `void`, и таким образом может забить на выражение внутри. Поэтому можно написать свой `void_t`:
```cpp
template<typename...>
struct my_void { using type = void; };

template<typename... Ts>
using my_void_t = typename my_void<Ts...>::type;
```

### SFINAE (Вспомогательный `void_t` в специализациях шаблонных классов)
Третий способ. Пример:
```cpp
template<typename T, typename = void>
struct MyFormatHelper {
    void func1() {}
};

template<typename T>
struct MyFormatHelper<T, decltype(static_cast<void>(std::declval<T>().foo()))> {
    void func2() {}
};

struct Foo {
    void foo() {}
};

int main() {
    MyFormatHelper<int> f1;  // 1
    f1.func1();
    MyFormatHelper<Foo> f2;  // 2
    f2.func2();
}
```
Здесь все происходит аналогично предыдущим пунктам. Но мы изначально указали фиктивный шаблонный аргумент, чтобы потом использовать его для вырезания по SFINAE. Чтобы можно было создавать `FormatHelper<T>`, не указывая второй параметр (а он не нужен пользователю), сделали `void` значением по умолчанию. 

Примечание: поиск конкретного метода или чего-то такого называется member detection idiom.
## Билет 39
Автор: Кирилл Бриллиантов

### ```enable_if```

Помимо того, чтобы вырезать перегрузки по корректности какого-то выражения, можно вырезать еще и по корректности условия. Для этого существует структурка ```enable_if```

Возможная реализация enalble_if

```cpp
template<bool B, class T = void>
struct enable_if {};
 
template<class T>
struct enable_if<true, T> { using type = T; };

template<bool B, class T = void>
using enable_if_t = typename enable_if<B, T>::type; // чтобы в коде не лезть внутрь enable_if
```

То есть если условие ложно, то выберется основная версия ```enable_if``` (имеется в виду не специализация). А в такой версии нет псевдонима type, получается, что если ```enable_if_t<B, T>``` полезет внутрь ```enable_if``` , то он не найдет член type, поэтому будет substitution failure.

### Удаление перегрузок методов внутри класса

Иногда хочется удалить некоторые перегрузки изначально нешаблонных методов внутри шаблонного класса. Наивное решение ждет неудача

```cpp
template <typename T>
struct MemberDetecter {
  std::enable_if_t< /*some condition*/, bool> test() {
    return true;
  }
  bool test() const /* const, чтобы не было ambigous */{ 
    return false;
  }
};
```
В такой реализации, если условие неверно, произойдет ошибка компиляции, так как SFINAE не работает для нешаблонных объектов, а в данном случае  ```test``` - нешаблонная фукнция. Чтобы это пофиксить

```cpp
template <typename T>
struct MemberDetecter {
  template <typename U = T> // Теперь test - шаблонная
  std::enable_if_t< /*some condition*/, bool> test() {
    return true;
  }
  bool test() const /* const, чтобы не было ambigous */{ 
    return false;
  }
};
```

Теперь при вызове test ничего не поменялось, так как есть параметр по умолчанию, но устранилась ошибка компилции, так как врубилось SFINAE

### Упрощенный member detection

Две предыдущие идея можно объединить для упрощенного member detection

```cpp
// детектим метод int getValue() const;
template <typename T>
struct MemberDetecter {
  bool test (...) const { return false; } // 1
  
  template <typename U = T>
  std::enable_if_t<
    std::is_same_v<int, decltype(std::declval<const T&>()).getValue()>,
    bool
  > test (std::nullptr_t) cosnt { // 2
     return true;
  }
};
```
Внутри ```enable_if_t``` происходит многоуровневая проверка
- Вначале провеятся можно ли вызывать getValue() от const& на объект типа T. Если нельзя то данная перегрузка вырежется по SFINAE
- Далее происходит проверка того, что возвращаемые типы сошлись при помощи ```is_same_v```

Также тут используется ```...``` для того чтобы сделать перегрузку с приоритетом меньше, чем у 2. Помимо точек надо, чтобы 2 что-то принимало (например std::nullptr_t). Возможно, здесь можно обойтись без этого, но такой трюко удобен, когда кол-во перегрузок больше двух.
## Прочие мелочи, не в билетах
Авторы: ..., Пётр Сурков

### If-with-init statement
Хотим завести переменную, чтобы она была доступна только в условиях и телах `if`, `else if`, `else`.

Очевидное решение:
```c++
map<int, string> m = ...;
{
    typename map<int, string>::iterator it = m.find(10);
    if (it != m.end()) cout << it->second << '\n';
    else               cout << "Not found\n";
}  // После этой скобки `it` недоступен
```

Решение строго лучше, пишем объявление прямо в `if`:
```c++
map<int, string> m = ...;
if (auto it = m.find(10); it != s.end()) {
    cout << it->second << '\n';
} else {
    cout << "Not found\n";  // it тут доступен.
}  // После этой скобки `it` недоступен.
```

### Строковые литералы
Тип строковых литералов - массив `const char` фиксированной (на этапе компиляции) длины. Это позволяет писать такие шаблонные функции:
```c++
template<size_t N>
constexpr auto parse_format(const char (&s)[N]) {
    int specifiers = 0;
    array<char, N> found{};
    for (size_t i = 0; i < N; i++) {  // Вот в этом месте так как strlen не constexpr, то если бы приняли как char*, то не смогли узнать до куда идти циклом.
        if (s[i] == '%') {
            if (i + 1 >= N)
                throw std::logic_error("Expected specifier after %");
            i++;
            found[specifiers++] = s[i];
            if (!(s[i] == 'd' || s[i] == 'c' || s[i] == 's'))
                throw std::logic_error("Unknown specifier");
        }
    }
    return pair{specifiers, found};
}
static_assert(parse_format("hello%d=%s").first == 2);
static_assert(parse_format("hello%d=%s").second[0] == 'd');
static_assert(parse_format("hello%d=%s").second[1] == 's');
```
Таким образом, вот эта [библиотека](https://github.com/hanickadot/compile-time-regular-expressions) позволяет работать с регулярками в стиле `ctre::match<"[a-z]+([0-9]+)">(s)`

### TODO: RTTI
#### TODO: "полиморфный класс"
#### TODO: typeid
#### TODO: const std::type_info& и std::type_index
#### TODO: Mangling имён и type_info::name()