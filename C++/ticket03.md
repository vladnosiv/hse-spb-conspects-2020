## Билет 03 "Правила поиска имён (глобальных и внутри классов)"
Автор: Герман Тарабонда

### Где возникает qualified lookup, а где — unqualified

Если простым языком: то для  `foo()` происходит unqualified lookup (то есть просто поиск по имени), а для `::foo()` происходит qualified lookup.

Как вообще это происходит.

Unqulified lookup -- ищем в текущих `{}` где находится наш условный `foo()` и ищем объявление `foo()`. Подробнее об этом будет написано позже.

Qualified lookup -- ищем так как указано. Например: `model::animal::run()`. Сначала мы смотрим на `run()`. Вызывается qualified lookup. Теперь нужно найти `animal`. Это тоже выполняется qualified lookup'ом. Чотбы найти `animal` нужно найти `model`. А вот поиск `model` происходит с помощью unqulified lookup.

### Явное обращение к глобальному пространству имён (`::foo`)

Все что не лежит явно в namespace'ах лежит в глобальном namespace. Чтобы обратиться к глобальному namespace можно явно указать `::foo`.

### Правила unqualified lookup в телах функций, методов, на уровне пространств имён ("глобально")

Правило такое: везде кроме классов ищем объявление до строчки использования. В классах мы ищем во всем его объявлении. Например:

```C++
... // И в конце концов здесь (4)
namespace food {
... // Потом здесь (3)
class Meat {
... // Потом здесь (2)
void fry() {
... // Ищем здесь сначала (1)
slice();
... // Здесь не ищем
}
... // И здесь (2)
}
... // Здесь тоже не ищем
}
... // И тут не ищем
```

### Forward declaration для функций и классов, особенности неполных типов

В чем прикол forward declaration? На самом деле это довольно полезная штука. Оно позволяет программисту написать объявление чего-либо, а затем когда-нибудь написать определение этого чего-либо.

Пример из `lab_11` файл `bin_manip.h`:

```C++
#include <iosfwd>

std::ostream& hex(std::ostream&);
...
```

Здесь нужно только объявление `ostream`, поэтому достаточно подключения `iosfwd`. Это заметно ускоряет компиляцию программу, так как в `iosfwd` написаны только неполные объявления классов.

В `bin_manip.cpp` уже нужно подключать `iostream`, так как там есть вызов функций, которые не объявлены в `iosfwd`.

В `employee.cpp` тоже есть проблемы. Например:

```C++
#include "bin_manip.h"

...(ifstream& f) {
f >> read_le_int32(...);
}
```

Такого рода файл будет выдавать ошибку компиляции, так как не поймет, что `ifstream` - наследник `istream`, так как в `iosfwd` не указаны детали реализации. Поэтому дополнительно в этот файл нужно подключить `fstream`.

Кратко про неполные типы: объявлять можно, пользоваться нельзя. Пример:

```C++
class IncompleteClass; // forward declaration, неполный класс

void foo1(const IncompleteClass* p); // ОК
void foo2(const IncompleteClass& p); // ОК
void foo3(IncompleteClass p); // ОК
void foo4(IncompleteClass p); // не ОК, определение функции

IncompleteClass* p; // ОК
IncompleteClass p; // не ОК
```

