## Билет 15
Автор: Егор Лебедев

### Параметры шаблонов
Современный `c++` предоставляет множество возможностей программисту. 

0. Шаблоны могут иметь параметры по умолчанию

В частности параметрами шаблона могут быть 
1. Произвольные типы
2. Целые числа
3. Любые указатели и _ссылки_ на статические переменные
4. Шаблоны
5. В параметрах шаблонах возможно указывать параметры по умолчанию (при этом если у типа C в шаблоне был какой-то параметр по умолчанию, он не "отнаследуется" в шаблон-параметр)
6. `bool`
7. Начиная с `c++20`: к целочисленным типам добавился `float`
8. Начиная с `c++20`: к целочисленным типам добавились какие-то структуры
```c++
struct MyStruct {
    int x;
};

template<typename T = char>        // 0
struct Helper { T x; };

int globalVar = 4;

template<
    typename T,                    // 1
    std::size_t N,                 // 2
    int& P,                        // 3
    template<typename> typename U, // 4
    template<
        typename = T, 
        typename = allocator<T>
    > typename C,                  // 5
    bool B                         // 6
    /*  float f    */ // c++20     // 7
    /*  MyStruct  */ // c++20      // 8
> struct Hell {
    void go() {
        T t = N + P;
        U<T> u{ t };
        C<> c; c.push_back(t);
        assert(B);
    }
};
int main() {
    Hell<int, 10, globalVar, Helper, vector, (100 > 11)> hell; // 9
    hell.go();
}
```
9. Стоит заметить, что `(100 > 11)` обязательно, иначе беды с парсингом.

### Автовывод параметров шаблонов
Шаблонные функции умеют получать информацию (о шаблонах) от своих аргумент, поэтому их не всегда стоит явно указывать:
1. Можно указать лишь несколько шаблонных параметров, остальные выведутся из аргументов функции
2. Шаблонные параметры `U`, `F` в коде ниже функция вывела из своих аргументов.
3. Параметры по умолчанию не обязательно должны быть в конце
```c++
template<typename F, typename T = long long, typename U = void, typename V>
void func(F f, T t, U u, V v) {
    cout << f + t + u + v;
}

func<int>({}, {}, 239, -179);
```
Данный код выведет на экран число `30`

* Начиная с `c++17` аналогичное работает для конструкторами класса, называется `Class template argument deduction` (`CTAD`).

### Специализации шаблонов

Синтаксис:
1. Общий случай
    ```c++
    /* 1.1 */ template<typename T> class Stack { ... };
    /* 1.2 */ template<typename T> class unique_ptr { ... };
    ```

2. Специализация
    ```c++
    /* 2.1 */ template<> class Stack<bool> { ... };
    ```
    Если компилятор где-нибудь увидит `Stack<bool>`, то он будет обращаться именно к специализации, иначе - общий случай. (Понятно, что работает не только для `bool`).

    Важно отметить, что общий случай может не иметь вообще ничего общего со специализацией кроме имени.

3. Частичная специализация
    ```c++
    /* 3.2 */ template<typename T> class unique_ptr<T[]> { ... };
    ```
    Теперь мы можем заменить `delete` из общего случая на `delete[]` в частичной специализации. 

    Эта специализация берется, "если уравнение с `T[]` решается относительной данной переменной", иначе берется общий случай.

4. Вообще любые уравнения
    ```c++
    /* 4.1 */ template<typename T, typename U, std::size_t N>
    class Stack<std::map<T, std::array<U, N>>> { ... };
    ```
    Мораль: вместо `...` в `Stack<...>` можно подставлять вообще любое уравнение на тип.

_Замечание_: частичные специализации есть только у структур/классов, функции - только полные специализации, но это уже совсем другой билет...
