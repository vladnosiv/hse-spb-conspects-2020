## Билет 06
Автор: Никита Абрамов

#### Конвенции именований стандартной библиотеки, отличия stdio.h и cstdio

Язык С++ позволяет использовать всю стандартную библиотеку языка С, но появляется еще и собственная стандартная библиотека. Заметим, что STL (standard template library) - кусок стандартной библиотеки языка C++. Конвенция в стандартной библиотеке C++: заголовок пишется без разширений (например, без `.h`). Добавил что-то свое в `std` - за парой исключений получил UB. Для стандартных заголовков из C есть два варианта их подключения:

* `<stdio.h>` - попадает в глобальный namespace (`::fopen`), может положить что-то в `std`
* `<cstdio>` - попадает в `std` (`::std::fopen`), может положить что-то в глобальный

Можно использовать оба, но лучше придерживаться одного стиля и использовать один.  
`#include <bits/stdc++.h>` — нестандартный заголовок из GCC, зависит от версии, лучше не использовать.

#### Неформатированный ввод-вывод (get, peek, unget, read, seekg/tellg)
Всё ещё есть отличие между текстовым и бинарным режимом: 
`std::ifstream f("a.bin", std::ios_base::in | std::ios_base::binary);`
Существуют функции, в которых мы не можем никак форматировать наш ввод-вывод, разберем основные из них подробнее.

*  get   
`std::istream::get` - (`cin.get`) - считывает 1 символ/строку в c-style, бывает:  
```
int get(); //считывает символ и возвращает его целочисленный код
istream& get (char& c); //можно записать в переменную
istream& get (char* s, streamsize n); // записать в строку в стиле c-style
istream& get (char* s, streamsize n, char delim); /* считывает n - 1 символ или до того,
как встретит разделитель(по умолчанию - перенос строки). 
Деталь - разделитель не извлекается, его потом можно считать
\0 -  автоматически добавляется в конец, можно ставить n = 0, тогда - пустая строка*/
istream& get (streambuf& sb); //используется для работы с stream buffer (не разбиралось)
istream& get (streambuf& sb, char delim);
```
если не удалось — `istream::traits_type::eof()` (возвращает End-of-File value, которое для многих стандартных функций    считается, как неверный символ (ни с чем сравнивать тоже нельзя))
*  peek
`int peek();` - возвращает текущий элемент во входной последовательности, но не извлекает его, если установлены флаги ошибок(или устанавливается в момент выполнения, то возвращает `istream::traits_type::eof()`)
*  unget
`istream& unget();`  - вначале очищает eofbit (с С++11), возвращает последний символ, который достали, если есть флаги ошибок, то устанавливает failbit и возвращается. Следует работать аккуратно  
*  read
`istream& read (char* s, streamsize n);`- считывает символы в буфер (размер - знаковый аналог size_t) (аналог `fread`)
* seekg/tellg
`streampos tellg();` - возвращает текущую позицию. `streampos` кастуется к `int`, для элементов этого типа существуют: 
`!=` и `==`
`istream& seekg (streampos pos);` - устанавливает позицию на следующий символ, который будет доставаться из потока  
Пример:
```
// get length of file:
    is.seekg (0, is.end);
    int length = is.tellg();
    is.seekg (0, is.beg);
```
#### Форматированный ввод-вывод, отличия от printf (типобезопасность, поддержка пользовательских типов)
Пример для форматированного ввода-вывода
```
std::ostream& operator<<(std::ostream& os, int v) {
    return os;
}
std::istream& operator>>(std::istream& is, int &v) {
    return is;
}
std::cin >> x >> y;
(std::cin >> x) >> y; //так его разбирает компилятор, как раз ради этого и возвращаем ссылку
operator>>(operator>>(std::cin, x), y); //можно еще так
```
Стандартная библиотека перегружает операторы для базовых типов (`int`, `double`, `char`, `char*`) и каких-то своих (`std::string`). Форматированный ввод - потому что мы можем сами задавать формат, какой хотим. Разберем пример с добавлением произвольного класса(сразу про реализацию своих операторов ввода-вывода):
```
struct BigInt {
};
std::ostream& operator<<(std::ostream& os, const BigInt &v) {
    return os << (int)v; // алгоритмический костыль(чтобы не уйти в бесконечную рекурсию)
    return os << static_cast<int>(v); // C++-style алгоритмический костыль
}
```
Обычно, когда есть поля, состоящие из базовых типов, то обходится без подобных костылей.  
##### Общие правила  
*  Возвращаем ссылку(неконстантная, потому что поток меняется) на левый параметр, потому что несовсем понятно, что такое скопировать поток, особенно, когда он, например, из файла. Также хочется считывать несколько объектов подряд. 
*  Пишем для базовых классов потоков, если не нужно обратное (например, `istream`, а не `ifstream`). 
*  Сам объект для чтения принимает по неконстантной ссылке, потому что мы в него что-то записываем.   
*  Можно делать friend, если хотим доставать какие-то приватные поля у класса.
Но так как обычно friend использовать не любят, потому что это нехорошо отражается на архитектуре(цитата Соколова), то можно писать так:   
```
struct BigInt {
public:
    std::ostream& operator<<(std::ostream& os) {
        os << v;
        return os;
    }
private:
    int v;
};

std::ostream& operator<<(std::ostream& os, const BigInt &v) {
    return v << os
}
```
#### Реализация своих операторов ввода-вывода, включая обработку ошибок
Разберем теперь более подробно обработку ошибок  
У каждого потока есть три бита состояния, которые можно узнать:
* badbit — поток умер: не смог записать байт (место кончилось)
* failbit — не удалось прочитать/записать, но поток жив. Например, неверный формат. Где мы сейчас в потоке — непонятно.
* eofbit — мы уже знаем, что поток закончился (аналогично feof). Например, если в конце файла 123 и мы прочитали число, то мы не знаем, что за пробелом конец потока.
Чтение: .rdstate(), .fail(), .eof(), .bad(), operator bool (отрицание fail) и operator!.  
`iostate rdstate() const;` - возвращает комбинацию битов, про которые было сказано раннее  
`.fail(), .eof(), .bad()` - возвращает каждый конкретный бит(могут быть реализованы через сравнение с `rdstate()`)
Запись:  
* clear() для сброса/перезаписи флагов.
* setstate() для добавления флага.
* На контестах достаточно while (cin >> n)
* Для корректного чтения/записи BigInt стоит не просто читать символы, а ещё и флаги ставить при ошибках.
* Чтобы показать совсем разумную ошибку, обычно надо парсить руками

Можно устанавливать исключения(чтобы они вылетали при проставлении битов)
```
std::cout.exceptions(std::cout.failbit | std::cout.badbit);
std::cin.exceptions(std::cin.failbit | std::cin.badbit);
```
#### Реализация своих манипуляторов (например, `read_le_int32` или `eat`)
Если у нас манипулятор без параметров, то можем просто представлять его как функцию:
`ios_base& hex (ios_base& str);` - пример из std, устанавливает флаг(basefield) на hex и работает с ним.
```
ostream &tab(ostream &out)
{
    return out « '\t'; // добавляем tab
}

istream &eatline(istream &in) // убираем строку
{
    while(in && in.get() != '\n')
    {
    }
    return in;
}
```
Если же хотим запускать от чего-то (например, `read_le_int32(x)`), то это похоже на вызов конструктора у объекта, поэтому приходится заводить структуру.  
Рассмотрим несколько примеров:  
Пример с friend - манипулятором
```
struct write_le_int32 {
    explicit write_le_int32(int32_t _val) : val(_val) {} //для read - принимаем и храним все по ссылке
    friend std::ostream& operator<<(std::ostream &os, const write_le_int32 &d);/* const&, чтобы лишний раз не копировать, а также, так как у нас состояние объекта меняться не будет - мы просто его выведем) */
private:
    int32_t val;
};
```
Можно снова избавиться от `friend` с помощью трюка, описанного выше (разумеется, можно использовать не только операторы `<<`, но и `()`, например)  
```
class expand
{
public:ostream &operator <<(ostream &out, expand number)
{
   return number(out);
}
    expand(short to_expand) : value (to_expand) {}
    ostream &operator()(ostream &) const; //как-то выведем число из цифр в формате слов
private:
    short value;
    static const char *const tens[];
    static const char *const units_and_teens[];
};

ostream &operator <<(ostream &out, expand number)
{
   return number(out);
}
```
