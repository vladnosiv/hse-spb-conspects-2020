## Билет 05
Автор: Венедиктов Роман

### Конвенции именований стандартной библиотеки, отличия stdio.h и cstdio
* В стандартной библиотеке C++ есть кусок под названием STL (standard template library),
  это всякие вектора и алгоритмы.
  Ввод-вывод (`iostream`) туда не входит.
  Но иногда STL путается с "стандартная библиотека C++".
* Конвенция в стандартной библиотеке C++: заголовок пишется без `.h`
  и обычно добавляет имена только в `namespace std`
  * Добавили что-то своё в `namespace std` (за парой исключений) — UB
* В C++ есть два вида заголовков из Си:
  * `<stdio.h>` — всё подключил в глобальный namespace, опционально в `std`
  * `<cstdio>` всё подключил в `std`, опционально в глобальный

### Иерархия потоков ввода-вывода
* Иерархия классов:
![](https://github.com/e2e4b6b7/hse-spb-conspects-2020/blob/master/C%2B%2Bmedia/Ticket5.jpg)
  * Базовый `std::ios` определяет функции для обработки ошибок.
  * В функциях, которые записывают/читают данные вы обычно
    берёте ссылку на базовые `istream`/`ostream`. 
    (Чтобы корректно работать со всеми наследниками)
  * Всякие `basic_istream`, это обобщения на случай, если символ — не `char` 
    (а например, четыре байта).
### Файловый ввод-вывод
* Можно открыть файл из `<fstream>`:
  ```c++
  std::ifstream in("a.txt"); // Если файл не открылся? Будет в состоянии "ошибки", надо проверять
  // in.close() // Не нужно закрывать, ifstream/ofstream сам закрывает, когда вызывается деструктор. В том числе не нужно даже если нет проверки на успешность открытия.
  ```

### Байтовый и текстовый режим
Открытие в бинарном режиме:
`std::ifstream f("a.bin", std::ios_base::in | std::ios_base::binary);`.
Разница режимов в том, как обрабатывать специальные последовательности байт для определенный платформ. Под Linux бинарный и не бинарный режим работают одинаково. Под Windows, в текстовом режиме, \r\n при чтении переходит в \n и обратно при выводе.

* `cin.get` — посмотреть один символ, вытащить его из потока, если не удалось — `istream::traits_type::eof()`
* `cin.peek` — посмотреть один символ и не вытаскивать
* `cin.unget` — запихнуть символ обратно, с ним надо аккуратно читать документацию, когда это можно делать (Если не смог, ставит `badbit`)
* `read` — читает символы в буфер
* `seekg`/`tellg` — можно узнать позицию в файле.

### Обработка ошибок
У каждого потока есть три бита состояния, которые можно узнать:

* `badbit` — поток умер: не смог записать байт (место кончилось)
* `failbit` — не удалось прочитать/записать, но поток жив.
  Например, неверный формат.
  Где мы сейчас в потоке — непонятно.
* `eofbit` — мы __уже__ знаем, что поток закончился (аналогично `feof`).
  Например, если в конце файла `"123 "` и мы прочитали число, то мы не знаем, что за пробелом конец потока.

Чтение: 
* `.rdstate()` — полное состояние потока (bitmask)
* `.fail()` = `failbit || badbit`
* `.eof()` = `eofbit`
* `.bad()` = `badbit`
* `operator bool` — отрицание `.fail()`
* `operator!` = `.fail()`

Запись:
* `clear(bitmask)` — сброcить флаги и задать такое состояние 
  (по умолчанию `goodbit`)
  (если соответсвующий stream buffer — nullptr,  то добавляет к состоянию `badbit`)
* `setstate(bitmask)` для __добавления__ флага.

### Проверка конца файла и почему нельзя писать while (!eof)
```c++
while (!in.eof()) {
	in >> a;
	// some code
}
```
На файле `"123 "` считает первое число, потом пойдёт считывать второе и не сможет. Не перезапишет `a` и код выполнится для последнего числа дважды

Более правильно:
```c++
while (in >> a) {
	// some code
}
```
