## Билет 24
Автор: Пётр Сурков

### STL

* Containers libary
* Iterators libary
* Algoritms libary

Этот билет — Containers libary. В следующих билетах есть подробнее про каждый из видов контейнеров в нём. 

А ещё тут спрашиваются отличия, например, stdio.h и cstdio. В C используем первый, в C++ — второй, он не загрязняет глобальное пространство имён, а кладёт всё в `std::`

### Containers libary
Хранит объекты и управляет их временем жизни.

Должен быть

* Деструктор
* Хотя бы некоторые из конструкторов (копирования, перемещения, создания с параметрами, в зависимости от вызываемых методов)
* Обычно должны быть операторы присванивания (копирования, перемещения)

Контейнеры инвариантны по типам: `vector<Base*>` и `vector<Derived*>` - независимые контейнеры. Скопировать второй в первый не получится.

#### Аллокатор

Памятью управляет аллокатор - шаблонный класс, умеющий выделять, удалять память, инициализировать и удалять объект. 

Обычно используется `std::allocator`, он вызывает `new/delete`, которые можно [перегружать](https://habr.com/ru/post/490640/).

Аллокатор - сложный объект. должен уметь выделять не только `T`. Например, в `list<>` нужно уметь выделять внутренний тип (структуру с `T` и указателями на следующий элемент).

К тому же, до C++11 аллокаторы не могли иметь глобального состояния.

Из-за этого есть специфичные требования к написанию собственных аллокаторов.

#### Сложность и гарантии исключения
Стандарт обещает какое-то время работы. Например, копирование `vector<T>` происходит за `O(n)` копирований `T`. 

Базовая гарантия есть всегда, про строгую каждой операции надо читать в стандарте. Но если move T кидает исключения, то многие строгие гарантии рушатся. 

#### Виды контейнеров

* Последовательные (хранят элементы в фиксированном пользователем порядке): `vector`, `deque`, `list`, `forward_list`.
* Ассоциативные (сортируют элементы по ключу): `map`, `set`, `multimap`, `multiset`.
* Неупорядоченные ассоциативные (хэшируют элементы по ключу): `unordered_*`.
* Адаптеры (надстраиваются над другими контейнерами): `queue`, `priority_queue`, `stack`.

#### Стандартные операции, есть всегда:

* Конструктор по умолчанию `O(1)`
* Конструктор перемещения `O(n)` (при копировании `T` за `O(1)`)
* `a.swap(b)`, `swap(a,b)` за константу для всех, кроме `std::array`
* `.empty()` (константа)
* `.size()` (константа, даже у списка)
* Конструктор копирования, если `CopyInsertable` (есть конструктор копирования у `T`):
* `==`/`!=`, если объекты можно сравнивать на `==`/`!=`:    
* Для обобщённого программирования:
    * `vector<T>::value_type`
    * `vector<T>::reference_type`
    * `vector<T>::const_reference`
    * `vector<T>::size_type`
    * `vector<T>::difference_type`

#### Некоторые из гарантий исключений
##### noexcept
* `erase` (если только не бросит исключение move/copy оператор/конструктор в `vector`/`deque`)/`clear`/`swap`
* `pop_back`/`pop_front` (если есть)

##### Строгая гарантия
* `insert`/`emplace` (если вставляет один элемент, а не много сразу; и то только если с нужного конца, см. `vector`/`deque`)
* `push_back`/`push_front`/`emplace_back`/`emplace_front` (если есть)


#### Range-based for
Синтаксический сахар:
```cpp
for (DECL : EXPR) BODY
```
разворачивается как
```cpp
{
    auto range = EXPR;
    auto begin = std::begin(range);
    auto end = std::end(range);
    for (auto it = begin; it != end; ++it) {
        DECL = *it;
        BODY
    }
}
```
Функции `std::begin`/`std::end` вызывают внутренние `begin`/`end`, но перегружены для обычных массивов.

Есть тонкость. В `for (int &x : foo().bar()) { ... }` временное значение `foo()` не живёт, но `bar()` живёт. 

[Пример](https://cppinsights.io/) развёртки сахара.

Как видно из раскрытия, не стоит удалять/добавлять элементы в контейнер проходясь range-based for по нему.

В билете №28 можно прочитать про ranged-based ещё раз и найти информацию про связь с ADL, но в данном билете это не требуется.

#### Удаление, Инвалидация
Функция `.erase` возвращает итератор на элемент, который теперь занимает место первого удалённого элемента, либо `end()` при его отсутствии. 

Если идём по контейнеру, удаляя элементы по текущему итератору, то пишем `it=v.erase(it)`, вместо просто `v.erase(it)`. Иначе сделав `it++` на следующем шаге можем получить инвалидированный итератор, так как `it` указывал на уже удалённый элемент.

Про другие варианты инвалидации можно почитать в билете №28. 
