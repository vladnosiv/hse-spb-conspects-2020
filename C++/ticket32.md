### Билет 32 (Виды инициализации)

Автор: Таня Гордеева

## Старые виды инициализации
* **Default initialization**: `T t;` (в том числе поля), `new T`.
  * Конструктор по умолчанию для классов (возможно, неявный).
  * Для примитивов __ничего не делает__, в переменной лежит мусор, а обращение к ней -- UB.
  * Так что странно, что это называется инициализацией по умолчанию, потому что это скорее отсутствие инициализации. Лучше её вообще избегать, а в полях классов использовать direct member initializers. И в отличие от списка инициализации, при использовании которого переменные проинициализируются в порядке объявления полей, direct member initializers проинициализируют все переменные одновременно, что приятно
* **Value initialization**: `new T()`, `T()`, `: member()`.
  * По сути то же, что и default initialization, единственное отличие для примитивов: zero initialization (в ноль).
  * В C++11 добавили: `T t{};`, `new T{}`, `T{}`, `member{}`.
  
  ```c++
  struct Foo {
      int x;  // default initialization
      int y{};  // value initialization
      int z;
      Foo() : z() /* value initialization */ {}
  };
  int main() {
      Foo f;  // default initialization
      int z = f.z;  // 0, потому что проинициализирован в member initializer list
      int y = f.y;  // 0
      int x = f.x;  // UB
  }
  ```
## Direct, copy, list инициализация: когда какая вызывается
* **Copy initialization**:
  * `T t = ..;`, `T t = {..}`, `f(t)`, `return ..`, `throw ..`.
  * Копирующая инициализация. В этом случае мы указываем переменную и через знак равенства — её значение.
Также используется, когда аргумент передаётся в функцию по значению, или когда происходит возврат объекта из функции по значению.
  * Вызов _не-explicit_ конструктора `T` с параметрами. Если выполнить копирующую инициализацию для объекта, конструктор которого отмечен как explicit, происходит ошибка компиляции:
  ```c++
  struct Foo {
    explicit Foo(int) {}
  };
  
  Foo f = 1; // Compilation error
  ```
  * Если есть другой конструктор, который не является explicit, но при этом хуже подходит по типу, то копирующая инициализация вызовет его, проигнорировав explicit конструктор:
  ```c++
    struct Foo {
      explicit Foo(int) {}
      Foo(double) {}
    };
    
    Foo f = 1; // // вызывает Foo(double)
    ```
  * В C++11 можно делать несколько параметров.

* **Direct initialization**: `T t(foo, bar)`, `T(foo, bar)`, `static_cast<T>(foo, bar)`, `new T(foo, bar)`, `: member(foo, bar)`.
  * Прямая инициализация. Выполняется всегда, когда есть аргумент в круглых скобках.
  * Для примитивов никакого отличия от копирующей инициализации нет. Для пользовательских типов можно передавать несколько аргументов.   
   В ситуации с explicit конструктором прямая инициализация работает нормально.
  * Особенности: the most vexing parse, нельзя использовать в полях
  * В C++11 добавили: `T t{foo, bar};`, `T{foo, bar}`, `new T{foo, bar}`, `member{foo, bar}`.

* **List initialization**: она же "инициализация списком" или "универсальная инициализация" (uniform initialization).
Является формальным описанием инициализации с фигурными скобками.
Делится на direct и copy аналогично круглым скобкам:

* Direct list initialization:
  * `T object{arg1, arg2, ..};`, в том числе для полей.
  * `T{arg1, arg2, ..}` (в том числе в выражениях, `return`, параметрах)
  * `new T{arg1, arg2, ..}`
  * `: member{arg1, arg2, ..}`
* Copy list initialization:
  * `T object = {arg1, arg2, ..};`
  * `foo({arg1, arg2, ..})` (веселье с перегрузками `f`), в том числе с `operator[]` и `operator=`
  * `return {arg1, arg2, ..};` (нужно уже знать тип возвращаемого значения)

---
## The most vexing parse
Перевод: самый неприятный разбор

* Всё, что компилятор может прочитать как объявление (declaration), он читает именно как объявление.
  ```c++
  struct Timer { .. };
  struct TimeKeeper { TimeKeeper(Timer t) { .. } .. };
  int main() {
      TimeKeeper time_keeper(Timer());
      // Компилируется как объявление функции:
      // TimeKeeper time_keeper(Timer (*func)());
      // Чинится:
      TimeKeeper time_keeper1((Timer()));  // Лишние скобки.
      auto time_keeper2 = TimeKeeper(Timer());  // Copy initialization вместо direct.
      TimeKeeper time_keeper1{Timer{}};  // Хотя бы один фигурные скобки.
      TimeKeeper time_keeper1(Timer{});  // То есть так можно.
      TimeKeeper time_keeper1{Timer()};  // И так тоже.
  }
  ```
* Нельзя использовать в полях:
  ```c++
  struct Foo {
      Object1 a(10);  // Не компилируется.
      Object2 b();  // Компилируется как объявление функции
      Object3 c(Object4());  // Компилируется как объявление функции
  };
  ```
  
---
## Агрегатные типы
Это массивы `Foo a[10];` и "простые" классы, в которых не может быть:
  * Конструкторов
  * `private`/`protected` полей и наследования
  * Виртуальных функций и виртуального наследования
  * В C++11 (и только в них) нельзя было default member initializer: `Foo field(10);`
  
Агрегатные типы можно инициализировать фигурными скобками, в том числе рекурсивно. Это **aggregate initialization**: `T t = {..}`, `T t{..}`, `new T{..}`.
Если мы не укажем размер массива при агрегатной инициализации, компилятор сам догадается о размере.

  ```c++
   struct Point2D { int x, y; };
   struct Point3D : Point2D { int z; };
   int main() {
       Point2D a{1, 2};
       Point3D b{{1, 2}, 3};  // Записали подряд все базы и члены.
       Point3D arr[] = {{{1, 2}, 3}, {{4, 5}, 6}};
   }
  ```
* Агрегатная инициализация использует копирующую инициализацию для каждого элемента. Поэтому, если пытаться использовать агрегатную инициализацию для объектов с explicit конструкторами, то происходит ошибка компиляции:
  ```c++
  vector<int> arr1[] = {vector<int>(10) /* direct initialization */};  // Ок
  vector<int> arr2[] = {10};  // Ошибка компиляции, explicit vector<int>(int) 
  ```
* Если какой-то элемент опущен, то для него value initialization (бывает warning для объектов):
  ```c++
   int arr1[5];  // default initialization, в элементах мусор.
   int arr2[5] = {1, 2};  // aggregate initialization, в элементах 1 2 0 0 0
   int arr3[1] = {1, 2};  // Ошибка компиляции
   int arr4[2] = {};  // aggregate initialization, 0 0
   int arr5[4] = {{} /* value initialization */, 1};  // 0 1 0 0
  ```

* Можно опускать почти любые непустые скобочки (brace elision):
  ```c++
  struct Point2D { int x, y; }; struct Point3D : Point2D { int z; };
  int main() {
      Point3D arr[4] = {
          {1, 2, 3},  // {{1, 2}, 3} x=1, y=2, z=3
          {4, 5},     // {{4, 5}, 0} x=4, y=5, z=0
          6, 7, 8     // {{6, 7}, 8} x=6, y=7, z=8
                      // {{0, 0}, 0} x=0, y=0, z=0
      };
  }
  ```

---
* Пример с опущенными скобками:
  ```c++
  struct Foo { int x; };
  struct Bar { Foo f; };
  struct Baz { Bar b; };
  int main() {
      Baz b{10};     // OK
      Baz b{{10}};   // OK
      Baz b{{{10}}}; // OK
      assert(b.b.f.x == 10);
  }
  ```
* Однако если если есть функция с перегрузками, принимающая Foo, Baz или Bar, то в зависимости от количества скобок поведение программы может меняться
  ```c++
  f(  {10}  );
  f( {{10}} );
  f({{{10}}});
  ```
* В С++20 добавили designated initializers (было в С). Можно инициализировать ТОЛЬКО в порядке объявления полей. Однако пропускать поля можно.
  ```c++
  struct A { int x; int y; int z; };
  A a{.x = 1, .z = 2}; // x=1, y=0, z=2
  ```
* Нельзя эту конструкцию использовать рекурсивно, то есть нельзя написать ```{.c.e = 7};```, хотя можно написать ```{.c{.e = 7}}```.

---
## `std::initializer_list`
* braced-init-list может быть скрыто преобразован в std::initializer_list, это такой специальный новый тип. И если есть конструктор, принимающий на вход std::initializer_list, то вызывается именно этот конструктор:
   ```c++
   template <typename T>
   class vector {
     //...
     vector(std::initializer_list<T> init); // конструктор с initializer_list
   };
   
   std::vector<int> vec{0, 1, 2, 3, 4}; // вызывает этот^ конструктор
   ```
* **std::initializer_list для лохов** и вот почему: 
это вектор фиксированного размера с элементами const. То есть это тип, у него есть функции begin и end, которые возвращают итераторы, есть собственный тип итератора, и чтобы его использовать, нужно включать специальный заголовок. Поскольку элементы std::initializer_list являются const, его нельзя перемещать, поэтому, если T в коде выше является типом move-only, код не будет выполняться.


* Далее, std::initializer_list является объектом. Используя его, мы, фактически, создаём и передаём объекты. Как правило, компилятор может это оптимизировать, но с точки зрения семантики мы всё равно имеем дело с лишними объектами.

* Пример **интересного** поведения этого синтаксиса:
  * Сидите с пацанами кайфуете:
  ```c++
  std::string s(48, 'a'); // "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  ```
  * И тут Стасян такой пацаны смотрите:
  ```c++
  std::string s{48, 'a'}; // "0a"
  ```
  * бл*н Стасян ну ты и дебил конечно..

* Итого минусы:
  * Всегда создаётся массив, причём констант:
       ```c++
       vector<string> v{"foo", "bar", "baz"};
       // Перепишется в
       {
         const string temp[3] = {"foo", "bar", "baz"};  // Создаются std::string
         vector<string> v(initializer_list(temp, temp + 3));  // Лишние копии
         // Временные строчки удаляются.
       }
       ```
  * Нельзя делать `move` из-за константности, нельзя хранить `unique_ptr`.


В C++11 можно для своих классов делать что-то похожее на aggregate initialization для массивов:
   ```c++
   struct Foo {
       Foo(std::initializer_list<pair<int, float>> l) {
           // Работаем с l, как с обычным контейнером
       }
   };
   pair<int, float> p;  // default initialization
   Foo f = {            // std::initialize_list
     {1, 2.0f},      // direct initialization
     pair(1, 2.0f),  // direct initialization
     p               // copy initialization
   };
   ```  

* std::initialize_list это **не** агрегатная инициализация, **скобки пропускать нельзя**:
  ```c++
  vector<pair<int, int>> v1 = {{1, 2}, {3, 4}};  // ОК
  vector<pair<int, int>> v2 = {1, 2, 3, 4};  // Ошибка компиляции
  ```
* Можно делать несколько перегрузок с разными `initializer_list<>`.
* Работает рекурсивно: `vector<vector<int>> = {{1, 2}, {}, {3, 4, 5}};`

## Прикол

Должно быть вы утомились, давайте сыграем в игру "что выведет"
   ```
    auto x1{1};
    auto x2 = {1};
    auto x3 = {1, 2, 3};
    if (std::is_same_v<decltype(x1), int>) std::cout << 1;
    if (std::is_same_v<decltype(x2), int>) std::cout << 2;
    if (std::is_same_v<decltype(x3), int>) std::cout << 3;
   ```
Правильный ответ: 1, всё остальное интерпретируется как ```initializer_list<int>```

---
## Тонкости list initialization

* У выражения со скобками (braced-init-list) *нет типа*!!!
* У выражения со скобками (braced-init-list) **нет типа**!!!
* У выражения со скобками (braced-init-list) ***нет типа***!!!

**Тип выводится в зависимости от контекста**

У инициализации списком есть полезное свойство: не допускаются сужающие преобразования (narrowing conversions).  
Если для инициализации int использовать double, то такой код не скомпилируется:
   ```
   int main() {
     int i{2.0}; // ошибка!
   }
   ```
То же самое произойдёт, если агрегатный объект с полями типа int инициализировать списком элементов double.


**Хроника мыслей компилятора, когда он увидел braced-init-list:**

* Если `T` — агрерат и у нас ровно один элемент типа `T`, то делаем copy/direct initialization из него.
* Если `T` — массив символов и передали ровно один строковой литерал, то из него.
* Если `T` — агрегат, то aggregate initialization (опускаютя скобки, можно не указывать все члены).
* Если список пуст и есть конструктор по умолчанию, то value initialization.
* Пробуем все конструкторы с `std::initializer_list<>` разных типов.
  Запрещаем сужающие преобразования (`double` в `int`).
* Пробуем все остальные конструкторы.
* Если в списке ровно один элемент, то инициализируем без narrowing conversion.
* Если список пустой, то value initialization.
---
