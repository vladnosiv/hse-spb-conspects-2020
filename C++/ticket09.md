## Билет 09 "Исключения — основы"
Автор: Чистякова Полина
### Предусловия и постусловия конструктора и деструктора, инвариант объекта

Инвариант объекта - то, что определяет его корректное состояние
Иными словами что-то, что всегда верно про этот объект.

Пример: ```uniq_ptr<T> a``` - владеет указателем, на основе которого он построен. Никто больше этим указателем не владеет.

Как понятно, пока объект живёт - инвариант выполняется. Отсюда вытекают некоторые уловия:

	Постусловие конструктора - инвариант выполняется
	Предусловие конструктора - поля сконструированны
	Постуловие деструктора - объект корректно уничтожен
	Предусловеи деструктора - инвариант выполняется
### Разные стратегии обработки для двух видов ошибок

Существует 2 типа ошибок - "ошибки программирования" (undefined behavior, нарушение инвариантов, невозможно предсказать поведение после) и "ошибки окружения" (некорректный ввод пользователя, теоретически можно предсказать и обработать)
Отличаются они тем, что первые совершил программист и сам находит (путём отладки кода), а вторые от него совсем не зависят (например, обращение к несуществующему файлу) и с ними надо научиться справляться.

Первые ошибки обрабатываются просто - можно поставить `assert`'ы и просто ронять программу, когда они происходят, чтобы программист сразу понимал, что что-то не так.
```C++
assert(2+2 != 4);
// программа упадёт и в стандартный поток вывода ошибок (stderr) выведется чисто эта строчка, с пометкой, что она упала.
```

Со вторым типом ошибок сложнее - так просто уже не поступить, надо сообщить пользователю, что же произошло, и, возможно, сохранить какие-то результаты.

Для этого существует несколько стратегий:
 * Вывод сообщения об ошибке сразу, как её встретили:
    ```C++
    void read_people() {
       File *f = fopen(filename, "r");
       if (!f) {
          printf("сообщение об ошибке");
          return;
       }
    }
    ```
    Проблема этого подхода - не всегда надо сразу писать в стандартный поток вывода (например, мы хотим выводить ошибку как-тов графическом интерфейсе)
    Иногда хочется ошибку обработать не тут (например, ошибка на сервере, а сказать надо что-то тому, кто туда обратился)
 * Возвращать код ошибки
   ```C++
   int sqlite3_open(const char *fname, sqlite3A *out); // Возвращаемое значение - код ошибки. Второй параметр - указатель на результат работы функции
   ```
   Проблема конкретно этогоподхода сразу видна - надо знать все значения кода, что не очень удобно для программста
 * Почти возвращение кода ошибки - возвращать структуру, в которой может лежать значение OK или Error
 
   *пример на Rust'е*
   ```Rust
     fn Read_people() -> Result<People, String> {
        match open() {
           OK(f) -> {...}
           Err(err) -> return Err(err);
        }
     }
     let f = try!(open());
   ```
   Здесь Result - как раз такая стурктурка. Если ошибок нет, она вернёт значение OK или значение Err в противном случае.
   Проблема этого подхода - каждая функция очень аккуратно прощупывает остальные, всегда готова поймать исключение и, если сама не может её обработать, прокинуть дальше.
 * Кидать исключения
   ```C++
   std::vector<int> read_vector() {
      int n;
      if (!(cin >> n)){
         throw invalid_vector_format();
      }
   }
   
   try {
      read_vector();
   } catch ( invalid_vector_format() &err ) { /* обработка ошибки */ )
   ```
   Данный подход - просто goto решение проблемы

### Исключения: try, catch, throw, где что ставить для обработки ошибок

В предыдущем пункте мы увидели пример использования исключений.
Чтобы его выбросить используется конструкция `throw exception`.

Для обработки исключения существует блок `try/catch`:
```C++
try {
   /*что-то, что может выкинуть исключение, которое мы хотим обработать*/
} catch (/*исключение, которое мы ловим*/) {
   /*обработка исключения*/
}
```
Почему это удобно?

Потому что это помогает не думать об исключениях там, где мы их не можем обработать.
Просто кидаем что-нибудь, что долетит до тех, кто знает, что делать (или не принимаем исключение, а пускаем его дальше).

Небольшие уточнения к синтаксису:
 * у `catch` есть особый синтаксис - `catch (...)` дословно значит - "поймай всё, что угодно"
 * В `catch` иногда полезно что-то сделать, а затем прокнуть ошибку дальше (например, если мы хотим проследить жизненный путь ошибки). Осуществляется конструкцией `throw;`
### Вложенные try/catch, несколько catch подряд и почему важно ловить по ссылке

Вложенные try/catch работают также, как и обычные. Поднявшись до try исключение смотрит на все catch - если не находит нужный, летит дальше.
Исключение из catch вылетает во внешний try.

Ловят исключение по ссылке, потому что очень активно используется иерархия исключений - хотим избежаьт slicing'а.

### Stack unwinding (раскрутка стэка) и уничтожение локальных ресурсов

Как только исключение бросается, оно летит по строчкам вверх (а не вниз, как каждая уважающая себя программа), и уничтожает всё, что встречается ему на пути (вызываются деструкторы).
Когда оно доходит до первого блока try, оно прекращает лететь вверх и идёт к блокам catch.
Там исключение ищет себе подходящий вход. Когда оно его находит - начнается обработка этого исключения. Внутри блока catch считается, что исключения уже нет.

**WARNING** Поскольку во время размотки стека вызываются деструкторы, то всякие указатели

### Идиома Resource Acquisition Is Initialization (RAII)

Расшифровка RAII: resource acquisition is initialization. Конструктор должен полностью проинициализировать класс и убедиться во всех инвариантах. А если не смог — кидаем исключение.

При этом, если из конструктора вылетело исключение, то использовать этот объект мы уже не сможем. Нам просто не дадут :с
### Примеры исключений из стандартной библиотеки (std::exception и его наследники, bad_alloc)

Самый базовый класс для ошибок - `std::exception`. От него наследуются все остальные (и принято наследовать свои классы ошибок).

Примеры классов ошибок и как они наследуются.

```
std::exception
│   virtual const char *what() const;    
│
└───std::logic_error
│   │
│   └───std::invalid_argument
│   │
│   └───std::out_of_range
│   
└───std::runtime_error
│   
└───my_logic_exception
        *этот класс пользовательский, при большом желании можно ненаследовать*
```
