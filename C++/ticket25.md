## Билет 25
Автор: Юра Худяков, Алексей Лучинин

#### Конвенции именований стандартной библиотеки, отличия stdio.h и cstdio

(украдено из 29 билета)

Язык С++ позволяет использовать всю стандартную библиотеку языка С, но появляется еще и собственная стандартная библиотека. Заметим, что STL (standard template library) - кусок стандартной библиотеки языка C++. Конвенция в стандартной библиотеке C++: заголовок пишется без разширений (например, без `.h`). Добавил что-то свое в `std` - за парой исключений получил UB. Для стандартных заголовков из C есть два варианта их подключения:

* `<stdio.h>` - попадает в глобальный namespace (`::fopen`), может положить что-то в `std`
* `<cstdio>` - попадает в `std` (`::std::fopen`), может положить что-то в глобальный

Можно использовать оба, но лучше придерживаться одного стиля и использовать один.  
`#include <bits/stdc++.h>` — нестандартный заголовок из GCC, зависит от версии, лучше не использовать.

### Последовательные контейнеры

Хранят элементы в фиксированном пользователем порядке.

* `array`
* `list`
* `forward_list`
* `string`
* `vector`
* `deque`

Далее - будто мы сделали `using std::` от всего, что выше (автору лень писать std::)

#### array

* Удобный Сишный массив: знает свой размер, имеет random-access итераторы
* Хранится на стеке без динамической памяти: размер определяется шаблонным аргументом
    ```c++
    array<int, 229> ar;
    ```
* Является агрегатом, можно сделать
    ```c++
    array<int, 229> ar = {1, 3, 3, 7};
    ```
* Из необычного: есть метод `fill(value)`, у остальных контейнеров такого нет. Заполняет значением `value`, как понятно из названия
* Итераторы не инвалидируются никогда. Удобно, правда? Но при этом если произойдёт `swap`, тогда то, на что указывали итераторы, может поменяться (хранилища местами поменяли). Что прикольно: **такое же** поведение и в других ниже перечисленных, **кроме** string
* Ещё можно юзать как `tuple` с элементами одинакового размера, зачем-то (cppreference сказал такое применение).
* Если размер 0, то звать `front(), back()`, присваивать по индексу и т.п. - нельзя, UB

`array` - особенный, у него фиксированное количество элементов. 

Остальные обычно умеет большее:  [cppreference](https://en.cppreference.com/w/cpp/named_req/SequenceContainer) и далее ниже

* `Container(n, t)` — `n` копий `t`, требует `CopyInsertable`.
* Оператор присваивания есть, требует ещё и `CopyAssignable`.
* `a.emplace(p, args..)` — в точке `p` создаётся новый объект, конструктору аргументы `args..`. Для `vector` и `deque` требуется `MoveInsertable`+`MoveAssignable`.
  Возвращает итератор на вставленный элемент.
* `a.insert(p, t)` — в точке `p` создаётся копия, надо `CopyInsertable` или `MoveInsertable` (в зависимости от категории `t`).
  Есть ещё версия, которая вставляет `n` копий, которая вставляет полуинтервал между парой итераторов, контейнер целиком, initalizer list... думаю, стоит о этих перегрузках сказать, а расписывать в подробностях нет особо смысла.
  Возвращает итератор на первый вставленный элемент (или на `p`, если их нет).
* `a.erase(it)` — удалить элемент `p`. Для `vector` и `deque` требуется `MoveAssignable`.
  Есть ещё версия, которая удаляет полуинтервал.
  Возвращает итератор на элемент после последнего удалённого (или на `end`, если удалили самый последний элемент).
  Могут спросить, а зачем возвращать итератор на элемент, который после. Пример кода: хотим удалить все чётные элементы
  ```c++
   for (auto it = values.begin(); it != values.end(); ) {
       if (*it % 2 == 0) {
          it = values.erase(it);
       } else {
          it++;
       }
   }
  ```
  Нам необходимо знать, какой там следующий, потому что ++ мы не можем сделать - итератор уже сдох (инвалидировался). (по факту, это пример своего `erase_if` для, например, списков)

* `a.assign(begin, end)` — переприсвоить элементы на значения из полуинтервала (или контейнера, или сделать `n` копий). Умеет ещё из InputIterator-а брать.
  Это круче `=`, когда мы 1) не хотим лишние копии; или 2) типы контейнеров не сошлись: 
  ```c++
  vector<Base*> v; 
  vector<Derived*> d; 
  v.assign(d);
  ```
* `a.clear()` - уничтожает (вызывает деструкторы) всех объектов в контейнере. У вектора и строчки память не чистит! (до C++11 может и чистит, а после точно нет, `capacity` остаётся тем же). Про обращения с памятью у листа и дека на cppreference я не нашёл, возможно, это зависит от конкретной реализации. Написано лишь, что инвалидирует все итераторы, указатели итп.
   [stackoverflow](https://stackoverflow.com/questions/18467624/what-does-the-standard-say-about-how-calling-clear-on-a-vector-changes-the-capac/18467916#18467916)


У некоторых бывает:
* `front()`/`back()` — возвращают ссылки
* `(emplace|push|pop)_(front|back)` — ничего не возвращают; `emplace` возвращает ссылку, начиная с C++17.
    Или для людей:
    * `emplace_front, emplace_back`
    * `push_front, push_back`
    * `pop_front, pop_back`
* `a[n]` — возвращают ссылку
* `a.at(n)` — возвращает ссылку и кидает `out_of_range` если выход за границу.

#### vector
* Обязан хранить элементы в памяти подряд.
  В стандарте прописано, что должна работать арифметика указателей.
* За амортизированную константу работает с хвостом.
* За линию добавляет и удаляет элементы
* Есть `capacity()` — размер текущего буфера памяти.
* Есть `size()` — реальный размер.
* Реаллокация инвалидирует все итераторы, указатели, ссылки.
* Можно вызвать `reserve` — увеличить `capacity` хотя бы до аргумента. Реаллокация.
* `shrink_to_fit()` — вежливо просит уменьшить `capacity()` до `size()`, помувает из старого хранилища в новое, поменьше. 
    Но никто не гарантирует, что он это сделает. Например, есть такая шняга, как SSO - Short String Optimization, суть: не выделяем для коротких строчек в std::string массив (std::array, возможно) на куче, вместо этого выделяем маленький на стеке (типа 20 элементов, у меня (Юра) на компе 15). 
    Подробнее почитать можно вроде бы тут: [stackoverflow](https://stackoverflow.com/a/10319672)
* `T* data()` — возвращает чистый указатель на данные.
* Удаление реаллокацию не вызывает, но инвалидирует указатели и ссылки на элементы после `erase`.
* swap как в array

#### `vector<bool>`
* Больше нет требования на непрерывность.
* Есть __рекомендация__ хранить упаковано в биты.
  Меньше памяти, но потенциально медленнее.
  Когда-то казалось хорошей идеей. Но по факту - не очень.
* Есть `flip()` — перевернуть все значения. У остальных такого нет.
* Есть проблемы с прокси-объектами:
    Возвращаем прокси объект, чтобы уметь присваивать в биты:
    ```c++
    vector<bool> v(100);
    v[5] = 1;
    ```
    Но это: медленно, а ещё в местах, где обычный вектор работает, `vector<bool>` не работает
    ```c++
    bool& x = &v[5];
    ```
    Не работает.
    Или, например, хотим range-based for
    ```c++
        for (auto& i: v) { // с int ок, с bool не скомпилится, так как прокси объект возвращается как rvalue, то есть const и к нему не привязаться
            i = i^1;
        }
        for (auto i: v) { // с int ок, копия, а bool будет меняться
            i = i^1;
        }
        // с for (const auto& i: v) оба ок, но в обоих случаях не меняемый
    ```
    Решение - `auto&&`
    ```c++
        for (auto&& i: v) { // для int возвращается lvalue, так что это будет auto& i:v, а для bool возвращается rvalue и это будет auto i:v
        {
            i = i^1;
        }
        // сильно подробнее о хрени выше можно почитать в 17 билете (о auto&&) или в конце 34 билета (о vector<bool>), если остаётся время во время подготовки, можно искать по ключевым словам в all-tickets.md
        // но это совсем допвопрос, можно это не обговаривать, так как и так билет большой, но стоит быть готовым, что проверяющий может спросить подробнее о проблемах vector<bool>
    ```
    Егор предлагал ссылки:
  * http://alenacpp.blogspot.com/2005/06/vector.html
  * http://www.gotw.ca/publications/mill09.htm

#### deque
* Умеет вставлять/удалять начало и в конец за константу (амортизированную или нет - на cppreference не указано);
  а ещё умеет за константу получать i-й элемент.
  * https://ru.stackoverflow.com/a/900583/210302 - здесь хорошо расписано, но чуть ниже я словами (неоч подробно) тоже расписал
  * На самом деле это как вектор, только запас в две стороны.
  * А чтобы много не копировать, обычно ещё дополнительно хранит элементы не последовательно, а блоками фиксированного размера (стандарт не обещает). Может быть так: куча мелких блоков, каждый может расти влево и вправо (чтобы расти влево, можно провернуть трюк как на алгосах с очередью: как бы 2 стека, просто растущих в разные стороны)

    Удобно: надо перевыделять только буфер блока, а не всё хранилище. 

    Минус: элементы в памяти не последовательно, нельзя пройтись по ним всем и вывести ([пример](https://github.com/yeputons/hse-2019-cpp/blob/master/32x-200606/code/03-vector-deque.cpp) с самой последней консультации по плюсам)
* `resize`: либо `pop_back()`, либо вставили сколько-то элементов в конец.
* Вставка в середину инвалидирует все итераторы и ссылки на элементы.
* Вставка в любой из концов инвалидирует только итераторы.
* Сложность вставки: линия от расстояния до ближайшего конца.
* Удаление:
  * Если удалили последний, то инвалидирует `end()` и итераторы на все удалённые.
  * Если удалили первый, но не последний, то только удалённые.
  * Если удалили из середины, то вообще всё.
  * Линия от расстояния до ближайшего конца.
* swap как в array

#### list
* Двусвязный список, удаление всегда за линию от количества элементов.
* Нельзя random access, итераторы и указатели не инвалидируются.
  Можно идти с начала, можно идти с конца за константу.
* Можно перемещать элементы из одного списка в другой:
1. `splice(iterator pos, list l) `
Вставляет полностью список `l` перед `pos`. Нельзя, чтобы `l == this`, то есть самого себя туда передавать нельзя!
`O(1)`, надо просто переставить указатели.
```cpp
std::list<int> list1 = { 1, 2, 3, 4, 5 };
std::list<int> list2 = { 10, 20, 30, 40, 50 };

auto it = list1.begin();
std::advance(it, 2); // сдвинули итератор на 2 вправо

list1.splice(it, list2);
// list1: 1 2 10 20 30 40 50 3 4 5
// list2: пустой
``` 
2. `splice(iterator pos, list l, iterator first, iterator second)`
Вырезает подотрезок из `l` и вставляет перед `pos`.
`O(n)`, так как мы не знаем сколько элементов между `first` и `second`, при этом `size()` должен работать за `O(1)`, поэтому мы проходимся по всем элементам между `first` и `second`.
```cpp
std::list<int> list1 = { 1, 2, 3, 4, 5 };
std::list<int> list2 = { 10, 20, 30, 40, 50 };

auto it1 = list1.begin();
std::advance(it1, 3);

auto it2 = list2.begin();
std::advance(it2, 2);

list1.splice(it1, list2, it2, list2.end());
// list1: 1 2 3 30 40 50 4 5
// list2: 10 20
``` 
3. Есть `remove`, `remove_if`, `unique`, `merge`, `reverse`, стабильный `sort`. Они являются методами `list`: не инвалидируют сам `list` (просто переставляют указатели), работают быстро и по-другому (обычный `sort` здесь работал бы долго или не работал бы вообще (проверил - не компилится!), так как ему нужны `random access` итераторы)

    `sort` наверняка сделан как `merge sort`, но явно это на [cppreference](https://en.cppreference.com/w/cpp/container/forward_list/sort) не указано.
* swap как в array

#### forward\_list
* Односвязный список. Умеет поменьше из-за однонаправленности, зато поэффективнее по памяти
* Нельзя сделать `insert`, надо `insert_after`, то есть вставлять перед не выйдет, надо вставлять после. 
    Методы, которые есть у `list` (типа `unique`, `merge` и т.п., смотри выше 3 пункт), есть и тут.
* swap как в array

#### string
* Не совсем контейнер, лежит в отдельной strings library.
* Последовательность символов.
  Похоже на `std::vector<char>`, но не гарантируется последовательная память и инвалидируется на очень много неконстантных действий.
  Может храниться как rope/deque/что угодно.
  [rope](https://en.wikipedia.org/wiki/Rope_(data_structure))
  Коротко: бинарное дерево, которое умеет быстро делать операции вставки, удаления, конкатенации (за логарифм). По факту можно сделать на Декартовом дереве по неявному ключу (или другом сбалансированном)
* Вообще, есть не только `string`, но и `basic_string<T>`: позволяет строку не по `char`-ам, а по любому типу. Но, кажется, нужно специализировать `char_traits` для работы, но мы это не обсуждали особо. Возможно, стоит в билете упомянуть, но особо в подробности не вдаваться. Я потестил немного: на float-ах норм создастся, но выводится `cout << s` не будет: он не знает `operator<<(basic_string<float>)`
* Есть `string == basic_string<char>` и `wstring == basic_string<wchar_t>`
* Есть встроенные методы, которые работают с индексами вместо итераторов.
  * `a.substr(first, length = std::string::npos)` // здесь std::string::npos - это максимально возможное значение `size_t`, то есть по сути замена `end`, возьмём подстрочку до конца строки
  * `a.find(substr, startPos = 0) --> pos` // startPos - откуда начинать искать, по умолчанию startPos = 0, но можно и не с 0.
* Есть `c_str()`, возвращает сишную строку, удалять не надо.
  До C++11 была `data()`, там не гарантировался завершающий ноль. С C++11 она осталась, но теперь синоним с `c_str()` и тоже имеет завершающий 0 в конце.
* Есть `append`, `+=`, `+` и другие удобные шняги, удобные для строк.
* swap инвалидидирует всё к чертям


#### Инвалидация итераторов

По идее, всё, что нужно, названо выше, но я нашёл ещё [это](https://stackoverflow.com/a/54004916), можно открыть и оттуда читать. На англе, да, но всё, что нужно, есть и выше, здесь просто в одном месте собрано.

Но там нет про строчки, и на cppreference тоже не особо, зато есть на [cplusplus.com](http://www.cplusplus.com/reference/string/string/) - можно по нужным методам побродить и понять, что очень многие инвалидируют. Вряд ли принимающий будет гонять наизусть, да и вы можете смотреть прямо во время рассказа туда. Мне кажется, хватит сказать, что очень многое инвалидирует.

В билете указано отдельно про `end()` - ну да, `begin(), end()` тоже могут инвалидироваться, например, когда `push_back()`-аешь или `push_front()`-аешь, или `insert`-аешь. 

Может быть важно сказать: везде, кроме std::string, при `swap()` итераторы не инвалидируются, а теперь указывают на то, что было на том же месте в другом контейнере, том, с которым свпонули.
